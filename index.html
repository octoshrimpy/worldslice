<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Slice-of-World Generator</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      @font-face {
        font-family: "unifontex";
        src: url("https://stgiga.github.io/UnifontEX/UnifontExMono.ttf");
        font-style: normal;
        font-weight: 400;
        font-display: block;
      }

      /* ====================== Sweetie16 (ONLY literal colors) ====================== */
      :root {
        --sw0: #1a1c2c;
        --sw1: #5d275d;
        --sw2: #b13e53;
        --sw3: #ef7d57;
        --sw4: #ffcd75;
        --sw5: #a7f070;
        --sw6: #38b764;
        --sw7: #257179;
        --sw8: #29366f;
        --sw9: #3b5dc9;
        --sw10: #41a6f6;
        --sw11: #73eff7;
        --sw12: #f4f4f4;
        --sw13: #94b0c2;
        --sw14: #566c86;
        --sw15: #333c57;

        /* ====================== App semantic vars ====================== */
        --bg: var(--sw0);
        --fg: var(--sw12);
        --mut: var(--sw13);
        --acc: var(--sw5);
        --btn: var(--sw15);
        --br: color-mix(in srgb, var(--sw12) 14%, transparent);

        --pane: var(--sw0);
        --pane2: color-mix(in srgb, black 40%, var(--sw0));
        --pill-bg: color-mix(in srgb, var(--sw0) 60%, var(--sw8));
        --pill-br: color-mix(in srgb, var(--sw7) 55%, transparent);

        /* cross-hover */
        --hot: var(--sw4);
        --hot-bg: color-mix(in srgb, var(--sw5) 14%, transparent);
        --hot-outline: color-mix(in srgb, var(--sw5) 28%, transparent);
        --ring: var(--sw5);

        /* ====================== Tile colors ====================== */
        --tile-water: var(--sw10);
        --tile-water-1: var(--sw10);
        --tile-water-2: var(--sw9);
        --tile-water-3: var(--sw8);
        --tile-lava-1: var(--sw2);
        --tile-lava-2: var(--sw3);
        --tile-lava-3: var(--sw4);

        --tile-mountain-1: var(--sw14);
        --tile-mountain-2: var(--sw13);
        --tile-mountain-3: var(--sw13);
        --tile-mountain-4: var(--sw13);
        --tile-mountain-5: var(--sw12);

        --tile-forest: var(--sw6);
        --tile-forest-deciduous: var(--sw6);
        --tile-forest-coniferous: var(--sw7);
        --tile-forest-dead: color-mix(in srgb, var(--sw4) 20%, var(--sw1));
        --tile-mycelium: color-mix(in srgb, var(--sw9) 50%, var(--sw2));

        --tile-grass: var(--sw6);
        --tile-grass-dead: color-mix(in srgb, var(--tile-grass) 60%, var(--sw1));
        --tile-plains: color-mix(in srgb, var(--sw5) 50%, var(--sw0));
        --tile-settlement: var(--sw2);
        --tile-camp: var(--sw3);
        --tile-ruins: var(--sw14);
        --tile-desert: color-mix(in srgb, var(--sw4) 70%, var(--sw1));
        --tile-religious-death: var(--sw3);
        --tile-religious-monastery: var(--sw11);
      }

      html,
      body {
        height: 100%;
        display: flex;
        flex-direction: column;
        margin: 0;
        padding: 0;
        background: var(--bg);
        color: var(--fg);
        font-family: "unifontex", system-ui, Segoe UI, Roboto, Inter, sans-serif;
      }

      header {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
        align-items: center;
        padding: 12px;
        border-bottom: 1px solid var(--br);
      }

      h1 {
        font-size: 16px;
        margin: 0 12px 0 0;
        color: var(--acc);
        flex: 1;
        white-space: nowrap;
      }

      label {
        color: var(--mut);
        font-size: 12px;
      }

      .menu-toggle {
        position: absolute;
        width: 1px;
        height: 1px;
        margin: -1px;
        border: 0;
        padding: 0;
        overflow: hidden;
        clip: rect(0 0 0 0);
        white-space: nowrap;
      }
      .menu-button {
        display: none;
        align-items: center;
        gap: 6px;
        padding: 7px 10px;
        border: 1px solid var(--br);
        border-radius: 6px;
        background: var(--btn);
        color: var(--fg);
        cursor: pointer;
      }
      .menu-icon {
        display: inline-block;
        width: 16px;
        height: 2px;
        background: currentColor;
        position: relative;
      }
      .menu-icon::before,
      .menu-icon::after {
        content: "";
        position: absolute;
        left: 0;
        width: 16px;
        height: 2px;
        background: currentColor;
      }
      .menu-icon::before {
        top: -5px;
      }
      .menu-icon::after {
        top: 5px;
      }
      .menu-content {
        display: inline-flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      input,
      select,
      button {
        background: var(--btn);
        color: var(--fg);
        border: 1px solid var(--br);
        border-radius: 6px;
        padding: 7px 10px;
      }

      input[type="text"] {
        min-width: 10rem;
      }

      button {
        cursor: pointer;
      }

      button:active {
        transform: translateY(1px);
      }

      .wrap {
        flex-grow: 1;
        padding: 12px;
        display: flex;
        gap: 12px;
      }

      .pane {
        border: 1px solid var(--br);
        border-radius: 8px;
        padding: 10px;
        background: var(--pane2);
        position: relative;
        display: flex;
        gap: 1rem;
        flex-grow: 1;
      }

      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      pre {
        white-space: pre;
        overflow: auto;
        margin: 0;
        font-family: "unifontex", system-ui, Segoe UI, Roboto, Inter, sans-serif;
      }

      #out {
        flex: 1;
        text-wrap: balance;
        color: var(--sw13);
      }

      #out .xref {
        text-decoration: underline;
        color: var(--sw6);
        text-decoration-color: var(--sw14);
        transition: all 0.15s ease-in-out;
      }
      #out .xref.is-hot {
        text-decoration: none;
      }

      .mapwrap {
        /* flex: 1; */
        display: flex;
        flex-direction: column;
        align-items: flex-end;
      }

      /* Larger, square-cell minimap */
      #map {
        margin-top: 8px;
        overflow: visible;
        cursor: pointer;
      }
      #map span {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        width: 1.2rem;
        height: 1.2rem;
        transition: all 0.15s ease-in-out;
        border-radius: 50%;
      }
      #map span:hover {
        transform: scale(1.3);
      }

      /* ========= Tile coloring (NO magic colors) ========= */
      #map span[data-tile="water"] {
        color: var(--tile-water);
      }
      #map span[data-tile="water"][data-depth="1"] {
        color: var(--tile-water-1);
      }
      #map span[data-tile="water"][data-depth="2"] {
        color: var(--tile-water-2);
      }
      #map span[data-tile="water"][data-depth="3"] {
        color: var(--tile-water-3);
      }
      #map span[data-tile="lava"][data-depth="1"] {
        color: var(--tile-lava-1);
      }
      #map span[data-tile="lava"][data-depth="2"] {
        color: var(--tile-lava-2);
      }
      #map span[data-tile="lava"][data-depth="3"] {
        color: var(--tile-lava-3);
      }


      #map span[data-tile="mountain"][data-height="1"] {
        color: var(--tile-mountain-1);
      }
      #map span[data-tile="mountain"][data-height="2"] {
        color: var(--tile-mountain-2);
      }
      #map span[data-tile="mountain"][data-height="3"] {
        color: var(--tile-mountain-3);
      }
      #map span[data-tile="mountain"][data-height="4"] {
        color: var(--tile-mountain-4);
      }
      #map span[data-tile="mountain"][data-height="5"] {
        color: var(--tile-mountain-5);
      }

      #map span[data-tile="forest"] {
        color: var(--tile-forest);
      }
      #map span[data-tile="forest"][data-forest="deciduous"] {
        color: var(--tile-forest-deciduous);
      }
      #map span[data-tile="forest"][data-forest="coniferous"] {
        color: var(--tile-forest-coniferous);
      }
      #map span[data-tile="forest"][data-forest="dead"] {
        color: var(--tile-forest-dead);
      }
      #map span[data-tile="mycelium"] {
        color: var(--tile-mycelium);
      }

      #map span[data-tile="grass"] {
        color: var(--tile-grass);
      }
      #map[data-dead-trees="1"] span[data-tile="grass"],
      #map[data-desert="1"] span[data-tile="grass"] {
        color: var(--tile-grass-dead);
      }
      #map span[data-tile="plains"] {
        color: var(--tile-plains);
      }
      #map span[data-tile="settlement"] {
        color: var(--tile-settlement);
      }
      #map span[data-tile="ruins"] {
        color: var(--tile-ruins);
      }
      #map span[data-tile="camp"] {
        color: var(--tile-camp);
      }
      #map span[data-tile="desert"] {
        color: var(--tile-desert);
      }
      #map span[data-tile="beach"] {
        color: var(--tile-desert);
      }
      #map span[data-tile="religious"][data-religious="death"] {
        color: var(--tile-religious-death);
      }
      #map span[data-tile="religious"][data-religious="monastery"] {
        color: var(--tile-religious-monastery);
      }

      .small {
        font-size: 12px;
        color: var(--mut);
      }

      ul.list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      ul.list li {
        background: var(--btn);
        border: 1px solid var(--br);
        padding: 4px 7px;
        border-radius: 6px;
        cursor: pointer;
      }
      ul.list li:hover {
        border-color: var(--acc);
      }

      .head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .mut {
        color: var(--mut);
      }
      .sep {
        height: 10px;
      }

      .pill {
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid var(--br);
        background: var(--pill-bg);
      }
      .pill.seedpill {
        margin-top: 2rem;
      }
      .nowrap {
        white-space: nowrap;
      }
      .seedpill {
        margin-left: 6px;
        color: var(--fg);
        border-color: var(--pill-br);
        background: var(--pill-bg);
      }

      @media (max-width: 45rem) {
        header {
          align-items: center;
          position: sticky;
          top: 0;
          z-index: 10;
          background: var(--bg);
        }
        .wrap {
          flex-direction: column;
        }
        .pane {
          flex-direction: column-reverse;
          align-items: stretch;
        }
        #out {
          width: 100%;
        }
        .mapwrap {
          width: 100%;
          align-items: flex-start;
        }
        .menu-button {
          display: inline-flex;
          margin-left: auto;
          position: absolute;
          top: 1rem;
          right: 1rem;
        }

        .row {
          flex: 1 1 100%;
        }
        .menu-content {
          display: none;
          width: 100%;
        }
        header:has(.menu-toggle:checked) .menu-content {
          display: flex;
        }
        #map {
          width: 100%;
          font-size: min(1.2rem, 3.5vw);
        }
        #map span {
          width: 1em;
          height: 1em;
          font-size: 1em;
        }
      }

      .hidden {
        display: none;
      }

      button.primary {
        background: color-mix(in srgb, var(--acc) 70%, var(--btn));
        color: var(--bg);
        font-weight: bold;
        transition: all ease-in-out 0.15s;
      }
      button.primary:hover {
        background: color-mix(in srgb, var(--acc) 80%, var(--btn));
      }

      /* ===== cross-hover linking ===== */
      #map span.is-hot {
        position: relative;
        transform-origin: center center;
        transform: scale(1.5);
      }
      #map span.is-hot::before {
        display: flex;
        height: 1.5rem;
        width: 1.5rem;
        border: 2px solid var(--ring);
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        background: var(--bg);
        z-index: -1;
        pointer-events: none;
      }

      #out .xref {
        cursor: pointer;
        border-radius: 4px;
        padding: 0 2px;
      }

      #out .xref.is-hot {
        color: var(--acc);
        background: var(--hot-bg);
        outline: 1px solid var(--hot-outline);
      }
    </style>
  </head>

  <body>
    <header>
      <h1>World Slice</h1>
      <input id="menuToggle" class="menu-toggle" type="checkbox" />
      <div class="row">
        <button id="prev">Prev</button>
        <button id="gen" class="primary">Generate</button>
        <button id="next">Next</button>
        <!-- <button id="save" title="Add current seed to favorites">Save</button> -->
        <span class="menu-content">
          <button id="copySeed" title="Copy current seed">Copy Seed</button>
          <label for="seed">Seed</label>
          <input id="seed" type="text" placeholder="Leave blank for random" />
          <label for="theme">Theme</label>
          <select id="theme" class="nowrap" title="Theme">
            <option value="rnd">Random (seed-based)</option>
            <option value="fantasy">Fantasy</option>
            <option value="scifi">Sci-fi</option>
            <option value="apocalypse">Post-apocalyptic</option>
          </select>
        </span>
        <!-- <button id="copyOut" title="Copy output text">Copy Output</button> -->
        <!-- <button id="share" title="Update URL with current seed/theme">Share</button> -->
      </div>
      <label for="menuToggle" class="menu-button">
        <span class="menu-icon" aria-hidden="true"></span>
        <span class="menu-text">Menu</span>
      </label>
    </header>

    <div class="wrap">
      <div class="pane">
        <pre id="out"></pre>
        <span class="mapwrap">
          <pre id="map"></pre>
          <span class="pill seedpill small">
            Seed:
            <strong id="seedShow">â€”</strong>
          </span>
        </span>
      </div>

      <div class="hidden">
        <div class="head">
          <strong>History</strong><span class="small mut">(latest 5)</span>
        </div>
        <div id="histWrap">
          <ul id="hist" class="list"></ul>
        </div>
        <div class="sep"></div>
        <div class="head favs">
          <strong>Favorites</strong><button id="clrFav" class="pill small">Clear</button>
        </div>
        <ul id="favs" class="list"></ul>
        <div class="sep"></div>
        <div class="small mut">
          Tip: press <strong>Enter</strong> in the seed box to use that seed once.
        </div>
      </div>
    </div>

    <script>
      /** 
       * TODO: map size next to seed pill, for small/med/large
       * TODO: wrap NPC names in span, color them --sw12
       * TODO: sometimes two locations are setup for a NPC task: `Khalem: repairing a broken bridge, lift, or passageway at Rail cathedral at Riros out in the wilds`, at rail cathedral but also at wilds. if this happens, the wilds needs to be within 3 tiles of the original mentioned spot. also make sure both spots are `is-hot` highlighted respectively.
       * TODO: hook grammar makes no sense when it combines multiple modifiers, e.g. "a relic goes missing near the rootbound enclave during light wind conditions". maybe only allow one modifier per hook?

      **/

      /* ====================== Tables (themes) ====================== */
      const GEO_FEATURES = [
        "river-water",
        "river-lava",
        "mountain",
        "lake", // not implemented yet
        "beaches", 
        "dunes",
        "oasis",
        "ruins",
        "ridge",
        "reef", // not implemented yet
        "mycelium",
        "dead trees",
      ];

      const T = {
        fantasy: {
          biome: [
            {
              name: "tundra",
              features: {
                "river-water": 0.3,
                lake: 0.25,
                mountain: 0.35,
                ridge: 0.4,
                ruins: 0.15,
              },
            },
            {
              name: "taiga",
              features: {
                "river-water": 0.45,
                lake: 0.35,
                mountain: 0.25,
                ridge: 0.3,
                ruins: 0.2,
                mycelium: 0.25,
              },
            },
            {
              name: "temperate forest",
              features: {
                "river-water": 0.5,
                lake: 0.35,
                ruins: 0.2,
                ridge: 0.2,
                mycelium: 0.3,
              },
            },
            {
              name: "steppe",
              features: {
                "river-water": 0.25,
                lake: 0.15,
                "watering hole": 0.3,
                dunes: 0.25,
                ridge: 0.2,
                ruins: 0.15,
              },
            },
            {
              name: "savanna",
              features: {
                "river-water": 0.35,
                lake: 0.2,
                "watering hole": 0.45,
                dunes: 0.2,
                oasis: 0.15,
                ruins: 0.1,
              },
            },
            {
              name: "desert",
              features: {
                "river-water": 0.1,
                lake: 0.05,
                "watering hole": 0.3,
                dunes: 0.6,
                oasis: 0.4,
                ruins: 0.25,
                ridge: 0.25,
                "river-lava": 0.1,
              },
            },
            {
              name: "jungle",
              features: {
                "river-water": 0.6,
                lake: 0.35,
                ruins: 0.25,
                lagoon: 0.25,
                mycelium: 0.4,
              },
            },
            {
              name: "wetlands",
              features: {
                "river-water": 0.7,
                lake: 0.45,
                lagoon: 0.4,
                mycelium: 0.3,
                ruins: 0.15,
              },
            },
            {
              name: "highlands",
              features: {
                "river-water": 0.3,
                mountain: 0.7,
                ridge: 0.6,
                lake: 0.2,
                "river-lava": 0.15,
                ruins: 0.2,
              },
            },
            {
              name: "islands",
              features: {
                "river-water": 0.25,
                lake: 0.2,
                reef: 0.7,
                lagoon: 0.6,
                dunes: 0.2,
                ruins: 0.25,
              },
            },
            {
              name: "badlands",
              features: {
                "river-water": 0.15,
                mountain: 0.4,
                ridge: 0.6,
                dunes: 0.3,
                ruins: 0.35,
                "river-lava": 0.2,
                "dead trees": 0.3,
              },
            },
          ],
          temp: {
            1: "gelid",
            2: "frigid",
            3: "chill",
            4: "mild",
            5: "warm",
            6: "balmy",
            7: "sultry",
            8: "searing",
          },
          rain: ["parched", "dry", "breezy", "misty", "drizzled", "rain-washed", "monsoonal", "storm-lashed"],
          climateAdj: [
            "rocky",
            "dusty",
            "foggy",
            "smoky",
            "cracked",
            "scarred",
            "shadowed",
            "glowing",
            "pitted",
            "overgrown",
            "mossy",
            "fungal",
            "boggy",
            "marshy",
            "rooted",
            "thorny",
            "brambly",
            "ancient",
            "veined",
            "twilight",
            "starlit",
            "moonlit",
            "buried",
            "forgotten",
          ],
          factionsN1: [
            "Order",
            "Guild",
            "Clan",
            "Court",
            "Circle",
            "Syndicate",
            "Chapter",
            "Coven",
            "Brotherhood",
            "Company",
            "League",
            "Consulate",
            "Caravan",
            "Enclave",
            "Assembly",
            "Dominion",
            "Conclave",
            "Pact",
            "Sect",
            "Keep",
            "Banner",
            "Throng",
            "Kin",
            "House",
            "Hollow",
            "Sanctum",
            "Forge",
            "Crusade",
            "March",
            "Host",
          ],
          factionsN2: ["of the", "of", "for the", "under", "against the", "beneath the", "among the", "beyond the", "within the", "beside the", "before the", "after the", "toward the", "upon the"],
          roles: [
            "Wardens",
            "Archivists",
            "Bonepickers",
            "Skyfarers",
            "Prospectors",
            "Scribes",
            "Wayfinders",
            "Stormcallers",
            "Reclaimers",
            "Oathkeepers",
            "Lamplighters",
            "Seers",
            "Witchbinders",
            "Lorehunters",
            "Pathmakers",
            "Gravetenders",
            "Runesmiths",
            "Beastwalkers",
            "Spellweavers",
            "Hearthguard",
            "Frostborn",
            "Flamebearers",
            "Thornwatch",
            "Miststriders",
          ],
          motives: [
            "guarding",
            "restoring",
            "cleansing",
            "protecting",
            "mapping",
            "exploring",
            "sealing",
            "unsealing",
            "harvesting",
            "reclaiming",
            "binding",
            "awakening",
            "silencing",
            "tending",
            "unlocking",
            "tracking",
            "defending",
            "consecrating",
            "studying",
            "excavating",
          ],
          motiveGlue: ["the only remaining", "a", "an ancient", "a forgotten", "a cursed", "the last", "a sacred", "a sealed", "an abandoned", "a hidden", "a buried", "a ruined", "a lost", "a reclaimed"],
          relicAdjectives: [
            "ancient",
            "forgotten",
            "sealed",
            "cracked",
            "hallowed",
            "bound",
            "runed",
            "sunken",
            "twilight",
            "blood-marked",
            "iron-bound",
            "frosted",
            "echoing",
            "cursed",
            "blessed",
            "hidden",
            "star-forged",
            "bone-carved",
          ],
          relicNouns: ["tablet", "idol", "scroll", "blade", "mask", "sigil", "key", "horn", "stone", "ring", "crown", "lens", "staff", "seal", "totem", "mirror", "lock", "gem", "vessel", "pendant"],
          pois: [
            "relic line",
            "forgotten cairn",
            "leyline path",
            "star-iron vein",
            "storm cycle",
            "dune-wyrm pact",
            "glowmoss field",
            "floodgate",
            "hearthhold",
            "shattered runestone",
            "cursed grove",
            "ancestral cairn",
            "rootbound enclave",
            "dormant sentinel",
            "echoing tomb",
            "emberfield",
            "sealed vault",
            "moonshade beast",
            "sky-bridge",
            "sunken sanctuary",
          ],
          weather: [
            "light wind",
            "fine dust in the air",
            "low thunder",
            "steady breeze",
            "scattered clouds",
            "brief gusts",
            "thin mist",
            "dry air",
            "occasional flashes",
            "soft rainfall",
            "distant rumble",
            "light haze",
            "static in the air",
            "drifting ash",
            "stillness before change",
            "faint crackling",
            "settling silt",
            "air thick with pollen",
            "cool drafts",
            "humid stillness",
          ],
          hooks: [
            "an oath breaks",
            "a relic goes missing",
            "a boundary marker is moved",
            "the river changes course",
            "the caravan doesn't arrive",
            "a ward stops working",
            "a beast emerges from the quarry",
            "a gate opens without warning",
            "a name is removed from the scrolls",
            "the harvest comes too early",
            "the flame marks someone new",
            "the map is altered",
            "a rival claims blood-right",
            "the tithe causes unrest",
            "the monolith sinks faster",
            "the plants react to movement",
            "a vault is uncovered",
            "the sky cracks at dawn",
            "a sigil appears",
            "the well runs dry",
          ],
          hookMods: ["near the <poi>", "within the biome", "during <weather> conditions", "beneath the <poi>", "around the <poi>", "when passing through the biome", "when the wind shifted to <weather>"],
          hookGlue: ["and", "but", "while", "as", "yet", "then", "though", "because", "when", "just as"],
        },

        scifi: {
          biome: [
            {
              name: "oceanic world",
              features: {
                reef: 0.8,
                lagoon: 0.7,
                "river-water": 0.3,
                lake: 0.2,
                ruins: 0.15,
              },
            },
            {
              name: "barren craters",
              features: {
                ridge: 0.6,
                mountain: 0.4,
                "river-lava": 0.2,
                ruins: 0.2,
                lake: 0.05,
              },
            },
            {
              name: "lava fields",
              features: {
                "river-lava": 0.8,
                mountain: 0.5,
                ridge: 0.4,
                ruins: 0.15,
              },
            },
            {
              name: "arboreal belts",
              features: {
                "river-water": 0.5,
                lake: 0.3,
                ruins: 0.2,
                mycelium: 0.25,
              },
            },
            {
              name: "fungal mats",
              features: {
                mycelium: 0.8,
                lake: 0.25,
                "river-water": 0.35,
                ruins: 0.2,
              },
            },
            {
              name: "erg desert",
              features: {
                dunes: 0.8,
                oasis: 0.35,
                "watering hole": 0.2,
                "river-water": 0.15,
                ruins: 0.2,
              },
            },
            {
              name: "ice shelf",
              features: {
                lake: 0.3,
                "river-water": 0.2,
                ridge: 0.35,
                mountain: 0.3,
                ruins: 0.1,
              },
            },
            {
              name: "toxic bogs",
              features: {
                "river-water": 0.5,
                lake: 0.4,
                lagoon: 0.25,
                ruins: 0.2,
                mycelium: 0.3,
              },
            },
            {
              name: "megacity sector",
              features: {
                ruins: 0.6,
                ridge: 0.3,
                "river-water": 0.25,
                lake: 0.15,
              },
            },
            {
              name: "ring habitat",
              features: {
                "river-water": 0.35,
                lake: 0.25,
                lagoon: 0.3,
                ridge: 0.2,
                ruins: 0.2,
              },
            },
            {
              name: "tidal wetlands",
              features: {
                "river-water": 0.6,
                lagoon: 0.6,
                reef: 0.4,
                lake: 0.3,
                mycelium: 0.2,
              },
            },
          ],
          temp: { 1: "cryonic", 2: "subzero", 3: "brisk", 4: "temperate", 5: "warm", 6: "tropic", 7: "equatorial", 8: "thermic" },
          rain: ["arid", "dry winds", "breezy", "humid", "mist-laden", "rainy", "storm-charged", "ion-saturated"],
          climateAdj: [
            "rocky",
            "dusty",
            "foggy",
            "smoky",
            "cracked",
            "scarred",
            "shadowed",
            "glowing",
            "pitted",
            "overgrown",
            "synthetic",
            "alien",
            "metallic",
            "magnetic",
            "gravitic",
            "orbital",
            "stellar",
            "lunar",
            "tidal",
            "crystalline",
            "coralline",
            "glassy",
            "mutant",
            "viral",
            "sentient",
            "abandoned",
            "encrypted",
            "rifted",
            "plasmatic",
          ],
          factionsN1: [
            "Consortium",
            "Syndicate",
            "Research Cell",
            "Freeport",
            "Colonial Office",
            "Outer Rim Guild",
            "Scavenger Crew",
            "Offworld Temple",
            "AI Collective",
            "Orbital Chapter",
            "Relay Cartel",
            "Trade Assembly",
            "Quantum Union",
            "Terraform Bureau",
            "Signal Corps",
            "Drift Network",
            "Cryo Division",
            "Echo Fleet",
            "Archive Node",
            "Security Cluster",
            "Mining Authority",
          ],
          factionsN2: ["of", "for", "operating in", "under", "over", "near", "within", "against", "aligned with", "based in"],
          roles: ["Surveyors", "Archivists", "Salvagers", "Datawrights", "Terraformers", "Smugglers", "Peacekeepers", "Prospectors", "Hackers", "Vigil AIs", "Skyfarers", "Signalers", "Cryotechs", "Synthbinders"],
          motives: [
            "guarding",
            "restoring",
            "studying",
            "protecting",
            "mapping",
            "exploring",
            "sealing",
            "unsealing",
            "harvesting",
            "reclaiming",
            "activating",
            "decrypting",
            "tracking",
            "repairing",
            "scanning",
            "hacking",
            "salvaging",
            "monitoring",
            "rebooting",
          ],
          motiveGlue: ["the only remaining", "a", "an old", "a sealed", "a forgotten", "a derelict", "a hidden", "an encrypted"],
          relicAdjectives: ["encrypted", "forgotten", "sealed", "quantum", "bio-locked", "holographic", "corrupted", "archived"],
          relicNouns: ["core", "drive", "node", "key", "vault", "chip", "beacon", "archive", "relay", "protocol"],
          pois: ["orbital spine", "seed vault", "phase-burned crater", "maglev trench", "signal relay", "data vault", "drift station"],
          weather: ["static rain", "an ion flash", "dust drift", "signal interference", "electrical haze", "solar flare scatter"],
          hooks: ["a ghost ping repeats each dusk", "a vault opens for the first time", "a comms blackout spreads", "a relay node reboots unexpectedly", "a drone fails to report", "a beacon activates without command"],
          hookMods: ["near the <poi>", "inside the <poi>", "during <weather>", "as <weather> builds", "after <weather> clears"],
          hookGlue: ["and", "but", "while", "as", "yet", "then", "though", "because", "even as", "just as"],
        },

        apocalypse: {
          biome: [
            {
              name: "ruined city",
              features: {
                ruins: 0.9,
                "river-water": 0.25,
                lake: 0.15,
                ridge: 0.2,
                mycelium: 0.2,
                "dead trees": 0.2,
              },
            },
            {
              name: "wasteland",
              features: {
                ruins: 0.4,
                ridge: 0.4,
                mountain: 0.3,
                "river-lava": 0.15,
                dunes: 0.25,
                "watering hole": 0.1,
                "dead trees": 0.4,
              },
            },
            {
              name: "overgrowth",
              features: {
                "river-water": 0.5,
                lake: 0.3,
                ruins: 0.35,
                mycelium: 0.5,
                lagoon: 0.2,
              },
            },
            {
              name: "floodplain",
              features: {
                "river-water": 0.75,
                lake: 0.5,
                lagoon: 0.35,
                ruins: 0.2,
                reef: 0.1,
              },
            },
            {
              name: "ash desert",
              features: {
                dunes: 0.7,
                "river-lava": 0.35,
                ridge: 0.3,
                ruins: 0.25,
                oasis: 0.15,
                "watering hole": 0.2,
                "dead trees": 0.3,
              },
            },
            {
              name: "irradiated zone",
              features: {
                ruins: 0.4,
                ridge: 0.3,
                "river-lava": 0.2,
                lake: 0.2,
                mycelium: 0.25,
                "dead trees": 0.35,
              },
            },
            {
              name: "salt flats",
              features: {
                lake: 0.25,
                dunes: 0.4,
                ridge: 0.3,
                "river-water": 0.15,
                ruins: 0.2,
                oasis: 0.1,
              },
            },
            {
              name: "scrapyard dunes",
              features: {
                dunes: 0.8,
                ruins: 0.5,
                ridge: 0.3,
                "river-lava": 0.2,
                "watering hole": 0.1,
                "dead trees": 0.25,
              },
            },
            {
              name: "bunker valley",
              features: {
                mountain: 0.4,
                ridge: 0.5,
                "river-water": 0.25,
                lake: 0.2,
                ruins: 0.35,
              },
            },
            {
              name: "shattered highlands",
              features: {
                mountain: 0.7,
                ridge: 0.7,
                "river-lava": 0.25,
                ruins: 0.25,
                lake: 0.15,
                "dead trees": 0.25,
              },
            },
            {
              name: "canal maze",
              features: {
                "river-water": 0.8,
                lagoon: 0.6,
                lake: 0.4,
                ruins: 0.3,
                reef: 0.1,
              },
            },
          ],
          temp: { 1: "frost-bit", 2: "cold", 3: "cool", 4: "mild", 5: "warm", 6: "hot", 7: "blistering", 8: "oven-hot" },
          rain: ["powder-dry", "dry gusts", "dusty", "clammy", "drizzle", "rain-battered", "monsoon-bent", "electric storms"],
          climateAdj: [
            "rocky",
            "dusty",
            "foggy",
            "smoky",
            "cracked",
            "scarred",
            "shadowed",
            "glowing",
            "pitted",
            "overgrown",
            "sooty",
            "ashen",
            "shattered",
            "rusted",
            "abandoned",
            "buried",
            "sealed",
            "forgotten",
            "viral",
            "mutant",
            "slimed",
            "broken",
            "ruined",
            "hollow",
          ],
          factionsN1: ["Remnants", "Road Kings", "Canal Commune", "Vault Kin", "Scrap Choir", "Spore Ward", "Signal House"],
          factionsN2: ["of", "at", "over", "under", "through", "against", "within", "near", "beyond", "inside", "along", "beneath"],
          roles: ["Scavvers", "Archivists", "Pickers", "Claimants", "Watchers", "Riggers", "Spanners", "Guides", "Slingers"],
          motives: ["guarding", "claiming", "mining", "fighting", "hoarding", "charting", "towing", "sealing", "trading", "repairing"],
          motiveGlue: ["the only remaining", "a", "an old", "a sealed", "a flooded", "a broken", "a buried", "a rusted", "a forgotten"],
          relicAdjectives: ["sealed", "rusted", "burned", "coded", "scrapped", "buried", "cracked", "patched", "irradiated", "forgotten"],
          relicNouns: ["vault", "badge", "drive", "mask", "chip", "tag", "key", "module", "canister", "token", "seal", "crate"],
          pois: ["interchange", "metro mouth", "signal tower", "mall", "canal gate", "rail cathedral", "salt pit", "water plant"],
          weather: ["static rain", "polluted snow", "heat shimmer", "metallic drizzle", "smoke squalls", "acid mist", "radio interference"],
          hooks: ["a treaty flag burns", "a convoy goes missing", "a bunker door opens on its own", "a warning light blinks without power", "a flare goes up with no claim"],
          hookMods: ["near the <poi>", "inside the <poi>", "during <weather>", "as <weather> builds", "after <weather> clears"],
          hookGlue: ["and", "but", "while", "as", "yet", "then", "though", "because", "even as", "just as"],
        },
      };
            
      const FIELD_MOTIVE_VERBS = [
        "mining",
        "harvesting",
        "excavating",
        "mapping",
        "exploring",
        "tracking",
        "studying",
        "scanning",
        "salvaging",
        "charting",
        "reclaiming",
      ];

      const NPC_TASKS = {
        faction: [
          "recruiting new members for a difficult assignment",
          "screening applicants after a recent breach",
          "guarding a cache of supplies near <poi>",
          "guarding a sealed storehouse whose lock has begun to fail",
          "escorting a courier between safehouses",
          "escorting a dignitary through contested ground",
          "training new initiates in {protocol|discipline}",
          "drilling a response team for an expected incursion",
          "auditing {relics|records|inventories} for discrepancies",
          "investigating forged credentials circulating among allies",
          "negotiating a fragile truce over access to <poi>",
          "enforcing a disputed boundary marker near <poi>",
          "recovering a stolen insignia tied to {leadership|authority}",
          "hunting an infiltrator who knows internal routes",
          "coordinating a joint operation with an uneasy partner",
          "planning a raid or recovery mission timed with <weather>",
          "intercepting contraband moving through the biome",
          "protecting a witness scheduled to testify at a council",
          "relocating a vulnerable cell before the next crackdown",
          "disabling a rival outpost overlooking <poi>",
          "repairing a failing {ward|gate|lock|access point}",
          "attempting to reactivate a dormant asset at <poi>",
          "silencing rumors that could fracture the ranks",
          "delivering an ultimatum to a rival faction",
          "hosting a tribunal for a member accused of betrayal",
          "tracking a missing squad last seen near <poi>",
          "securing a route for a coming convoy",
          "mapping contacts and loyalties inside a contested district",
          "recovering a lost map that details hidden approaches",
          "testing a {prototype tool|ritual} under field conditions",
          "containing an outbreak of panic after <weather>",
          "negotiating trade rights in exchange for protection",
          "redistributing rations after an unexpected shortage",
          "guarding a prisoner transfer through hostile ground",
          "searching for a specialist needed to stabilize <poi>",
          "tending a wounded leader while rivals circle",
          "covering up a mistake before it becomes public",
          "investigating a sabotage incident in the faction's stores",
          "retrieving a message that must not be read by outsiders",
          "{binding|sealing|securing} a dangerous discovery at <poi>",
          "monitoring a repeating signal/omen tied to <poi>",
          "setting a trap for a rival team operating near <poi>",
          "running security for a clandestine meeting during <weather>",
          "conducting a census of members and dependents",
          "escorting a defector who wants asylum",
          "protecting a critical shipment during <weather>",
          "investigating why a long-trusted contact went silent",
          "clearing a safehouse compromised by an unknown contaminant",
        ],

        settlement: [
          "repairing the waterworks after <weather>",
          "patching leaks and reinforcing cisterns ahead of <weather>",
          "restoring power/heat/light to a key block of homes",
          "fixing a jammed {gate|lift|lock|access mechanism} at <poi>",
          "tracking a series of thefts that target essentials",
          "investigating a break-in at a storeroom near <poi>",
          "organizing a trade caravan and negotiating safe passage",
          "preparing a ration exchange with an unreliable partner",
          "hosting a tense council meeting about <poi>",
          "mediating a feud that threatens to split the community",
          "surveying new housing sites away from known hazards",
          "mapping structural risks in older tunnels/buildings",
          "investigating a strange illness spreading after <weather>",
          "quarantining a block and tracing the source to <poi>",
          "clearing rubble to reopen a route to <poi>",
          "reinforcing defenses after a warning sign at <poi>",
          "training volunteers for watch duty and emergency response",
          "rescuing trapped workers during <weather>",
          "finding a replacement part/resource the settlement can't do without",
          "recovering a lost tool kit critical to maintenance",
          "auditing stores because supplies don't match the ledgers",
          "running a controlled burn / purge / cleanup of a contaminated zone",
          "investigating a suspicious fire that started too cleanly",
          "negotiating a marriage pact / adoption / sponsorship to secure alliances",
          "settling a land claim dispute over the edge of the biome",
          "evacuating families after a new hazard appears near <poi>",
          "escorting a visiting envoy through nervous streets",
          "hosting a ceremony that must not be interrupted",
          "burying the dead and appeasing the living after a tragedy",
          "repairing communications lines after <weather>",
          "tracking why patrols keep missing check-ins near <poi>",
          "building a new market route that avoids a dangerous stretch",
          "shoring up walls and walkways before the next <weather>",
          "investigating counterfeit {tokens|ration chits|permits} circulating locally",
          "hunting down a black-market supplier poisoning the town",
          "organizing a salvage lottery that's turning violent",
          "recovering a child/elder who wandered toward <poi>",
          "escorting healers/engineers to a worksite near <poi>",
          "replacing leadership after a sudden resignation",
          "investigating a ghost story that's driving people away from <poi>",
          "securing a festival with rising tensions and hidden weapons",
          "disarming a booby trap found in a common thoroughfare",
          "patching a collapsed tunnel/bridge caused by <weather>",
          "moving the seed stores / archives / reliquary to a safer vault",
          "interviewing newcomers whose story doesn't add up",
          "negotiating protection payments under threat",
          "tracking a predator that hunts livestock near <poi>",
          "testing a new well/route that may be cursed/unsafe/unstable",
          "restoring the local map after someone altered it",
        ],

        world: [
          "mapping an new trail that skirts <poi>",
          "charting safe routes as <weather> builds",
          "guiding travelers through hostile ground to <poi>",
          "escorting {pilgrims|refugees|traders} across the biome",
          "hunting a dangerous creature seen near <poi>",
          "tracking something that leaves no prints after <weather>",
          "recovering a lost expedition last seen near <poi>",
          "searching for a missing scout who vanished during <weather>",
          "salvaging a ruined site for usable parts and supplies",
          "extracting valuable material from a hazardous zone near <poi>",
          "scouting a rival camp positioned near <poi>",
          "observing an encroaching force without being detected",
          "securing a crossing after the terrain shifts near <poi>",
          "repairing a broken {bridge|lift|passageway} at <poi>",
          "investigating why an old marker no longer matches the land",
          "following a repeating {signal|omen} that points toward <poi>",
          "{closing|sealing|stabilizing} a breach at <poi>",
          "unsealing a site at <poi> under strict precautions",
          "retrieving a {relic|container|data-cache} rumored to be in <poi>",
          "delivering a message through a zone nobody wants to cross",
          "recovering a downed {cart|sled|rig} stranded by <weather>",
          "clearing a path through {overgrowth|rubble|drifted dunes} near <poi>",
          "setting up a remote observation post overlooking <poi>",
          "testing whether the {water|air|soil} is safe beyond the ridge",
          "tracking a {poacher|scavenger crew} operating near <poi>",
          "negotiating {passage|terms} with a territorial group beyond the border",
          "discovering why local the {wildlife|fauna|tribe} avoids <poi>",
          "finding the source of strange lights/sounds near <poi>",
          "recovering supplies dropped during a retreat",
          "investigating an abandoned camp where everything was left behind",
          "locating a hidden {cache|<item>} mapped only in partial coordinates",
          "escorting a specialist needed to handle <poi>",
          "running a diversion to pull attention away from <poi>",
          "delivering {emergency medicine|supplies|equipment} to an isolated outpost",
          "surveying terrain for a future {settlement site|outpost|relay station}",
          "finding fresh water in a parched stretch of the biome",
          "tracking the movement of a storm front that behaves oddly",
          "recovering a stolen map and identifying who copied it",
          "investigating a boundary marker that was moved overnight",
          "following a trail of messages {carved|encoded} along the route",
          "retrieving proof of a rival's wrongdoing from <poi>",
          "rescuing captives taken toward <poi>",
          "destroying a hazard source without triggering worse consequences",
          "confirming whether <poi> is truly empty or merely silent",
          "bringing back a {sample|artifact} from <poi> without contamination",
          "finding a safer detour after <weather> made the main route impassable",
          "tracking a caravan that never arrived from the direction of <poi>",
          "retrieving a lost {heirloom|<item>} that may start a war if mishandled",
          "investigating a new {sinkhole|collapse} revealed after <weather>",
        ],
      };

      /* ====================== Tileset (no colors here; CSS drives colors) ====================== */
      const tileset = {
        water: { depthGlyphs: { 1: "~", 2: "â‰ˆ", 3: "â‰‹" } },
        lava: { depthGlyphs: { 1: "~", 2: "â‰ˆ", 3: "â‰‹" } },
        plains: { tile: "Â·", variants: ["â€§", "âˆ™"] },
        beach: { tile: "Â·", variants: ["â€§", "âˆ™"] },
        grass: { tile: "áµž", variants: ["áµž", "Ë¯", "Ë¬", "Ë‡", "â€¦", "âµˆ", '"', "'"] },
        forest: {
          tile: "â¯­",
          coniferous: ["âƒ", "ð™¢", "ðŠ¾"],
          dead: ["ð™˜", "â†‘", "â†Ÿ"],
          deciduous: ["ðŒ’", "á»Œ"],
          variants: ["ð™˜", "â†‘", "âƒ", "ðŒ’", "á»Œ", "ð™¢", "ðŠ¾", "â†Ÿ"],
        },
        desert: { tile: "~", variants: [
          "~", 
          "â‰ˆ", 
        ] },
        mycelium: { tile: "áµ ", variants: ["âµˆ", "Â·", "â€§", "âˆ™",] },
        mountain: {
          tile: "^",
          height: { 1: "ê˜", 2: "á¨ˆ", 3: "á´§", 4: "Î›", 5: "Î”" },
        },
        settlement: { tile: "â›©", variants: ["âŒ‚", "ð˜®", "ð™", "ð›…", "ð›˜", "ð¡", "ð€", "ð", "ð‚§", "ðƒ€"] },
        ruins: { tile: "âŒ‚", variants: ["âŒ‚", "ð˜®", "ð™", "ð›…", "ð›˜", "ð¡", "ð€", "ð", "ð‚§", "ðƒ€"] },
        camp: { tile: "á—‘" },
        religious: { death: "âš±", monastery: "â›¨" },
      };


      const SYL = ["al", "ur", "da", "ri", "ka", "lem", "vor", "zan", "ti", "sha", "mor", "bel", "oth", "ryn", "ser", "vak", "nel", "ios", "qar", "ume", "thal", "gre", "nor", "fen", "zir", "una", "vek", "cal", "mar", "ros", "ion", "kha", "zul", "ora", "sta", "dra", "pha"];

      const namePost = [" Hold", " Castle", " Reach", " Fall", " Falls", " Gate", " Prime", " Camp", " Cliffs", " Fold", " Crown", " Wilds", " Hollow", " Vale", " Peaks", " Grove", " Keep", " Commune", " Verge", " Wastes", " Spire", " Fields", " Flats", " Basin", " Spine", " Fault", " Deep", " Steppe", " Maw", " Province"];

      const TEMPLATES = [
        { name: "Title+Lineage", weight: 12, build: (r, L) => `${oneOf(r, L.titles)} ${oneOf(r, L.lineages)}` },
        { name: "Title+Toponym", weight: 6, build: (r, L) => `${oneOf(r, L.titles)} ${oneOf(r, L.toponyms)}` },
        { name: "The+Collective+of+Role", weight: 16, build: (r, L) => `The ${oneOf(r, L.collectives)} ${oneOf(r, L.prepsOf)} ${oneOf(r, L.roles)}` },
        { name: "Role+of+Toponym", weight: 14, build: (r, L) => `${oneOf(r, L.roles)} ${oneOf(r, L.prepsOf)} ${oneOf(r, L.toponyms)}` },
        { name: "The+Collective+of+Toponym", weight: 12, build: (r, L) => `The ${oneOf(r, L.collectives)} ${oneOf(r, L.prepsOf)} ${oneOf(r, L.toponyms)}` },
        { name: "Abstract+of+Region", weight: 10, build: (r, L) => `${oneOf(r, L.abstracts)} ${oneOf(r, L.prepsOf)} ${oneOf(r, L.regions)}` },
        { name: "Toponym+Company", weight: 8, build: (r, L) => `${oneOf(r, L.toponyms)} ${oneOf(r, L.tradeBodies)}` },
        { name: "The+Nickname", weight: 7, build: (r, L) => `The ${oneOf(r, L.nicknames)}` },
        { name: "Hybrid", weight: 9, build: (r, L) => `${oneOf(r, L.titles)} ${oneOf(r, L.lineages)} ${oneOf(r, L.prepsOf)} ${oneOf(r, L.toponyms)}` },
        { name: "Role+Preposition+Site", weight: 6, build: (r, L) => `${oneOf(r, L.roles)} ${oneOf(r, L.prepsSite)} ${oneOf(r, L.sites)}` },
      ];

      /* ====================== Faction naming (fixed deterministic lexicon) ====================== */
      const DEFAULT_COLLECTIVES = ["Order", "Guild", "Clan", "Court", "Circle", "Syndicate", "Chapter", "Coven", "Brotherhood", "Company", "League", "Consulate", "Caravan", "Enclave", "Assembly", "Dominion", "Conclave", "Pact", "Sect", "Keep", "Banner", "Kin", "House", "Hollow", "Sanctum", "Forge", "Crusade", "March", "Host"];
      const DEFAULT_ROLES = ["Wardens", "Archivists", "Bonepickers", "Skyfarers", "Prospectors", "Scribes", "Wayfinders", "Stormcallers", "Reclaimers", "Oathkeepers", "Lamplighters", "Seers", "Witchbinders", "Lorehunters", "Pathmakers", "Gravetenders", "Runesmiths", "Beastwalkers", "Spellweavers", "Hearthguard", "Frostborn", "Flamebearers", "Thornwatch", "Miststriders"];
      const LINEAGE_ROOTS = ["Var", "Tor", "Ash", "Hale", "Brenn", "Keth", "Mor", "Vale", "Dun", "Rav", "Fen", "Grey", "Orv", "Nyx", "Cal"];
      const LINEAGE_SUFFIXES = ["yn", "ell", "ath", "ek", "ar", "os", "en", "ard", "ir", "an", "oth", "ic", "as"];
      const TOPONYM_ROOTS = ["Ash", "Red", "Thorn", "Hollow", "River", "Stone", "Mist", "Oak", "Wolf", "Raven", "Sun", "Star", "Ember", "Frost", "Gold", "Mire", "Holt", "Rev", "Shale", "Writ"];
      const TOPONYM_SUFFIXES = ["mere", "holt", "gate", "brig", "brook", "field", "wood", "veld", "keep", "bridge", "ward", "reach", "shire", "watch", "march", "moor", "ford", "fell", "crest", "vale", "dell", "dale", "fen", "scythe", "glen", "ryn"];
      const REGIONIZERS = ["Low", "Upper", "High", "Outer", "Far", "Near", "Old", "New"];
      const REGION_PLURALS = ["Marches", "Hills", "Moors", "Flats", "Wastes", "Reaches", "Wards", "Downs"];
      const NICKNAME_COLORS = ["Black", "Red", "Grey", "White", "Gold", "Green", "Blue", "Umber", "Sable", "Crimson", "Azure"];
      const NICKNAME_THINGS = ["Thorn", "Hand", "Lantern", "Crow", "Hound", "Spear", "Moth", "Mason", "Key", "Hammer", "Watch"];
      const PREPS_OF = ["of", "of the"];
      const PREPS_SITE = ["at", "under", "within", "beside", "along", "near"];
      const ABSTRACTS = ["Pact", "Dominion", "March", "Compact", "Confederacy", "Concord", "Mandate", "League", "Charter"];
      const TRADE_BODIES = ["Company", "Charter", "Shipping", "Freight", "Exchange", "Syndicate", "Cartage"];
      const TITLE_WORDS = ["House", "Clan", "Order", "Circle", "Court", "Conclave", "Banner", "Keep", "Forge", "Sanctum", "Host"];
      const SITE_BASES = ["Gate", "Bridge", "Wayhouse", "Watch", "Spire", "Hollow", "Vault", "Crossing", "Ford", "Hall", "Tower", "Works"];
      const DEATH_MARKERS = ["ossuary", "cairn", "vault", "necropolis", "catacombs", "burial ground", "funerary mound", "memorial", "tomb", "crypt", "graveyard", "sepulchre", "cemetery", "mausoleum", "crematorium"];
      const MONASTERY_MARKERS = ["Shrine", "Synagogue", "Pagoda", "Zendo", "Monastery", "Abbey", "Hermitage", "Sacred Grove", "Sacred Spring", "Temple", "Chapel", "Sanctum", "Sanctuary", "Stone Circle", "Oratory"];
      const DEATH_GROUPS = ["mourners", "undertakers", "gravediggers", "deathwatch", "ossuary wardens", "memorialists", "grievers", "kin", "bereaved", "lamenters"];
      const RELIGIOUS_GROUPS = ["devout", "ascetics", "clergy", "monks", "priests", "hermits", "pilgrims", "zealots", "brothers", "sisters", "cultists", "missionaries", "nuns", "friars", "elders", "druids", "seekers", "wayfarers", "penitents", "acolytes", "undertakers", "mediums", "shamans", "oracles", "prophets", "necromancers"];
      const POI_STRUCTURE_KEYWORDS = [
        "abbey",
        "bunker",
        "cathedral",
        "chapel",
        "citadel",
        "dock",
        "forge",
        "fort",
        "gate",
        "hall",
        "keep",
        "mall",
        "metro",
        "monastery",
        "outpost",
        "plant",
        "port",
        "relay",
        "sanctum",
        "settlement",
        "shrine",
        "signal",
        "spine",
        "spire",
        "station",
        "tower",
        "temple",
        "vault",
        "wayhouse",
      ];

      const BIOME_FEATURES_BY_NAME = (() => {
        const out = {};
        for (const tt of Object.values(T)) {
          const biomes = tt?.biome || [];
          for (const biome of biomes) {
            if (!biome) continue;
            if (typeof biome === "object") {
              const name = String("name" in biome ? biome.name ?? "" : biome).toLowerCase();
              if (name && !out[name]) out[name] = biome.features && typeof biome.features === "object" ? biome.features : {};
            } else if (typeof biome === "string") {
              const name = biome.toLowerCase();
              if (!out[name]) out[name] = {};
            }
          }
        }
        return out;
      })();

      /* ====================== RNG + Utilities ====================== */
      function h32(s) {
        let h = 5381 >>> 0;
        for (let i = 0; i < s.length; i++) h = ((h * 33) ^ s.charCodeAt(i)) >>> 0;
        return h >>> 0;
      }

      function xs32(seed) {
        let x = seed >>> 0;
        return () => {
          x ^= x << 13;
          x ^= x >>> 17;
          x ^= x << 5;
          return (x >>> 0) / 4294967296;
        };
      }

      function n2(seed, x, y) {
        let v = (seed ^ ((x * 374761393) | 0) ^ ((y * 668265263) | 0)) >>> 0;
        v ^= v >>> 13;
        v = Math.imul(v, 1274126177) >>> 0;
        v ^= v >>> 16;
        return (v >>> 0) / 4294967296;
      }

      function randSeed() {
        const a = new Uint32Array(1);
        if (crypto && crypto.getRandomValues) crypto.getRandomValues(a);
        else a[0] = (Math.random() * 4294967296) >>> 0;
        return a[0].toString(36);
      }

      function resolveInlineOptions(s, r) {
        if (typeof s !== "string") return s;
        const rand = typeof r === "function" ? r : Math.random;
        return s.replace(/\{([^{}]+)\}/g, (_, body) => {
          const parts = body.split("|").map((p) => p.trim()).filter((p) => p.length);
          if (!parts.length) return "";
          return parts[(rand() * parts.length) | 0];
        });
      }

      function oneOf(r, src) {
        if (!src) return undefined;
        if (Array.isArray(src)) {
          const picked = src[(r() * src.length) | 0];
          return resolveInlineOptions(picked, r);
        }
        if (typeof src === "object") {
          const keys = Object.keys(src);
          if (!keys.length) return undefined;
          const k = keys[(r() * keys.length) | 0];
          return resolveInlineOptions(src[k], r);
        }
        return resolveInlineOptions(src, r);
      }

      function normalizeBiomeFeatures(features, fallbackRarity = 0.3) {
        const clampRarity = (value) => Math.max(0, Math.min(1, value));
        if (!features) return {};
        if (Array.isArray(features)) {
          const out = {};
          for (const f of features) {
            if (typeof f === "string") {
              out[f] = fallbackRarity;
              continue;
            }
            if (f && typeof f === "object") {
              const id = "id" in f ? f.id : "name" in f ? f.name : "";
              const rarity = Number.isFinite(f.rarity) ? clampRarity(Number(f.rarity)) : fallbackRarity;
              if (id) out[String(id)] = rarity;
            }
          }
          return out;
        }
        if (typeof features === "object") {
          const out = {};
          for (const [key, value] of Object.entries(features)) {
            if (!key) continue;
            const rarity = Number.isFinite(value) ? clampRarity(Number(value)) : fallbackRarity;
            out[String(key)] = rarity;
          }
          return out;
        }
        return {};
      }

      function normalizeBiome(biome) {
        const defaultFeatures = normalizeBiomeFeatures(GEO_FEATURES);
        if (!biome) return { name: "", features: {} };
        if (typeof biome === "string") {
          const known = normalizeBiomeFeatures(BIOME_FEATURES_BY_NAME[biome.toLowerCase()]);
          return { name: biome, features: Object.keys(known).length ? known : defaultFeatures };
        }
        if (typeof biome === "object") {
          const name = "name" in biome ? String(biome.name ?? "") : String(biome);
          const features = normalizeBiomeFeatures(biome.features);
          if (Object.keys(features).length) return { name, features };
          const known = normalizeBiomeFeatures(BIOME_FEATURES_BY_NAME[name.toLowerCase()]);
          return { name, features: Object.keys(known).length ? known : defaultFeatures };
        }
        return { name: String(biome), features: defaultFeatures };
      }

      function pickTempTier(r, tt) {
        const temp = tt?.temp;
        if (temp && typeof temp === "object" && !Array.isArray(temp)) {
          const keys = Object.keys(temp)
            .map((k) => Number(k))
            .filter((n) => Number.isFinite(n))
            .sort((a, b) => a - b);
          if (keys.length) {
            const tier = keys[(r() * keys.length) | 0];
            return { tier, label: String(temp[tier]) };
          }
        }
        const label = oneOf(r, temp) ?? "mild";
        return { tier: 4, label: String(label) };
      }

      function pickRainIndex(r, tt) {
        const rain = tt?.rain;
        if (Array.isArray(rain) && rain.length) {
          const idx = (r() * rain.length) | 0;
          return { idx, label: String(rain[idx]) };
        }
        const label = oneOf(r, rain) ?? "dry";
        return { idx: 1, label: String(label) };
      }

      function maybe(rng, chance = 0.5) {
        return typeof rng === "function" ? rng() < chance : Math.random() < chance;
      }

      function ensure(arr, fallback) {
        return Array.isArray(arr) && arr.length ? arr : fallback;
      }

      function uniqN(n, fn) {
        const out = new Set();
        let guard = 0;
        while (out.size < n && guard++ < n * 20) out.add(fn());
        return Array.from(out);
      }

      function cartesian(a, b) {
        const out = [];
        for (let i = 0; i < a.length; i++) for (let j = 0; j < b.length; j++) out.push([a[i], b[j]]);
        return out;
      }

      function pickWeighted(r, items) {
        const sum = items.reduce((acc, it) => acc + (it.weight || 1), 0);
        const roll = r() * sum;
        let acc = 0;
        for (const it of items) {
          acc += it.weight || 1;
          if (roll < acc) return it;
        }
        return items[items.length - 1];
      }

      function normalizeWeights(weights) {
        const total = Object.values(weights).reduce((a, b) => a + b, 0) || 1;
        for (const k in weights) weights[k] /= total;
      }

      function shuffleDet(r, arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = (r() * (i + 1)) | 0;
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      function escAttr(s) {
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/"/g, "&quot;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function escHtml(s) {
        return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }

      function escRe(s) {
        return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      function xref(cell, label) {
        return `<span class="xref" data-cell="${escAttr(cell)}">${escHtml(label)}</span>`;
      }

      function linkifyRefs(text, refs) {
        let out = escHtml(text);
        if (!Array.isArray(refs) || !refs.length) return out;
        const ordered = refs.slice().sort((a, b) => b.name.length - a.name.length);
        for (const ref of ordered) {
          const re = new RegExp(escRe(escHtml(ref.name)), "g");
          out = out.replace(re, xref(ref.cell, ref.name));
        }
        return out;
      }

      /* ====================== Naming + Lexicon ====================== */
      class NameGenerator {
        constructor(rng, { syllables = SYL, postfixes = namePost } = {}) {
          this.r = rng;
          this.syllables = syllables;
          this.postfixes = postfixes;
        }

        baseName({ allowExtraSyllable = true } = {}) {
          const n = 2 + (allowExtraSyllable && this.r() > 0.7);
          let s = "";
          for (let i = 0; i < n; i++) s += this.syllables[(this.r() * this.syllables.length) | 0];
          return s.charAt(0).toUpperCase() + s.slice(1);
        }

        placeName() {
          let s = this.baseName();
          if (this.r() > 0.5) s += this.postfixes[(this.r() * this.postfixes.length) | 0];
          return s;
        }

        npcName() {
          return this.baseName();
        }
      }

      function buildLineages(r, count = 12) {
        return uniqN(count, () => LINEAGE_ROOTS[(r() * LINEAGE_ROOTS.length) | 0] + LINEAGE_SUFFIXES[(r() * LINEAGE_SUFFIXES.length) | 0]);
      }

      function buildToponyms(r, count = 20) {
        return uniqN(count, () => TOPONYM_ROOTS[(r() * TOPONYM_ROOTS.length) | 0] + TOPONYM_SUFFIXES[(r() * TOPONYM_SUFFIXES.length) | 0]);
      }

      function buildRegionsFromToponyms(r, tops, count = 10, regionizer_chance = 0.5) {
        return uniqN(count, () => {
          const top = tops[(r() * tops.length) | 0];
          const addRegionizer = r() < regionizer_chance;
          const addPlural = r() < 0.4;
          const rr = REGIONIZERS[(r() * REGIONIZERS.length) | 0];
          const prefix = addRegionizer ? rr + " " : "";
          if (addPlural) {
            const p = REGION_PLURALS[(r() * REGION_PLURALS.length) | 0];
            return `${prefix}${top} ${p}`;
          }
          return `${prefix}${top}`;
        });
      }

      function buildNicknames(r) {
        return cartesian(NICKNAME_COLORS, NICKNAME_THINGS).map(([c, t]) => `${c} ${t}${maybe(r, 0.5) ? "s" : ""}`);
      }


      function buildLexicon(tt, r) {
        const roles = ensure(tt.roles, DEFAULT_ROLES);
        const collectives = ensure(tt.factionsN1, DEFAULT_COLLECTIVES);

        const prepsOf = PREPS_OF;
        const prepsSite = PREPS_SITE;
        const abstracts = ABSTRACTS;
        const tradeBodies = TRADE_BODIES;
        const titles = TITLE_WORDS;

        const lineages = buildLineages(r, 12);
        const toponyms = buildToponyms(r, 20);
        const regions = buildRegionsFromToponyms(r, toponyms, 10);
        const nicknames = buildNicknames(r);

        const sites = SITE_BASES.map((s) => (maybe(r, 0.5) ? `the ${s}` : s));

        return { roles, collectives, prepsOf, prepsSite, abstracts, tradeBodies, titles, lineages, toponyms, regions, nicknames, sites };
      }

      function factionName(r, theme = "fantasy") {
        const tt = T[theme] || {};
        const L = buildLexicon(tt, r);
        const template = pickWeighted(r, TEMPLATES);
        return template.build(r, L);
      }

      function namedPOI(nameGen, poiType) {
        const r = nameGen.r;
        const style = (r() * 4) | 0;
        const base = nameGen.placeName();
        if (style === 0) return `${base} ${poiType}`;
        if (style === 1) return `The ${poiType} of ${base}`;
        if (style === 2) return `${poiType.charAt(0).toUpperCase() + poiType.slice(1)} at ${base}`;
        return `${base}'s ${poiType}`;
      }

      function poiIsStructure(poiType) {
        const s = String(poiType || "").toLowerCase();
        for (const word of POI_STRUCTURE_KEYWORDS) {
          if (s.includes(word)) return true;
        }
        return false;
      }

      /* ====================== World Placement ====================== */
      function buildSettlementNames(nameGen, count) {
        return uniqN(count, () => nameGen.placeName());
      }

      function placeWorldRefs(seedU32, theme, tileKeyGrid, N, poiTypes, factions, rText, biome) {
        const r = xs32(seedU32 ^ 0xa53c9e17);

        const settlements = [];
        const land = [];

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            const k = tileKeyGrid[y][x];
            const key = `${x},${y}`;
            if (k !== "water" && k !== "lava") land.push(key);
            if (k === "settlement") settlements.push(key);
          }
        }

        const settlementOrder = shuffleDet(r, settlements);
        const landOrder = shuffleDet(r, land);

        const nameGen = new NameGenerator(rText);
        const settlementNames = buildSettlementNames(nameGen, Math.max(6, settlements.length));
        const settlementNameByCell = new Map();
        settlements.forEach((cell, i) => settlementNameByCell.set(cell, settlementNames[i % settlementNames.length]));

        const poiPlacements = [];
        const poiTypesExpanded = poiTypes.slice();
        const ruinsRarity = biomeFeatureRarity(biome, "ruins");
        let ruinCount = 0;
        if (ruinsRarity > 0) {
          ruinCount = 1 + Math.floor(ruinsRarity * 2);
          if (r() < ruinsRarity * 0.6) ruinCount += 1;
        }

        for (let i = 0; i < poiTypesExpanded.length; i++) {
          const poiType = poiTypesExpanded[i];
          const poiName = namedPOI(nameGen, poiType);

          const cell = settlementOrder[i] || landOrder[i] || `${(seedU32 % N) | 0},${((seedU32 >>> 8) % N) | 0}`;
          poiPlacements.push({ poiType, poiName, cell });
        }

        if (ruinCount > 0) {
          let rIdx = 0;
          for (let i = 0; i < ruinCount; i++) {
            while (rIdx < landOrder.length && (settlementNameByCell.has(landOrder[rIdx]) || poiPlacements.some((p) => p.cell === landOrder[rIdx]))) {
              rIdx++;
            }
            const cell = landOrder[rIdx++] || landOrder[0] || `${(seedU32 % N) | 0},${((seedU32 >>> 8) % N) | 0}`;
            const poiType = "ruins";
            const poiName = namedPOI(nameGen, poiType);
            poiPlacements.push({ poiType, poiName, cell });
          }
        }

        const used = new Set(poiPlacements.map((p) => p.cell));
        const factionPlacements = [];

        let sIdx = poiTypes.length;
        let lIdx = poiTypes.length;

        for (let i = 0; i < factions.length; i++) {
          let cell = null;

          while (sIdx < settlementOrder.length && used.has(settlementOrder[sIdx])) sIdx++;
          if (sIdx < settlementOrder.length) cell = settlementOrder[sIdx++];

          if (!cell) {
            while (lIdx < landOrder.length && used.has(landOrder[lIdx])) lIdx++;
            cell = landOrder[lIdx++] || landOrder[0] || `${i % N},${(i * 7) % N}`;
          }

          used.add(cell);
          factionPlacements.push({ factionName: factions[i].name, motive: factions[i].motive, cell });
        }

        const ann = new Map();
        function ensureCell(cell) {
          if (!ann.has(cell)) ann.set(cell, { poi: [], factions: [] });
          return ann.get(cell);
        }

        for (const cell of settlements) {
          const o = ensureCell(cell);
          o.settlementName = settlementNameByCell.get(cell);
        }

        for (const p of poiPlacements) {
          const o = ensureCell(p.cell);
          o.poi.push({ name: p.poiName, type: p.poiType });
          if (poiIsStructure(p.poiType)) o.poiStructure = true;
        }

        for (const f of factionPlacements) {
          const o = ensureCell(f.cell);
          o.factions.push({ name: f.factionName });
          if (!settlementNameByCell.has(f.cell)) o.fieldCamp = true;
        }

        const deathMarkers = DEATH_MARKERS;
        const monasteryMarkers = MONASTERY_MARKERS;
        const death_groups = DEATH_GROUPS;
        const religious_groups = RELIGIOUS_GROUPS;
        const reserved = new Set([...used, ...settlements]);
        const baseDeathChance = 0.4;
        const baseMonasteryChance = 0.4;
        const decay = 0.3;
        const maxPerKind = 3;

        function rollCount(baseChance, decayFactor, max) {
          let count = 0;
          let p = baseChance;
          while (count < max && r() < p) {
            count++;
            p *= decayFactor;
          }
          return count;
        }

        const deathCount = rollCount(baseDeathChance, decay, maxPerKind);
        const monasteryCount = rollCount(baseMonasteryChance, decay, maxPerKind);
        let li = 0;

        function placeReligious(kind, count) {
          for (let i = 0; i < count; i++) {
            let cell = null;
            while (li < landOrder.length) {
              const cand = landOrder[li++];
              if (!reserved.has(cand)) {
                cell = cand;
                break;
              }
            }
            if (!cell) return;

            let label = "";
            if (kind === "death") {
              label = oneOf(r, deathMarkers);
            } else {
              label = oneOf(r, monasteryMarkers);
            }
            const group = kind === "death" ? oneOf(r, death_groups) : oneOf(r, religious_groups);
            const deity = nameGen.baseName();
            label = `${label}: ${group} of ${deity}`;

            const o = ensureCell(cell);
            const rel = { kind, label, glyph: tileset.religious?.[kind] };
            o.religious = rel;
            o.poi.push({ name: label, type: "religious" });
            poiPlacements.push({ poiType: "religious", poiName: label, cell });
            reserved.add(cell);
          }
        }

        placeReligious("death", deathCount);
        placeReligious("monastery", monasteryCount);

        return { annotations: ann, poiPlacements, factionPlacements, settlementNameByCell };
      }

      /* ====================== Map Generation ====================== */
      function biomeFeatureRarity(biome, id) {
        const { features } = normalizeBiome(biome);
        const rarity = features?.[id];
        return Number.isFinite(rarity) ? rarity : 0;
      }

      function biomeAllowsFeature(biome, id, minRarity = 0.25) {
        const { features } = normalizeBiome(biome);
        const rarity = features?.[id];
        return Number.isFinite(rarity) && rarity >= minRarity;
      }

      function tileWeightsForBiome(biome) {
        const baseWeights = { water: 0.12, mountain: 0.15, forest: 0.25, grass: 0.2, plains: 0.28 };
        const inc = (k, f) => (baseWeights[k] = Math.max(0.01, baseWeights[k] * f));
        const { features } = normalizeBiome(biome);
        const applyFeature = (id, minRarity, fn) => {
          const rarity = features?.[id];
          if (!Number.isFinite(rarity) || rarity < minRarity) return;
          fn(rarity);
        };

        applyFeature("dunes", 0.05, (rarity) => {
          inc("plains", 1 + rarity * 1.2);
          inc("forest", 1 - rarity * 0.6);
          inc("grass", 1 - rarity * 0.4);
          inc("water", 1 - rarity * 0.4);
          inc("mountain", 1 - rarity * 0.2);
        });

        applyFeature("oasis", 0.05, (rarity) => {
          inc("water", 1 + rarity * 1.5);
          inc("grass", 1 + rarity * 0.8);
          inc("forest", 1 + rarity * 0.4);
          inc("plains", 1 - rarity * 0.2);
        });

        applyFeature("river-water", 0.05, (rarity) => {
          inc("water", 1 + rarity * 1.0);
          inc("plains", 1 - rarity * 0.1);
        });

        applyFeature("river-lava", 0.05, (rarity) => {
          inc("mountain", 1 + rarity * 0.5);
          inc("plains", 1 + rarity * 0.2);
          inc("water", 1 - rarity * 0.4);
        });

        applyFeature("lake", 0.05, (rarity) => {
          inc("water", 1 + rarity * 1.4);
          inc("plains", 1 - rarity * 0.2);
        });

        applyFeature("reef", 0.05, (rarity) => {
          inc("water", 1 + rarity * 1.6);
          inc("plains", 1 - rarity * 0.3);
        });

        applyFeature("lagoon", 0.05, (rarity) => {
          inc("water", 1 + rarity * 1.3);
          inc("plains", 1 - rarity * 0.25);
        });

        applyFeature("beaches", 0.05, (rarity) => {
          inc("water", 1 + rarity * 0.6);
          inc("plains", 1 + rarity * 0.4);
        });

        applyFeature("mountain", 0.05, (rarity) => {
          inc("mountain", 1 + rarity * 1.5);
          inc("plains", 1 + rarity * 0.2);
          inc("forest", 1 - rarity * 0.1);
          inc("grass", 1 - rarity * 0.1);
        });

        applyFeature("ridge", 0.05, (rarity) => {
          inc("mountain", 1 + rarity * 1.1);
          inc("plains", 1 + rarity * 0.15);
          inc("forest", 1 - rarity * 0.1);
          inc("grass", 1 - rarity * 0.1);
        });

        applyFeature("ruins", 0.05, (rarity) => {
          inc("plains", 1 + rarity * 0.6);
          inc("forest", 1 - rarity * 0.2);
          inc("grass", 1 - rarity * 0.3);
          inc("mountain", 1 + rarity * 0.1);
          inc("water", 1 - rarity * 0.1);
        });

        applyFeature("dead trees", 0.05, (rarity) => {
          inc("forest", 1 - rarity * 0.4);
          inc("grass", 1 - rarity * 0.3);
          inc("plains", 1 + rarity * 0.2);
        });

        applyFeature("mycelium", 0.05, (rarity) => {
          inc("forest", 1 + rarity * 0.4);
          inc("grass", 1 + rarity * 0.2);
          inc("plains", 1 - rarity * 0.2);
        });

        applyFeature("watering hole", 0.05, (rarity) => {
          inc("water", 1 + rarity * 1.2);
          inc("grass", 1 + rarity * 0.4);
          inc("plains", 1 - rarity * 0.2);
        });

        normalizeWeights(baseWeights);
        return baseWeights;
      }

      function pickByWeights(x, weights) {
        const keys = Object.keys(weights);
        let acc = 0;
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          acc += weights[k];
          if (x <= acc) return k;
        }
        return keys[keys.length - 1];
      }

      function pickVariant(tileKey, tileset, seed) {
        const variants = [tileset[tileKey].tile, ...(tileset[tileKey].variants || [])];
        const index = Math.floor(seed * variants.length);
        return variants[index];
      }

      function riverCells(seedU32, N) {
        const cells = new Set();
        const rand = xs32(seedU32 ^ 0x6d2b79f5);
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
          [1, 1],
          [1, -1],
          [-1, 1],
          [-1, -1],
        ];

        const addCells = (x, y, width) => {
          const r = Math.max(1, width);
          for (let oy = -r + 1; oy <= r - 1; oy++) {
            for (let ox = -r + 1; ox <= r - 1; ox++) {
              if (Math.abs(ox) + Math.abs(oy) >= r) continue;
              const nx = x + ox;
              const ny = y + oy;
              if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
              cells.add(`${nx},${ny}`);
            }
          }
        };

        const pickDir = () => dirs[(rand() * dirs.length) | 0];
        const lenMain = Math.floor(N * (1.6 + rand()));
        const start = {
          x: (rand() * N) | 0,
          y: (rand() * N) | 0,
          len: lenMain,
          width: 2,
          branchChance: 0.12,
          turnChance: 0.28,
          dir: pickDir(),
        };

        const queue = [start];
        while (queue.length) {
          const p = queue.pop();
          let x = p.x;
          let y = p.y;
          let dx = p.dir[0];
          let dy = p.dir[1];

          for (let i = 0; i < p.len; i++) {
            addCells(x, y, p.width);

            if (rand() < p.branchChance && p.len - i > 8) {
              queue.push({
                x,
                y,
                len: Math.floor(p.len * (0.45 + rand() * 0.2)),
                width: 1,
                branchChance: p.branchChance * 0.5,
                turnChance: p.turnChance * 0.9,
                dir: pickDir(),
              });
            }

            if (rand() < p.turnChance) {
              const nd = pickDir();
              dx = nd[0];
              dy = nd[1];
            }

            x += dx;
            y += dy;

            if (x < 0) {
              x = 0;
              dx = 1;
            } else if (x >= N) {
              x = N - 1;
              dx = -1;
            }
            if (y < 0) {
              y = 0;
              dy = 1;
            } else if (y >= N) {
              y = N - 1;
              dy = -1;
            }
          }
        }
        return cells;
      }

      /* ====================== Shared grid helpers ====================== */
      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }

      function neighbors4(N, x, y) {
        const out = [];
        if (y > 0) out.push([x, y - 1]);
        if (x < N - 1) out.push([x + 1, y]);
        if (y < N - 1) out.push([x, y + 1]);
        if (x > 0) out.push([x - 1, y]);
        return out;
      }

      function neighbors8(N, x, y) {
        const out = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx,
              ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < N && ny < N) out.push([nx, ny]);
          }
        }
        return out;
      }

      function countNeighbors8Of(tileKeyGrid, N, x, y, key) {
        let c = 0;
        for (const [nx, ny] of neighbors8(N, x, y)) if (tileKeyGrid[ny][nx] === key) c++;
        return c;
      }

      function countWaterNeighbors4(tileKeyGrid, N, x, y) {
        const neigh = neighbors4(N, x, y);
        let c = 0;
        for (const [nx, ny] of neigh) if (tileKeyGrid[ny][nx] === "water") c++;
        return c;
      }

      function cleanupIsolatedWater(seedU32, tileKeyGrid, weights, N) {
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "water") continue;
            if (countWaterNeighbors4(tileKeyGrid, N, x, y) >= 2) continue;

            const cand = new Map();
            for (const [nx, ny] of neighbors4(N, x, y)) {
              const k = tileKeyGrid[ny][nx];
              if (!k || k === "water" || k === "settlement") continue;
              cand.set(k, (cand.get(k) || 0) + 1);
            }

            let replacement = null;

            if (cand.size) {
              const entries = Array.from(cand.entries());
              entries.sort((a, b) => b[1] - a[1]);
              const topCount = entries[0][1];
              const tied = entries.filter((e) => e[1] === topCount).map((e) => e[0]);
              if (tied.length === 1) replacement = tied[0];
              else {
                const roll = n2(seedU32, 19000 + x, 19100 + y);
                replacement = tied[Math.floor(roll * tied.length)];
              }
            } else {
              const roll = n2(seedU32, 19200 + x, 19300 + y);
              const w2 = { ...weights };
              delete w2.water;
              delete w2.settlement;
              const total = Object.values(w2).reduce((a, b) => a + b, 0) || 1;
              for (const k in w2) w2[k] /= total;
              replacement = pickByWeights(roll, w2);
            }

            next[y][x] = replacement || "plains";
          }
        }
        return next;
      }

      // Deterministic "make ranges" pass.
      function smoothMountains(seedU32, tileKeyGrid, weights, N, rounds = 2) {
        let cur = tileKeyGrid.map((row) => row.slice());

        for (let round = 0; round < rounds; round++) {
          const next = cur.map((row) => row.slice());

          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              const k = cur[y][x];
              if (k === "water" || k === "settlement") continue;

              const m8 = countNeighbors8Of(cur, N, x, y, "mountain");
              const roll = n2(seedU32, 54000 + round * 1000 + x, 54100 + round * 1000 + y);

              if (k === "mountain") {
                if (m8 < 2 && roll < 0.8) {
                  const w2 = { ...weights };
                  delete w2.water;
                  delete w2.settlement;
                  delete w2.mountain;
                  const total = Object.values(w2).reduce((a, b) => a + b, 0) || 1;
                  for (const kk in w2) w2[kk] /= total;
                  next[y][x] = pickByWeights(roll, w2);
                }
              } else {
                if (m8 >= 5 && roll < 0.65) next[y][x] = "mountain";
                else if (m8 === 4 && roll < 0.25) next[y][x] = "mountain";
              }
            }
          }

          cur = next;
        }

        return cur;
      }

      /* ====================== Water depth via distance-to-land + smoothing ====================== */
      function liquidGlyph(tileKey, depth) {
        const t = tileset[tileKey] || tileset.water;
        return t.depthGlyphs[depth] || t.depthGlyphs[1] || tileset.plains?.tile;
      }

      function distToNonLiquid(tileKeyGrid, N, liquidKey) {
        const INF = 1e9;
        const dist = Array.from({ length: N }, () => Array(N).fill(INF));

        const qx = new Int16Array(N * N);
        const qy = new Int16Array(N * N);
        let head = 0,
          tail = 0;

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) {
              dist[y][x] = 0;
              qx[tail] = x;
              qy[tail] = y;
              tail++;
            }
          }
        }

        while (head < tail) {
          const x = qx[head],
            y = qy[head];
          head++;
          const d = dist[y][x];

          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (dist[ny][nx] > d + 1) {
              dist[ny][nx] = d + 1;
              qx[tail] = nx;
              qy[tail] = ny;
              tail++;
            }
          }
        }

        return dist;
      }

      function smoothDepthsTodo2(seedU32, tileKeyGrid, depthGrid, N, liquidKey) {
        const next = depthGrid.map((row) => row.slice());

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            if (next[y][x] <= 1) continue;

            let hasPlainsOrGrass = false;
            for (const [nx, ny] of neighbors8(N, x, y)) {
              if (tileKeyGrid[ny][nx] === "plains" || tileKeyGrid[ny][nx] === "grass") {
                hasPlainsOrGrass = true;
                break;
              }
            }
            if (!hasPlainsOrGrass) continue;
            next[y][x] = 1;
          }
        }

        const next2 = next.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            if (next[y][x] !== 3) continue;

            let touches1 = false;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (tileKeyGrid[ny][nx] === liquidKey && next[ny][nx] === 1) {
                touches1 = true;
                break;
              }
            }
            if (!touches1) continue;

            const roll = n2(seedU32, 62000 + x, 62100 + y);
            if (roll < 0.5) next2[y][x] = 2;
          }
        }

        return next2;
      }

      function bumpDepthCenters(tileKeyGrid, depthGrid, N, liquidKey) {
        const next = depthGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            const d = depthGrid[y][x];
            if (d >= 3) continue;
            let sameOrHigher = true;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (tileKeyGrid[ny][nx] !== liquidKey || depthGrid[ny][nx] < d) {
                sameOrHigher = false;
                break;
              }
            }
            if (sameOrHigher) next[y][x] = d + 1;
          }
        }
        return next;
      }

      function buildDepthGrid(seedU32, tileKeyGrid, river, N, liquidKey = "water") {
        const dist = distToNonLiquid(tileKeyGrid, N, liquidKey);

        const depthGrid = Array.from({ length: N }, () => Array(N).fill(0));
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            let d = clamp(dist[y][x], 1, 3);
            if (river?.has(`${x},${y}`)) d = Math.max(d, 2);
            depthGrid[y][x] = d;
          }
        }

        const smoothed = smoothDepthsTodo2(seedU32, tileKeyGrid, depthGrid, N, liquidKey);
        return bumpDepthCenters(tileKeyGrid, smoothed, N, liquidKey);
      }

      /* ====================== Mountain height via distance-to-non-mountain ====================== */
      function distToNonMountain(tileKeyGrid, N) {
        const INF = 1e9;
        const dist = Array.from({ length: N }, () => Array(N).fill(INF));

        const qx = new Int16Array(N * N);
        const qy = new Int16Array(N * N);
        let head = 0,
          tail = 0;

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") {
              dist[y][x] = 0;
              qx[tail] = x;
              qy[tail] = y;
              tail++;
            }
          }
        }

        while (head < tail) {
          const x = qx[head],
            y = qy[head];
          head++;
          const d = dist[y][x];

          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (dist[ny][nx] > d + 1) {
              dist[ny][nx] = d + 1;
              qx[tail] = nx;
              qy[tail] = ny;
              tail++;
            }
          }
        }
        return dist;
      }

      function buildHeightGrid(tileKeyGrid, N) {
        const dist = distToNonMountain(tileKeyGrid, N);
        const heightGrid = Array.from({ length: N }, () => Array(N).fill(0));
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") continue;
            const d = dist[y][x];
            const h = 1 + Math.floor((d - 1) * 1.6);
            heightGrid[y][x] = clamp(h, 1, 5);
          }
        }
        return heightGrid;
      }

      function mountainGlyph(h) {
        return tileset.mountain.height[h] || tileset.mountain.height[1] || tileset.mountain?.tile || tileset.plains?.tile;
      }

      function applyDunePatches(seedU32, tileKeyGrid, N, rarity) {
        if (rarity <= 0) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = xs32(seedU32 ^ 0x3e9b1d2f);
        const patches = Math.max(1, Math.floor(1 + rarity * 4));
        const totalCells = Math.floor(N * N * (0.05 + rarity * 0.12));
        const stepsPerPatch = Math.max(10, Math.floor(totalCells / patches));
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];

        const pickStart = () => {
          for (let tries = 0; tries < 100; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (k !== "water" && k !== "mountain" && k !== "settlement") return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          let { x, y } = pickStart();
          for (let i = 0; i < stepsPerPatch; i++) {
            if (x < 0 || x >= N || y < 0 || y >= N) break;
            const k = next[y][x];
            if (k !== "water" && k !== "mountain" && k !== "settlement") next[y][x] = "desert";
            const d = dirs[(rand() * dirs.length) | 0];
            if (rand() < 0.2) {
              x = clamp(x + d[0] + (rand() < 0.5 ? d[0] : 0), 0, N - 1);
              y = clamp(y + d[1] + (rand() < 0.5 ? d[1] : 0), 0, N - 1);
            } else {
              x = clamp(x + d[0], 0, N - 1);
              y = clamp(y + d[1], 0, N - 1);
            }
          }
        }

        return next;
      }

      function applyOasisPatches(seedU32, tileKeyGrid, N, rarity) {
        const oasisVeg = new Set();
        if (rarity <= 0) return { grid: tileKeyGrid, oasisVeg };
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = xs32(seedU32 ^ 0x7f4a7c1b);
        const patches = Math.max(1, Math.floor(1 + rarity * 3));
        const maxRadius = 1 + Math.floor(rarity * 2);

        const pickStart = () => {
          for (let tries = 0; tries < 120; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (k !== "water" && k !== "mountain" && k !== "settlement") return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          const { x: cx, y: cy } = pickStart();
          const bigBonus = rand() < 0.35 ? 1 : 0;
          const r = 1 + ((rand() * maxRadius) | 0) + bigBonus;

          for (let y = cy - r - 2; y <= cy + r + 2; y++) {
            for (let x = cx - r - 2; x <= cx + r + 2; x++) {
              if (x < 0 || x >= N || y < 0 || y >= N) continue;
              const dx = x - cx;
              const dy = y - cy;
              const dist = Math.abs(dx) + Math.abs(dy);
              if (dist > r + 2) continue;
              const k = next[y][x];
              if (k === "mountain" || k === "settlement") continue;
              if (dist <= r) {
                next[y][x] = "water";
              } else if (k !== "water") {
                if (dist === r + 2 && rand() < 0.4) continue;
                next[y][x] = rand() < (dist === r + 2 ? 0.7 : 0.6) ? "grass" : "forest";
                oasisVeg.add(`${x},${y}`);
              }
            }
          }
        }

        return { grid: next, oasisVeg };
      }

      function applyMyceliumPatches(seedU32, tileKeyGrid, N, rarity) {
        if (rarity <= 0) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = xs32(seedU32 ^ 0x91a2f5c3);
        const patches = Math.max(1, Math.floor(1 + rarity * 4));
        const totalCells = Math.floor(N * N * (0.03 + rarity * 0.1));
        const stepsPerPatch = Math.max(12, Math.floor(totalCells / patches));
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
          [1, 1],
          [-1, 1],
          [1, -1],
          [-1, -1],
        ];

        const isBlocked = (k) =>
          k === "water" || k === "lava" || k === "mountain" || k === "settlement" || k === "desert" || k === "ruins";

        const pickStart = () => {
          for (let tries = 0; tries < 140; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (k === "forest") return { x, y };
            if (!isBlocked(k) && rand() < 0.65) return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          let { x, y } = pickStart();
          for (let i = 0; i < stepsPerPatch; i++) {
            if (x < 0 || x >= N || y < 0 || y >= N) break;
            const k = next[y][x];
            if (!isBlocked(k)) next[y][x] = "mycelium";
            const d = dirs[(rand() * dirs.length) | 0];
            if (rand() < 0.25) {
              x = clamp(x + d[0] + (rand() < 0.5 ? d[0] : 0), 0, N - 1);
              y = clamp(y + d[1] + (rand() < 0.5 ? d[1] : 0), 0, N - 1);
            } else {
              x = clamp(x + d[0], 0, N - 1);
              y = clamp(y + d[1], 0, N - 1);
            }
          }
        }

        return next;
      }

      function applyBeachPatches(seedU32, tileKeyGrid, depthGrid, N) {
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = xs32(seedU32 ^ 0x2b9f5ac1);
        const centers = [];

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            const k = tileKeyGrid[y][x];
            if (k !== "plains") continue;
            let shallowNeighbor = false;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (tileKeyGrid[ny][nx] === "water" && (depthGrid?.[ny]?.[nx] || 1) === 1) {
                shallowNeighbor = true;
                break;
              }
            }
            if (!shallowNeighbor) continue;
            if (rand() < 0.38) centers.push({ x, y });
          }
        }

        const touchesShallowWater = (x, y) => {
          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (tileKeyGrid[ny][nx] === "water" && (depthGrid?.[ny]?.[nx] || 1) === 1) return true;
          }
          return false;
        };

        for (const c of centers) {
          const r = 2 + ((rand() * 4) | 0);
          for (let y = c.y - r - 1; y <= c.y + r + 1; y++) {
            for (let x = c.x - r - 1; x <= c.x + r + 1; x++) {
              if (x < 0 || x >= N || y < 0 || y >= N) continue;
              const k = next[y][x];
              if (k !== "plains") continue;
              const dist = Math.abs(x - c.x) + Math.abs(y - c.y);
              if (dist > r) continue;
              if (dist === r && rand() < 0.35) continue;
              if (!touchesShallowWater(x, y)) continue;
              next[y][x] = "beach";
            }
          }
        }

        return next;
      }

      function applyRuinsClusters(seedU32, tileKeyGrid, N, ruinCenters, rarity) {
        if (!Array.isArray(ruinCenters) || !ruinCenters.length || rarity <= 0) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());

        for (const center of ruinCenters) {
          const parts = String(center?.cell || "").split(",");
          const cx = Number(parts[0]);
          const cy = Number(parts[1]);
          if (!Number.isFinite(cx) || !Number.isFinite(cy)) continue;
          const k = next[cy]?.[cx];
          if (!k || k === "water" || k === "lava" || k === "settlement") continue;
          next[cy][cx] = "ruins";
        }

        return next;
      }

      /* ====================== Forest typing (biome + climate) ====================== */
      function forestTypeForCell(seedU32, x, y, biome, climate, oasisVeg) {
        const s = String(biome || "").toLowerCase();
        const tempTier = clamp(climate?.tempTier ?? 4, 1, 8);
        const rainIdx = clamp((climate?.rainIdx ?? 3) + 1, 1, 8);

        const isDeadBiome = biomeAllowsFeature(biome, "dead trees", 0.2);

        const isColdBiome = s.includes("tundra") || s.includes("taiga") || s.includes("ice") || s.includes("highland");

        if (isDeadBiome) {
          if (oasisVeg?.has(`${x},${y}`)) return "deciduous";
          const roll = n2(seedU32, 70000 + x, 70100 + y);
          if (rainIdx >= 6 && roll < 0.18) return "deciduous";
          return "dead";
        }

        if (isColdBiome || tempTier <= 3) return "coniferous";

        if (tempTier >= 7 && rainIdx <= 2) {
          if (oasisVeg?.has(`${x},${y}`)) return "deciduous";
          const roll = n2(seedU32, 70200 + x, 70300 + y);
          return roll < 0.6 ? "dead" : "deciduous";
        }

        if (rainIdx >= 6 && tempTier >= 5) return "deciduous";

        const roll = n2(seedU32, 70400 + x, 70500 + y);
        return roll < 0.18 ? "coniferous" : "deciduous";
      }

      function forestGlyphForType(ft, seed01) {
        const t = tileset.forest;
        const list = ft === "coniferous" ? t.coniferous : ft === "dead" ? t.dead : ft === "deciduous" ? t.deciduous : t.variants;
        const idx = Math.floor(seed01 * list.length);
        return list[idx] || t.tile;
      }

      /* ====================== Map generator ====================== */
      function genMap(seedU32, biome, tileset, worldMeta = null, climate = null) {
        const N = 25;
        const weights = tileWeightsForBiome(biome);
        const mountainBias = n2(seedU32, 90500, 90600) < 0.3;
        if (mountainBias) {
          weights.mountain = Math.max(0.01, weights.mountain * 1.7);
          weights.plains *= 0.85;
          weights.grass *= 0.85;
          weights.forest *= 0.85;
          weights.water *= 0.9;
          normalizeWeights(weights);
        }

        const riverType = biomeAllowsFeature(biome, "river-lava") ? "lava" : biomeAllowsFeature(biome, "river-water") ? "water" : null;
        const river = riverType && n2(seedU32, 42000, 43000) > 0.35 ? riverCells(seedU32 ^ 0x9e3779b9, N) : new Set();

        let tileKeyGrid = Array.from({ length: N }, () => Array(N).fill("plains"));

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            let tileKey;
            if (riverType && river.has(`${x},${y}`)) {
              tileKey = riverType;
            } else {
              const r0 = n2(seedU32, x, y);
              tileKey = pickByWeights(r0, weights);
              if (tileKey !== "water" && n2(seedU32, 7000 + x, 8000 + y) > 0.985) tileKey = "settlement";
            }
            tileKeyGrid[y][x] = tileKey;
          }
        }

        tileKeyGrid = cleanupIsolatedWater(seedU32, tileKeyGrid, weights, N);
        tileKeyGrid = smoothMountains(seedU32, tileKeyGrid, weights, N, 2);
        if (biome.toLowerCase().includes("desert")) {
          const desertAll = n2(seedU32, 4242, 31337) < 0.5;
          if (desertAll) {
            for (let y = 0; y < N; y++) {
              for (let x = 0; x < N; x++) {
                if (tileKeyGrid[y][x] === "plains") tileKeyGrid[y][x] = "desert";
              }
            }
          }
        }
        tileKeyGrid = applyDunePatches(seedU32, tileKeyGrid, N, biomeFeatureRarity(biome, "dunes"));
        const oasisResult = applyOasisPatches(seedU32, tileKeyGrid, N, biomeFeatureRarity(biome, "oasis"));
        tileKeyGrid = oasisResult.grid;
        const oasisVeg = oasisResult.oasisVeg;
        tileKeyGrid = applyMyceliumPatches(seedU32, tileKeyGrid, N, biomeFeatureRarity(biome, "mycelium"));
        const ruinCenters = worldMeta?.poiPlacements?.filter((p) => p.poiType === "ruins") || [];
        tileKeyGrid = applyRuinsClusters(seedU32, tileKeyGrid, N, ruinCenters, biomeFeatureRarity(biome, "ruins"));

        const depthGrid = buildDepthGrid(seedU32, tileKeyGrid, river, N, riverType || "water");
        tileKeyGrid = applyBeachPatches(seedU32, tileKeyGrid, depthGrid, N);
        const heightGrid = buildHeightGrid(tileKeyGrid, N);

        const forestTypeGrid = Array.from({ length: N }, () => Array(N).fill(null));
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] === "forest") forestTypeGrid[y][x] = forestTypeForCell(seedU32, x, y, biome, climate, oasisVeg);
          }
        }

        const ann = worldMeta?.annotations || new Map();

        let s = "";
        for (let y = 0; y < N; y++) {
          let row = "";
          for (let x = 0; x < N; x++) {
            const tileKey = tileKeyGrid[y][x];
            const key = `${x},${y}`;
            const a = ann.get(key);

            const bits = [];
            bits.push(`${tileKey} @ (${x},${y})`);
            if (tileKey === "water" || tileKey === "lava") bits.push(`depth: ${clamp(depthGrid[y][x] || 1, 1, 3)}`);
            if (tileKey === "mountain") bits.push(`height: ${clamp(heightGrid[y][x] || 1, 1, 5)}`);
            if (tileKey === "forest") bits.push(`forest: ${forestTypeGrid[y][x] || "mixed"}`);
            if (a?.settlementName) bits.push(`Settlement: ${a.settlementName}`);
            if (a?.fieldCamp) bits.push("Field Camp");
            if (a?.poi?.length) {
              for (const p of a.poi) {
                if (a?.religious && p.type === "religious") continue;
                bits.push(`POI: ${p.name}`);
              }
            }
            if (a?.factions?.length) for (const f of a.factions) bits.push(`Faction: ${f.name}`);
            if (a?.factionOps?.length) for (const f of a.factionOps) bits.push(`Faction Activity: ${f.name} â€” ${f.verb}`);
            if (a?.npcs?.length) for (const n of a.npcs) bits.push(`NPC: ${n.name} â€” ${n.task}`);
            if (a?.religious) bits.push(a.religious.label);

            const title = escAttr(bits.join("\n"));

            const showStructure = a?.poiStructure && !a?.fieldCamp && !a?.religious && tileKey !== "water";

            if (showStructure) {
              const variantSeed = n2(seedU32, x + 999, y + 999);
              const ch = pickVariant("settlement", tileset, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="settlement" data-poi="structure" title="${title}">${ch}</span>`;
            } else if (a?.fieldCamp) {
              const ch = tileset.camp?.tile || tileset.settlement?.tile || tileset.plains?.tile;
              row += `<span data-cell="${x},${y}" data-tile="camp" title="${title}">${ch}</span>`;
            } else if (a?.religious) {
              const rel = a.religious;
              const fallbackRel = tileset.religious?.death || tileset.religious?.monastery || tileset.settlement?.tile || tileset.plains?.tile;
              const ch = rel.glyph || tileset.religious?.[rel.kind] || fallbackRel;
              row += `<span data-cell="${x},${y}" data-tile="religious" data-religious="${escAttr(rel.kind)}" title="${title}">${ch}</span>`;
            } else if (tileKey === "water" || tileKey === "lava") {
              const d = clamp(depthGrid[y][x] || 1, 1, 3);
              const ch = liquidGlyph(tileKey, d);
              row += `<span data-cell="${x},${y}" data-tile="${tileKey}" data-depth="${d}" title="${title}">${ch}</span>`;
            } else if (tileKey === "mountain") {
              const h = clamp(heightGrid[y][x] || 1, 1, 5);
              const ch = mountainGlyph(h);
              row += `<span data-cell="${x},${y}" data-tile="mountain" data-height="${h}" title="${title}">${ch}</span>`;
            } else if (tileKey === "forest") {
              const ft = forestTypeGrid[y][x] || "mixed";
              const variantSeed = n2(seedU32, x + 999, y + 999);
              const ch = forestGlyphForType(ft, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="forest" data-forest="${escAttr(ft)}" title="${title}">${ch}</span>`;
            } else {
              const variantSeed = n2(seedU32, x + 999, y + 999);
              const ch = pickVariant(tileKey, tileset, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="${tileKey}" title="${title}">${ch}</span>`;
            }
          }
          s += row + (y < N - 1 ? "\n" : "");
        }

        return { html: s, tileKeyGrid, depthGrid, heightGrid, forestTypeGrid, N, river };
      }

      /* ====================== Slice Composition ====================== */
      function coord(r) {
        const lat = (r() * 160 - 80).toFixed(2),
          lon = (r() * 360 - 180).toFixed(2);
        const NS = lat >= 0 ? "N" : "S",
          EW = lon >= 0 ? "E" : "W";
        return `${Math.abs(lat)}Â° ${NS}, ${Math.abs(lon)}Â° ${EW}`;
      }

      function resolvePlaceholders(s, ctx, r) {
        const base = resolveInlineOptions(s, r);
        return base.replace(/<poi>/g, () => ctx.poi?.() ?? "site").replace(/<weather>/g, () => ctx.weather?.() ?? "weather");
      }

      function stem(s) {
        return s.replace(/^(the|a|an)\s+/i, "").split(" ")[0];
      }

      function composeHook(r, tt, ctx = {}) {
        const h1 = oneOf(r, tt.hooks);
        const m1 = maybe(r, 0.6) ? resolvePlaceholders(oneOf(r, tt.hookMods), ctx, r) : null;

        const hasSecond = maybe(r, 0.65);
        if (!hasSecond) return m1 ? `${h1} ${m1}.` : `${h1}.`;

        const glue = oneOf(r, tt.hookGlue);

        const h2 = (() => {
          let v;
          let guard = 0;
          do {
            v = oneOf(r, tt.hooks);
          } while ((v === h1 || stem(v) === stem(h1)) && guard++ < 5);
          return v;
        })();

        const m2 = maybe(r, 0.6) ? resolvePlaceholders(oneOf(r, tt.hookMods), ctx, r) : null;

        let left = m1 ? `${h1} ${m1}` : h1;
        const right = m2 ? `${h2} ${m2}` : h2;

        left = left.charAt(0).toUpperCase() + left.slice(1);
        return `${left}, ${glue} ${right}.`;
      }

      function composeMotive(r, tt, { adjChance = 0.6, forceAdj = false, normalizeSpacing = true } = {}) {
        const motive = oneOf(r, tt.motives);
        const glue = oneOf(r, tt.motiveGlue);
        const includeAdj = forceAdj || maybe(r, adjChance);
        const adj = includeAdj ? oneOf(r, tt.relicAdjectives) : null;
        const noun = oneOf(r, tt.relicNouns);

        let line = `${motive} ${glue} ${adj ? adj + " " : ""}${noun}`;
        if (normalizeSpacing) line = line.replace(/\s{2,}/g, " ").trim();
        return line;
      }

      function buildSlice(seedStr, theme) {
        const base = h32(String(seedStr));
        const r = xs32(base);
        const tt = T[theme] || T.fantasy;
        const npcR = xs32(base ^ 0x52dce729);
        const factionOpR = xs32(base ^ 0x1fb77b21);
        const npcGen = new NameGenerator(npcR);
        const npcCount = 2 + ((npcR() * 3) | 0);

        const toponyms = buildToponyms(r, 20);
        const region = buildRegionsFromToponyms(r, toponyms, 1)[0];

        const biome = normalizeBiome(oneOf(r, tt.biome));
        const biomeName = biome.name;
        const tempPick = pickTempTier(r, tt);
        const rainPick = pickRainIndex(r, tt);
        const climA = oneOf(r, tt.climateAdj);
        const coords = coord(r);

        const climate = { tempTier: tempPick.tier, tempLabel: tempPick.label, rainIdx: rainPick.idx, rainLabel: rainPick.label, adj: climA };

        const fCount = 1 + ((r() * 3) | 0);
        const pCount = 2 + ((r() * 3) | 0);

        const factions = [];
        for (let i = 0; i < fCount; i++) {
          const motive = composeMotive(r, tt);
          const name = factionName(r, theme);
          factions.push({ name, motive });
        }

        const poiTypes = [];
        for (let i = 0; i < pCount; i++) poiTypes.push(oneOf(r, tt.pois));

        const weatherNow = oneOf(r, tt.weather);

        const mapSeed = h32(seedStr + "|map|" + theme);
        const map0 = genMap(mapSeed, biomeName, tileset, null, climate);
        const landCells = [];
        for (let y = 0; y < map0.N; y++) {
          for (let x = 0; x < map0.N; x++) {
            if (map0.tileKeyGrid[y][x] !== "water") landCells.push(`${x},${y}`);
          }
        }
        const worldMeta = placeWorldRefs(mapSeed, theme, map0.tileKeyGrid, map0.N, poiTypes, factions, r, biomeName);
        const settlementEntries = Array.from(worldMeta.settlementNameByCell.entries());
        const poiRefs = worldMeta.poiPlacements.map((p) => ({ name: p.poiName, cell: p.cell }));
        const poiNames = poiRefs.map((p) => p.name);
        const npcLocationKinds = Object.keys(NPC_TASKS);
        const npcs = [];
        const seenNpcNames = new Set();
        let guard = 0;
        const fieldMotiveVerbs = new Set(FIELD_MOTIVE_VERBS);

        function pickLandCell() {
          return landCells[(npcR() * landCells.length) | 0] || "0,0";
        }

        function pickLandCellForOps() {
          return landCells[(factionOpR() * landCells.length) | 0] || "0,0";
        }

        function pickLandCellNear(targetCell, maxDist) {
          if (!targetCell) return pickLandCell();
          const parts = String(targetCell).split(",");
          const tx = Number(parts[0]);
          const ty = Number(parts[1]);
          if (!Number.isFinite(tx) || !Number.isFinite(ty)) return pickLandCell();
          const near = [];
          for (const cell of landCells) {
            const c = cell.split(",");
            const x = Number(c[0]);
            const y = Number(c[1]);
            if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
            if (Math.abs(x - tx) + Math.abs(y - ty) <= maxDist) near.push(cell);
          }
          if (near.length) return near[(npcR() * near.length) | 0];
          return pickLandCell();
        }

        function cellDist(a, b) {
          const pa = String(a || "").split(",");
          const pb = String(b || "").split(",");
          const ax = Number(pa[0]);
          const ay = Number(pa[1]);
          const bx = Number(pb[0]);
          const by = Number(pb[1]);
          if (!Number.isFinite(ax) || !Number.isFinite(ay) || !Number.isFinite(bx) || !Number.isFinite(by)) return Infinity;
          return Math.abs(ax - bx) + Math.abs(ay - by);
        }

        function pickDifferentLandCell(avoidCell) {
          if (landCells.length <= 1) return landCells[0] || "0,0";
          let cell = avoidCell;
          for (let i = 0; i < 8 && cell === avoidCell; i++) cell = pickLandCell();
          if (cell === avoidCell) {
            const idx = landCells.indexOf(avoidCell);
            if (idx >= 0) return landCells[(idx + 1) % landCells.length];
          }
          return cell;
        }

        function pickDifferentLandCellForOps(avoidCell) {
          if (landCells.length <= 1) return landCells[0] || "0,0";
          let cell = avoidCell;
          for (let i = 0; i < 8 && cell === avoidCell; i++) cell = pickLandCellForOps();
          if (cell === avoidCell) {
            const idx = landCells.indexOf(avoidCell);
            if (idx >= 0) return landCells[(idx + 1) % landCells.length];
          }
          return cell;
        }

        function pickAltLocation(avoidCell) {
          const pool = [];
          for (const [cell, name] of settlementEntries) pool.push({ prep: "in", label: name, cell });
          for (const p of worldMeta.poiPlacements) pool.push({ prep: "at", label: p.poiName, cell: p.cell });
          const filtered = pool.filter((p) => p.cell !== avoidCell);
          if (filtered.length) return filtered[(npcR() * filtered.length) | 0];
          return { prep: "out in", label: "the wilds", cell: pickDifferentLandCell(avoidCell) };
        }

        function pickFactionOpLocation(avoidCell) {
          if (factionOpR() < 0.3) {
            return { prep: "out in", label: "the wilds", cell: pickLandCellNear(avoidCell, 10) };
          }
          const pool = [];
          for (const [cell, name] of settlementEntries) pool.push({ prep: "in", label: name, cell });
          for (const p of worldMeta.poiPlacements) pool.push({ prep: "at", label: p.poiName, cell: p.cell });
          const filtered = pool.filter((p) => p.cell !== avoidCell && cellDist(p.cell, avoidCell) <= 10);
          if (filtered.length) return filtered[(factionOpR() * filtered.length) | 0];
          return { prep: "out in", label: "the wilds", cell: pickLandCellNear(avoidCell, 10) };
        }

        function motiveVerb(motive) {
          return String(motive || "").trim().split(/\s+/)[0]?.toLowerCase() || "";
        }

        function npcLocationFor(kind) {
          if (kind === "faction") {
            const pick = oneOf(npcR, worldMeta.factionPlacements);
            if (pick) {
              if (npcR() < 0.45) {
                const alt = pickAltLocation(pick.cell);
                return {
                  prep: alt.prep,
                  label: alt.label,
                  cell: alt.cell,
                  affiliation: { prep: "for", label: pick.factionName, cell: pick.cell },
                };
              }
              return { prep: "with", label: pick.factionName, cell: pick.cell };
            }
          }
          if (kind === "settlement" && settlementEntries.length) {
            const [cell, name] = settlementEntries[(npcR() * settlementEntries.length) | 0];
            return { prep: "in", label: name, cell };
          }
          return { prep: "out in", label: "the wilds", cell: pickLandCell() };
        }

        function npcPoiName() {
          if (poiNames.length) return oneOf(npcR, poiNames);
          return oneOf(npcR, tt.pois);
        }

        while (npcs.length < npcCount && guard++ < npcCount * 20) {
          const name = npcGen.npcName();
          if (seenNpcNames.has(name)) continue;
          seenNpcNames.add(name);
          const kind = npcLocationKinds[(npcR() * npcLocationKinds.length) | 0];
          const taskTemplate = oneOf(npcR, NPC_TASKS[kind]);
          const taskPoi = npcPoiName();
          const task = resolvePlaceholders(taskTemplate, { poi: () => taskPoi, weather: () => weatherNow }, npcR);
          const taskHtml = linkifyRefs(task, poiRefs);
          let loc = npcLocationFor(kind);
          const taskUsesPoi = taskTemplate.includes("<poi>");
          const poiMatch = taskUsesPoi ? poiRefs.find((p) => p.name === taskPoi) : null;
          if (poiMatch) {
            // If the task already names a POI, keep the location in the wilds nearby.
            loc = { prep: "out in", label: "the wilds", cell: pickLandCellNear(poiMatch.cell, 5), affiliation: loc.affiliation };
          } else if (loc.prep === "out in" && loc.label === "the wilds") {
            const nearMatch = poiRefs.find((p) => p.name === taskPoi);
            if (nearMatch) loc.cell = pickLandCellNear(nearMatch.cell, 5);
          }
          npcs.push({ name, task, taskHtml, prep: loc.prep, label: loc.label, cell: loc.cell, affiliation: loc.affiliation });
        }

        const factionOps = worldMeta.factionPlacements.map((fp) => {
          const verb = motiveVerb(fp.motive);
          if (!fieldMotiveVerbs.has(verb)) return null;
          const roll = factionOpR();
          if (roll > 0.45) {
            if (roll < 0.85) {
              return { verb, prep: "out in", label: "the wilds", cell: pickLandCellNear(fp.cell, 10) };
            }
            return null;
          }
          return { verb, ...pickFactionOpLocation(fp.cell) };
        });

        factionOps.forEach((op, i) => {
          if (!op) return;
          const fp = worldMeta.factionPlacements[i];
          let a = worldMeta.annotations.get(op.cell);
          if (!a) {
            a = { poi: [], factions: [] };
            worldMeta.annotations.set(op.cell, a);
          }
          if (!a.factionOps) a.factionOps = [];
          a.factionOps.push({ name: fp.factionName, verb: op.verb });
        });

        for (const npc of npcs) {
          let a = worldMeta.annotations.get(npc.cell);
          if (!a) {
            a = { poi: [], factions: [] };
            worldMeta.annotations.set(npc.cell, a);
          }
          if (!a.npcs) a.npcs = [];
          a.npcs.push({ name: npc.name, task: npc.task });
        }

        const map1 = genMap(mapSeed, biomeName, tileset, worldMeta, climate);
        const hookPick = oneOf(r, worldMeta.poiPlacements);
        const hookPOIName = hookPick ? hookPick.poiName : oneOf(r, tt.pois);
        const hookPOICell = hookPick ? hookPick.cell : null;

        const hook = composeHook(r, tt, { poi: () => hookPOIName, weather: () => oneOf(r, tt.weather) });

        let hookHtml = escHtml(hook);
        if (hookPick && hookPOIName) {
          const re = new RegExp(escRe(hookPOIName), "g");
          hookHtml = hookHtml.replace(re, xref(hookPOICell, hookPOIName));
        }

        let html = "";
        html += `Theme  : ${escHtml(theme)}\n`;
        html += `Region : ${escHtml(region)}\n`;
        html += `Biome  : ${escHtml(biomeName)}\n`;
        html += `Coords : ${escHtml(coords)}\n`;
        html += `Climate: ${escHtml(tempPick.label)}, ${escHtml(rainPick.label)}, ${escHtml(climA)}\n`;
        html += `Current Weather: ${escHtml(weatherNow)}\n\n`;

        html += `Factions (${factions.length}):\n`;
        worldMeta.factionPlacements.forEach((fp, i) => {
          const baseAnn = worldMeta.annotations.get(fp.cell);
          const baseName = baseAnn?.settlementName ? baseAnn.settlementName : "Field Camp";
          html += `  ${i + 1}. ${xref(fp.cell, fp.factionName)}\n`;
          const op = factionOps[i];
          html += `\t- ${escHtml(fp.motive)}`;
          if (op) {
            html += ` ${escHtml(op.prep)} ${xref(op.cell, op.label)} @ (${escHtml(op.cell)})`;
          }
          html += "\n";
          html += `\t- Base: ${xref(fp.cell, baseName)} @ (${escHtml(fp.cell)})\n`;
          html += "\n";
        });

        html += `NPCs (${npcs.length}):\n`;
        npcs.forEach((npc) => {
          let line = `  - ${escHtml(npc.name)}: ${npc.taskHtml}`;
          if (npc.affiliation) {
            line += ` ${escHtml(npc.affiliation.prep)} ${xref(npc.affiliation.cell, npc.affiliation.label)}`;
          }
          line += ` ${escHtml(npc.prep)} ${xref(npc.cell, npc.label)}\n`;
          html += line;
        });
        html += "\n";

        html += `Points of Interest (${worldMeta.poiPlacements.length}):\n`;
        worldMeta.poiPlacements.forEach((p) => {
          const a = worldMeta.annotations.get(p.cell);
          const near = a?.settlementName ? `, near ${xref(p.cell, a.settlementName)}` : "";
          html += `  - ${xref(p.cell, p.poiName)}${near} @ (${escHtml(p.cell)})\n`;
        });

        html += `\nHook: ${hookHtml}\n`;

        const biomeLower = biomeName.toLowerCase();
        const mapFlags = { deadTrees: biomeAllowsFeature(biomeName, "dead trees", 0.2), desert: biomeLower.includes("desert") };

        return { html, mapGrid: map1.html, mapFlags };
      }

      /* ====================== State, Storage, UI ====================== */
      const $ = (sel) => document.querySelector(sel);
      const out = $("#out"),
        mapEl = $("#map"),
        seedIn = $("#seed"),
        seedShow = $("#seedShow"),
        themeSel = $("#theme");

      const btnGen = $("#gen"),
        // btnSave = $("#save"),
        btnPrev = $("#prev"),
        btnNext = $("#next");

      const btnCopySeed = $("#copySeed")
        // btnCopyOut = $("#copyOut"),
        // btnShare = $("#share");

      const histList = $("#hist"),
        favList = $("#favs"),
        btnClrFav = $("#clrFav");

      const LS_H = "sow_history_v2",
        LS_F = "sow_faves_v2",
        MAXH = 5;

      let histArr = [],
        faves = [],
        idx = -1,
        current = "";

      function loadLS() {
        try {
          histArr = JSON.parse(localStorage.getItem(LS_H) || "[]");
          faves = JSON.parse(localStorage.getItem(LS_F) || "[]");
        } catch (e) {
          histArr = [];
          faves = [];
        }
      }

      function saveLS() {
        localStorage.setItem(LS_H, JSON.stringify(histArr.slice(-MAXH)));
        localStorage.setItem(LS_F, JSON.stringify([...new Set(faves)]));
      }

      function renderLists() {
        if (!histList || !favList) return;

        histList.innerHTML = "";
        const recent = histArr.slice(-MAXH).slice().reverse();
        recent.forEach((s) => {
          const li = document.createElement("li");
          li.textContent = s;
          li.title = "Load seed";
          li.onclick = () => {
            setCurrentSeed(s, true);
            generate();
          };
          histList.appendChild(li);
        });

        favList.innerHTML = "";
        faves.forEach((s) => {
          const li = document.createElement("li");
          li.textContent = s;
          li.title = "Load favorite";
          li.onclick = () => {
            setCurrentSeed(s, true);
            generate();
          };
          favList.appendChild(li);
        });
      }

      function pushHistory(s) {
        if (!s) return;
        if (histArr.length === 0 || histArr[histArr.length - 1] !== s) histArr.push(s);
        if (histArr.length > MAXH) histArr = histArr.slice(-MAXH);
        idx = histArr.length - 1;
        saveLS();
        renderLists();
      }

      function navigate(d) {
        if (!histArr.length) return;
        idx = Math.max(0, Math.min(histArr.length - 1, idx + d));
        setCurrentSeed(histArr[idx], false);
        generate();
      }

      function setCurrentSeed(s, push = true) {
        current = s;
        seedShow.textContent = s;
        if (push) pushHistory(s);
        updateHash();
      }

      function parseHash() {
        const h = location.hash.replace(/^#/, "");
        const params = new URLSearchParams(h.includes("=") ? h : "");
        const s = params.get("s"),
          t = params.get("t");
        return { s: s ? decodeURIComponent(s) : null, t: t ? decodeURIComponent(t) : null };
      }

      function updateHash() {
        if (!current) return;
        const t = themeSel.value;
        const h = `s=${encodeURIComponent(current)}&t=${encodeURIComponent(t)}`;
        if (location.hash !== `#${h}`) window.history.replaceState(null, "", `#${h}`);
      }

      function resolveTheme(seed, sel) {
        if (sel !== "rnd") return sel;
        const keys = Object.keys(T);
        return keys[h32(seed) % keys.length];
      }

      function doGenerate() {
        const typed = seedIn.value.trim();
        const s = typed || randSeed();
        setCurrentSeed(s, true);
        generate();
      }

      /* ====================== Cross-hover binding ====================== */
      let _crossHoverBound = false;

      function bindCrossHover() {
        if (_crossHoverBound) return;
        _crossHoverBound = true;

        const clearHot = () => {
          document.querySelectorAll(".is-hot").forEach((el) => el.classList.remove("is-hot"));
        };

        const markCell = (cell) => {
          clearHot();
          if (!cell) return;

          const esc = window.CSS && CSS.escape ? CSS.escape(cell) : cell.replace(/"/g, '\\"');

          mapEl.querySelectorAll(`span[data-cell="${esc}"]`).forEach((el) => el.classList.add("is-hot"));
          out.querySelectorAll(`.xref[data-cell="${esc}"]`).forEach((el) => el.classList.add("is-hot"));
        };

        out.addEventListener("pointerover", (e) => {
          const t = e.target.closest?.(".xref[data-cell]");
          if (!t) return;
          markCell(t.dataset.cell);
        });

        out.addEventListener("pointerout", (e) => {
          const t = e.target.closest?.(".xref[data-cell]");
          if (!t) return;
          const rt = e.relatedTarget;
          if (rt && rt.closest?.(".xref[data-cell]")) return;
          clearHot();
        });

        mapEl.addEventListener("pointerover", (e) => {
          const t = e.target.closest?.("span[data-cell]");
          if (!t) return;
          markCell(t.dataset.cell);
        });

        mapEl.addEventListener("pointerout", (e) => {
          const t = e.target.closest?.("span[data-cell]");
          if (!t) return;
          const rt = e.relatedTarget;
          if (rt && rt.closest?.("span[data-cell]")) return;
          clearHot();
        });
      }

      function generate() {
        if (!current) return;
        const themeUsed = resolveTheme(current, themeSel.value);
        const { html, mapGrid, mapFlags } = buildSlice(current, themeUsed);
        out.innerHTML = html;
        mapEl.innerHTML = mapGrid;
        mapEl.dataset.deadTrees = mapFlags?.deadTrees ? "1" : "";
        mapEl.dataset.desert = mapFlags?.desert ? "1" : "";
        bindCrossHover();
      }

      function shareURL() {
        if (!current) return;
        updateHash();
      }

      /* ====================== Events + Init ====================== */
      btnGen.onclick = doGenerate;
      seedIn.addEventListener("keydown", (e) => {
        if (e.key === "Enter") doGenerate();
      });
      btnPrev.onclick = () => navigate(-1);
      btnNext.onclick = () => navigate(1);

      // btnSave.onclick = () => {
      //   if (!current) return;
      //   if (!faves.includes(current)) faves.push(current);
      //   saveLS();
      //   renderLists();
      // };

      btnCopySeed.onclick = () => {
        if (current) navigator.clipboard?.writeText(current);
      };

      // btnCopyOut.onclick = () => navigator.clipboard?.writeText((out.textContent || "") + "\n" + (mapEl.textContent || ""));

      // btnShare.onclick = () => shareURL();

      if (btnClrFav) {
        btnClrFav.onclick = () => {
          if (!faves.length) return;
          if (!confirm("Clear all favorites?")) return;
          faves = [];
          saveLS();
          renderLists();
        };
      }

      themeSel.onchange = () => {
        generate();
        updateHash();
      };

      window.addEventListener("hashchange", () => {
        const { s, t } = parseHash();
        if (t) themeSel.value = t;
        if (s) {
          setCurrentSeed(s, true);
          generate();
        }
      });

      (function init() {
        loadLS();
        renderLists();
        const { s, t } = parseHash();
        if (t) themeSel.value = t;

        if (s) {
          setCurrentSeed(s, true);
        } else if (histArr.length) {
          setCurrentSeed(histArr[histArr.length - 1], false);
          idx = histArr.length - 1;
        } else {
          setCurrentSeed(randSeed(), true);
        }
        generate();
      })();
    </script>
  </body>
</html>
