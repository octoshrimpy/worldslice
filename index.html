<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Slice-of-World Generator</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Noto+Sans+Symbols&family=Noto+Sans+Symbols+2&family=Noto+Sans+Linear+A&family=Noto+Sans+Linear+B&family=Noto+Emoji&display=swap">
    <style>
  @font-face {
  font-family: 'UnifontExMono';
  src: url('http://stgiga.github.io/UnifontEX/UnifontExMono.eot'); /* IE9 Compat Modes */
  src: url('http://stgiga.github.io/UnifontEX/UnifontExMono.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('https://stgiga.github.io/UnifontEX/UnifontExMono.woff') format('woff'), /* Pretty Modern Browsers */
       url('https://stgiga.github.io/UnifontEX/UnifontExMono.ttf')  format('truetype'), /* Safari, Android, iOS */
       url('http://stgiga.github.io/UnifontEX/UnifontExMono.woff2') format('woff2'), /* Super Modern Browsers */
       url('http://stgiga.github.io/UnifontEX/UnifontExMono.svg#UnifontExMono') format('svg'); /* Legacy iOS */
}

            
      /* Use UnifontEX first, then Noto fallbacks */
      :root{
        --app-font:
          "UnifontExMono",
          "Noto Sans",
          "Noto Sans Linear A",
          "Noto Sans Linear B",
          "Noto Sans Symbols 2",
          "Noto Sans Symbols",
          "Noto Emoji",
          monospace;
      }

      html, body, * {
        font-family: var(--app-font);
      }

      /* ====================== Sweetie16 (ONLY literal colors) ====================== */
      :root {
        --sw0: #1a1c2c;
        --sw1: #5d275d;
        --sw2: #b13e53;
        --sw3: #ef7d57;
        --sw4: #ffcd75;
        --sw5: #a7f070;
        --sw6: #38b764;
        --sw7: #257179;
        --sw8: #29366f;
        --sw9: #3b5dc9;
        --sw10: #41a6f6;
        --sw11: #73eff7;
        --sw12: #f4f4f4;
        --sw13: #94b0c2;
        --sw14: #566c86;
        --sw15: #333c57;

        /* ====================== App semantic vars ====================== */
        --bg: var(--sw0);
        --fg: var(--sw12);
        --mut: var(--sw13);
        --acc: var(--sw5);
        --btn: var(--sw15);
        --br: color-mix(in srgb, var(--sw12) 14%, transparent);

        --pane: var(--sw0);
        --pane2: color-mix(in srgb, black 40%, var(--sw0));
        --pill-bg: color-mix(in srgb, var(--sw0) 60%, var(--sw8));
        --pill-br: color-mix(in srgb, var(--sw7) 55%, transparent);

        /* cross-hover */
        --hot: var(--sw4);
        --hot-bg: color-mix(in srgb, var(--sw5) 14%, transparent);
        --hot-outline: color-mix(in srgb, var(--sw5) 28%, transparent);
        --ring: var(--sw5);

        /* ====================== Tile colors ====================== */
        --tile-water: var(--sw10);
        --tile-water-1: var(--sw10);
        --tile-water-2: var(--sw9);
        --tile-water-3: var(--sw8);
        --tile-lava-1: var(--sw2);
        --tile-lava-2: var(--sw3);
        --tile-lava-3: var(--sw4);

        --tile-mountain-1: var(--sw14);
        --tile-mountain-2: var(--sw13);
        --tile-mountain-3: var(--sw13);
        --tile-mountain-4: var(--sw13);
        --tile-mountain-5: var(--sw12);

        --tile-forest: var(--sw6);
        --tile-forest-deciduous: var(--sw6);
        --tile-forest-coniferous: var(--sw7);
        --tile-forest-dead: color-mix(in srgb, var(--sw4) 20%, var(--sw1));
        --tile-mycelium: color-mix(in srgb, var(--sw9) 50%, var(--sw2));

        --tile-grass: var(--sw6);
        --tile-grass-dead: color-mix(
          in srgb,
          var(--tile-grass) 60%,
          var(--sw1)
        );
        --tile-plains: color-mix(in srgb, var(--sw5) 50%, var(--sw0));
        --tile-stone-1: var(--sw15);
        --tile-stone-2: var(--sw14);
        --tile-settlement: var(--sw2);
        --tile-poi: var(--sw13);
        --tile-camp: var(--sw3);
        --tile-ruins: var(--sw14);
        --tile-overgrown-ruins: color-mix(
          in srgb,
          var(--tile-ruins) 50%,
          var(--sw5)
        );
        --tile-road-primary: color-mix(in srgb, var(--sw4) 10%, var(--sw0));
        --tile-road-secondary: color-mix(in srgb, var(--sw15) 10%, var(--sw0));
        --tile-fungal-settlement: color-mix(
          in srgb,
          var(--tile-mycelium) 45%,
          var(--tile-settlement)
        );
        --tile-fungal-ruins: color-mix(
          in srgb,
          var(--tile-mycelium) 65%,
          var(--tile-ruins)
        );
        --tile-desert: color-mix(in srgb, var(--sw4) 70%, var(--sw1));
        --tile-religious-death: var(--sw3);
        --tile-religious-monastery: var(--sw11);
        --tile-crystal-blue: color-mix(in srgb, var(--sw11) 70%, var(--sw12));
        --tile-crystal-pink: color-mix(in srgb, var(--sw1) 45%, var(--sw12));
        --tile-crystal-green: color-mix(in srgb, var(--sw5) 55%, var(--sw12));
        --tile-crystal: var(--tile-crystal-blue);
      }

      html {
        font-size: 120%;
      }

      html,
      body {
        height: 100%;
        display: flex;
        flex-direction: column;
        margin: 0;
        padding: 0;
        background: var(--bg);
        color: var(--fg);
      }

      header {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
        align-items: center;
        padding: 12px;
        border-bottom: 1px solid var(--br);
      }

      h1 {
        font-size: 1rem;
        margin: 0 12px 0 0;
        color: var(--acc);
        flex: 1;
        white-space: nowrap;
      }

      label {
        color: var(--mut);
        font-size: 0.75rem;
      }

      .menu-toggle {
        position: absolute;
        width: 1px;
        height: 1px;
        margin: -1px;
        border: 0;
        padding: 0;
        overflow: hidden;
        clip: rect(0 0 0 0);
        white-space: nowrap;
      }
      .menu-button {
        display: none;
        align-items: center;
        gap: 6px;
        padding: 7px 10px;
        border: 1px solid var(--br);
        border-radius: 6px;
        background: var(--btn);
        color: var(--fg);
        cursor: pointer;
      }
      .menu-icon {
        display: inline-block;
        width: 16px;
        height: 2px;
        background: currentColor;
        position: relative;
      }
      .menu-icon::before,
      .menu-icon::after {
        content: "";
        position: absolute;
        left: 0;
        width: 16px;
        height: 2px;
        background: currentColor;
      }
      .menu-icon::before {
        top: -5px;
      }
      .menu-icon::after {
        top: 5px;
      }
      .menu-content {
        display: inline-flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      input,
      select,
      button {
        background: var(--btn);
        color: var(--fg);
        border: 1px solid var(--br);
        border-radius: 6px;
        padding: 7px 10px;
      }

      input[type="text"] {
        min-width: 10rem;
      }

      button {
        cursor: pointer;
      }

      button:active {
        transform: translateY(1px);
      }

      .wrap {
        flex-grow: 1;
        padding: 12px;
        display: flex;
        gap: 12px;
      }

      .pane {
        border: 1px solid var(--br);
        border-radius: 8px;
        padding: 10px;
        background: var(--pane2);
        position: relative;
        display: flex;
        gap: 1rem;
        flex-grow: 1;
      }

      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      pre {
        white-space: pre;
        overflow: auto;
        margin: 0;
      }

      #out {
        flex: 1;
        text-wrap: balance;
        color: var(--sw13);
      }

      #out .xref {
        text-decoration: underline;
        color: var(--sw6);
        text-decoration-color: var(--sw14);
        transition: all 0.15s ease-in-out;
      }
      #out .xref.is-hot {
        text-decoration: none;
      }

      .mapwrap {
        /* flex: 1; */
        display: flex;
        flex-direction: column;
        align-items: flex-end;
      }
      .map-tip {
        margin-top: 6px;
        min-height: 1.2em;
        color: var(--mut);
      }

      /* Larger, square-cell minimap */
      #map {
        margin-top: 8px;
        overflow: visible;
        cursor: pointer;
      }
      #map span {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        width: 1.2rem;
        height: 1.2rem;
        transition: all 0.15s ease-in-out;
      }
      #map span.map-label {
        width: auto;
        min-width: 12ch;
        justify-content: flex-start;
        color: var(--sw12);
        font-weight: 700;
        letter-spacing: 0.02em;
      }
      @media (hover: hover) and (pointer: fine) {
        #map span:hover {
          transform: scale(1.3);
        }
        #map span.map-label:hover {
          transform: none;
        }
      }

      /* ========= Tile coloring (NO magic colors) ========= */
      #map span[data-tile="water"] {
        color: var(--tile-water);
      }
      #map span[data-tile="water"][data-depth="1"] {
        color: var(--tile-water-1);
      }
      #map span[data-tile="water"][data-depth="2"] {
        color: var(--tile-water-2);
      }
      #map span[data-tile="water"][data-depth="3"] {
        color: var(--tile-water-3);
      }
      #map span[data-tile="lava"][data-depth="1"] {
        color: var(--tile-lava-1);
      }
      #map span[data-tile="lava"][data-depth="2"] {
        color: var(--tile-lava-2);
      }
      #map span[data-tile="lava"][data-depth="3"] {
        color: var(--tile-lava-3);
      }

      #map span[data-tile="mountain"][data-height="1"] {
        color: var(--tile-mountain-1);
      }
      #map span[data-tile="mountain"][data-height="2"] {
        color: var(--tile-mountain-2);
      }
      #map span[data-tile="mountain"][data-height="3"] {
        color: var(--tile-mountain-3);
      }
      #map span[data-tile="mountain"][data-height="4"] {
        color: var(--tile-mountain-4);
      }
      #map span[data-tile="mountain"][data-height="5"] {
        color: var(--tile-mountain-5);
      }

      #map span[data-tile="forest"] {
        color: var(--tile-forest);
      }
      #map span[data-tile="forest"][data-forest="deciduous"] {
        color: var(--tile-forest-deciduous);
      }
      #map span[data-tile="forest"][data-forest="coniferous"] {
        color: var(--tile-forest-coniferous);
      }
      #map span[data-tile="forest"][data-forest="dead"] {
        color: var(--tile-forest-dead);
      }
      #map span[data-tile="mycelium"] {
        color: var(--tile-mycelium);
      }

      #map span[data-tile="grass"] {
        color: var(--tile-grass);
      }
      #map[data-dead-trees="1"] span[data-tile="grass"],
      #map[data-desert="1"] span[data-tile="grass"] {
        color: var(--tile-grass-dead);
      }
      #map span[data-tile="plains"] {
        color: var(--tile-plains);
      }
      #map span[data-tile="stone"][data-stone="1"] {
        color: var(--tile-stone-1);
      }
      #map span[data-tile="stone"][data-stone="2"] {
        color: var(--tile-stone-2);
      }
      #map span[data-tile="settlement"] {
        color: var(--tile-settlement);
      }
      #map span[data-tile="poi"] {
        color: var(--tile-poi);
      }
      #map span[data-poi="marker"][data-ferry-id] {
        color: var(--tile-water-1);
      }
      #map span[data-tile="ruins"] {
        color: var(--tile-ruins);
      }
      #map span[data-tile="overgrown-ruins"] {
        color: var(--tile-overgrown-ruins);
      }
      #map span[data-tile="fungal-settlement"] {
        color: var(--tile-fungal-settlement);
      }
      #map span[data-tile="fungal-ruins"] {
        color: var(--tile-fungal-ruins);
      }
      #map span[data-tile="camp"] {
        color: var(--tile-camp);
      }
      #map span[data-tile="desert"] {
        color: var(--tile-desert);
      }
      #map span[data-tile="beach"] {
        color: var(--tile-desert);
      }
      #map span[data-tile="religious"][data-religious="death"] {
        color: var(--tile-religious-death);
      }
      #map span[data-tile="religious"][data-religious="monastery"] {
        color: var(--tile-religious-monastery);
      }
      #map span[data-tile="crystal"] {
        color: var(--tile-crystal);
      }
      #map span[data-tile="crystal"][data-crystal="blue"] {
        color: var(--tile-crystal-blue);
        filter: saturate(1);
      }
      #map span[data-tile="crystal"][data-crystal="pink"] {
        color: var(--tile-crystal-pink);
        filter: saturate(3);
      }
      #map span[data-tile="crystal"][data-crystal="green"] {
        color: var(--tile-crystal-green);
        filter: saturate(1);
      }
      #map span[data-road="primary"] {
        opacity: 1;
        /* background: color-mix(in srgb, var(--tile-road-primary) 75%, transparent); */
        /* box-shadow: inset 0 0 0.2rem color-mix(in srgb, var(--tile-road-primary) 70%, transparent); */
      }
      #map span[data-road="secondary"] {
        opacity: 0.23;
        /* background: color-mix(in srgb, var(--tile-road-secondary) 70%, transparent); */
        /* box-shadow: inset 0 0 0.2rem color-mix(in srgb, var(--tile-road-secondary) 60%, transparent); */
      }
      #map {

      }
      span[data-road] .road-glyph,.is-ferry-path {

        display: inline-flex;
        transform: scaleX(2);
        transform-origin: center;
        pointer-events: none;
      }

      .small {
        font-size: 0.75rem;
        color: var(--mut);
      }

      ul.list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      ul.list li {
        background: var(--btn);
        border: 1px solid var(--br);
        padding: 4px 7px;
        border-radius: 6px;
        cursor: pointer;
      }
      @media (hover: hover) and (pointer: fine) {
        ul.list li:hover {
          border-color: var(--acc);
        }
      }

      .head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .mut {
        color: var(--mut);
      }
      .sep {
        height: 10px;
      }

      .pill {
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid var(--br);
        background: var(--pill-bg);
      }
      .nowrap {
        white-space: nowrap;
      }
      .seed-controls {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      button.pill {
        border-radius: 999px;
        padding: 4px 8px;
      }
      button.pill.is-active {
        background: color-mix(in srgb, var(--acc) 65%, var(--btn));
        color: var(--bg);
        border-color: color-mix(in srgb, var(--acc) 55%, var(--btn));
      }
      .seedpill {
        margin-left: 6px;
        color: var(--fg);
        border-color: var(--pill-br);
        background: var(--pill-bg);
      }

      @media (max-width: 45rem) {
        header {
          align-items: center;
          position: sticky;
          top: 0;
          z-index: 10;
          background: var(--bg);
        }
        .wrap {
          flex-direction: column;
        }
        .pane {
          flex-direction: column-reverse;
          align-items: stretch;
        }
        #out {
          width: 100%;
        }
        .mapwrap {
          width: 100%;
          align-items: flex-start;
        }
        .menu-button {
          display: inline-flex;
          margin-left: auto;
          position: absolute;
          top: 1rem;
          right: 1rem;
        }

        .row {
          flex: 1 1 100%;
        }
        .menu-content {
          display: none;
          width: 100%;
        }
        header:has(.menu-toggle:checked) .menu-content {
          display: flex;
        }
        #map {
          width: 100%;
          font-size: min(1.2rem, 3.5vw);
        }
        #map span {
          width: 1em;
          height: 1em;
          font-size: 1em;
        }
      }

      .hidden {
        display: none;
      }

      button.primary {
        background: color-mix(in srgb, var(--acc) 70%, var(--btn));
        color: var(--bg);
        font-weight: bold;
        transition: all ease-in-out 0.15s;
      }
      @media (hover: hover) and (pointer: fine) {
        button.primary:hover {
          background: color-mix(in srgb, var(--acc) 80%, var(--btn));
        }
      }

      /* ===== cross-hover linking ===== */
      #map span.is-hot {
        position: relative;
        transform-origin: center center;
        transform: scale(1.5);
      }
      #map span.is-hot::before {
        display: flex;
        height: 1.5rem;
        width: 1.5rem;
        border: 2px solid var(--ring);
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        background: var(--bg);
        z-index: -1;
        pointer-events: none;
      }
      body.show-all #map span.is-hot::before {
        border-color: var(--hot-color, var(--hot));
      }

      #out .xref {
        cursor: pointer;
        border-radius: 4px;
        padding: 0 2px;
      }

      #out .xref.is-hot {
        color: var(--acc);
        background: var(--hot-bg);
        outline: 1px solid var(--hot-outline);
      }
      body.show-all #out .xref.is-hot {
        color: var(--hot-color, var(--acc));
        background: color-mix(
          in srgb,
          var(--hot-color, var(--acc)) 18%,
          transparent
        );
        outline: 1px solid
          color-mix(in srgb, var(--hot-color, var(--acc)) 45%, transparent);
      }
    </style>
  </head>

  <body>
    <header>
      <h1>World Slice</h1>
      <input id="menuToggle" class="menu-toggle" type="checkbox" />
      <div class="row">
        <button id="prev">Prev</button>
        <button id="gen" class="primary">Generate</button>
        <button id="next">Next</button>
        <!-- <button id="save" title="Add current seed to favorites">Save</button> -->
        <span class="menu-content">
          <button id="copySeed" title="Copy current seed">Copy Seed</button>
          <label for="seed">Seed</label>
          <input id="seed" type="text" placeholder="Leave blank for random" />
          <label for="theme">Theme</label>
          <select id="theme" class="nowrap" title="Theme">
            <option value="rnd">Random (seed-based)</option>
            <option value="fantasy">Fantasy</option>
            <option value="scifi">Sci-fi</option>
            <option value="apocalypse">Post-apocalyptic</option>
          </select>
        </span>
        <!-- <button id="copyOut" title="Copy output text">Copy Output</button> -->
        <!-- <button id="share" title="Update URL with current seed/theme">Share</button> -->
      </div>
      <label for="menuToggle" class="menu-button">
        <span class="menu-icon" aria-hidden="true"></span>
        <span class="menu-text">Menu</span>
      </label>
    </header>

    <div class="wrap">
      <div class="pane">
        <pre id="out"></pre>
        <span class="mapwrap">
          <pre id="map"></pre>
          <div id="mapTip" class="map-tip small" aria-live="polite"></div>
          <span class="seed-controls">
            <span class="pill seedpill small">
              Seed:
              <strong id="seedShow">â€”</strong>
            </span>
            <button id="showAll" class="pill small" type="button" aria-pressed="false">
              Show All
            </button>
          </span>
        </span>
      </div>

      <div class="hidden">
        <div class="head">
          <strong>History</strong><span class="small mut">(latest 5)</span>
        </div>
        <div id="histWrap">
          <ul id="hist" class="list"></ul>
        </div>
        <div class="sep"></div>
        <div class="head favs">
          <strong>Favorites</strong
          ><button id="clrFav" class="pill small">Clear</button>
        </div>
        <ul id="favs" class="list"></ul>
        <div class="sep"></div>
        <div class="small mut">
          Tip: press <strong>Enter</strong> in the seed box to use that seed
          once.
        </div>
      </div>
    </div>

    <script>
      /** 
       * TODO: wrap NPC names in span, color them --sw12
       * TODO: hook grammar makes no sense when it combines multiple modifiers, e.g. "a relic goes missing near the rootbound enclave during light wind conditions". maybe only allow one modifier per hook?
       * 
      **/

      // #region App Script Overview
      // Sections: Constants, Theme Tables, Tileset, Lexicon Data, RNG Utilities,
      // Naming + Lexicon Builders, World Builder, Map Generation, UI/State, Events.
      // #endregion App Script Overview

      // #region Constants + Feature Flags
      /* ====================== Tables (themes) ====================== */
      const geoFeatures = [
        "river-water",
        "river-lava",
        "mountain",
        "beaches",
        "dunes",
        "oasis",
        "ruins",
        "ridge",
        "reef", // not implemented yet
        "mycelium",
        "crystals",
        "dead trees",
      ];
      const moistureLevels = [
        ["arid", "bone-dry", "dusty"],
        ["dry-wind", "parched", "desiccating"],
        ["breezy", "lightly-damp", "fresh"],
        ["humid", "muggy", "damp"],
        ["mist-laden", "foggy", "drizzly"],
        ["rainy", "steady-rain", "overcast"],
        ["soaking", "waterlogged", "downpouring"],
        ["saturated", "flooded", "rain-soaked"],
      ];
      const tempLevels = [
        ["frost-bit", "glacial", "ice-cold"],
        ["cold", "chilled", "wintry"],
        ["cool", "crisp", "brisk"],
        ["mild", "temperate", "balmy"],
        ["warm", "sun-warmed", "pleasant"],
        ["hot", "sweltering", "baking"],
        ["blistering", "scorching", "searing"],
        ["oven-hot", "infernal", "white-hot"],
      ];
      const climateAdjLevels = [
        "rocky",
        "stone-littered",
        "gravelly",
        "dusty",
        "powdery",
        "silted",
        "foggy",
        "mist-laden",
        "haze-dimmed",
        "smoky",
        "ash-hung",
        "soot-touched",
        "cracked",
        "fissured",
        "split",
        "scarred",
        "worn",
        "gouged",
        "shadowed",
        "shade-wreathed",
        "dim",
        "glowing",
        "ember-lit",
        "aura-lit",
        "pitted",
        "pockmarked",
        "hole-riddled",
        "overgrown",
        "wild",
        "tangle-thick",
        "mossy",
        "lichened",
        "verdant",
        "fungal",
        "spore-rich",
        "mycelial",
        "boggy",
        "sodden",
        "peaty",
        "marshy",
        "reed-choked",
        "fen-like",
        "rooted",
        "root-bound",
        "tangled",
        "thorny",
        "spined",
        "barbed",
        "brambly",
        "briar-choked",
        "thicketed",
        "ancient",
        "timeworn",
        "age-sunk",
        "veined",
        "striated",
        "threaded",
        "twilight",
        "dusk-lit",
        "gloaming",
        "starlit",
        "star-washed",
        "star-sprinkled",
        "moonlit",
        "moon-washed",
        "lunar-lit",
        "buried",
        "entombed",
        "submerged",
        "forgotten",
        "lost",
        "forsaken",
        "synthetic",
        "fabricated",
        "engineered",
        "alien",
        "xeno",
        "offworld",
        "metallic",
        "steel-bright",
        "iron-hard",
        "magnetic",
        "magnetized",
        "polarity-charged",
        "gravitic",
        "gravity-warped",
        "mass-bent",
        "orbital",
        "high-orbit",
        "station-side",
        "stellar",
        "star-born",
        "heliac",
        "lunar",
        "moonward",
        "tidal",
        "current-tossed",
        "pull-swept",
        "crystalline",
        "crystal-lined",
        "prismatic",
        "coralline",
        "reef-bound",
        "coral-spired",
        "glassy",
        "vitrified",
        "mirror-bright",
        "mutant",
        "altered",
        "twisted",
        "viral",
        "pathogen-laced",
        "contagious",
        "sentient",
        "aware",
        "cognizant",
        "abandoned",
        "derelict",
        "empty",
        "encrypted",
        "cipher-locked",
        "encoded",
        "rifted",
        "split-reality",
        "fractured",
        "plasmatic",
        "ionized",
        "charged",
        "sooty",
        "blackened",
        "char-streaked",
        "ashen",
        "cinder-gray",
        "ash-dulled",
        "shattered",
        "splintered",
        "broken",
        "rusted",
        "corroded",
        "oxidized",
        "sealed",
        "locked-down",
        "quarantined",
        "slimed",
        "slick",
        "ooze-coated",
        "collapsed",
        "ruined",
        "ravaged",
        "wasted",
        "hollow",
        "caverned",
        "voided",
      ];

      const DEBUG = false;
      const FEATURE_SET = new Set([...geoFeatures, "lagoon", "watering hole"]);

      function debugWarn(message) {
        if (DEBUG) console.warn(message);
      }

      function validateFeatureName(id, context) {
        if (!DEBUG) return;
        if (!FEATURE_SET.has(id))
          debugWarn(
            `Unknown feature "${id}"${context ? ` in ${context}` : ""}`,
          );
      }

      // #endregion Constants + Feature Flags
      // #region Theme Tables
      const themes = {
        fantasy: {
          biome: [
            {
              name: "tundra",
              moistureRange: [1, 3],
              tempRange: [1, 2],
              features: {
                "river-water": 0.3,
                lake: 0.25,
                mountain: 0.35,
                ridge: 0.4,
                ruins: 0.15,
              },
            },
            {
              name: "taiga",
              moistureRange: [3, 6],
              tempRange: [2, 3],
              features: {
                "river-water": 0.45,
                lake: 0.35,
                mountain: 0.25,
                ridge: 0.3,
                ruins: 0.2,
                mycelium: 0.25,
              },
            },
            {
              name: "temperate forest",
              moistureRange: [4, 7],
              tempRange: [3, 5],
              features: {
                "river-water": 0.5,
                lake: 0.35,
                ruins: 0.2,
                ridge: 0.2,
                mycelium: 0.3,
              },
            },
            {
              name: "steppe",
              moistureRange: [2, 4],
              tempRange: [3, 5],
              features: {
                "river-water": 0.25,
                lake: 0.15,
                "watering hole": 0.3,
                dunes: 0.25,
                ridge: 0.2,
                ruins: 0.15,
              },
            },
            {
              name: "savanna",
              moistureRange: [3, 6],
              tempRange: [5, 7],
              features: {
                "river-water": 0.35,
                lake: 0.2,
                "watering hole": 0.45,
                dunes: 0.2,
                oasis: 0.15,
                ruins: 0.1,
              },
            },
            {
              name: "desert",
              moistureRange: [1, 2],
              tempRange: [7, 8],
              features: {
                "river-water": 0.1,
                lake: 0.05,
                "watering hole": 0.3,
                dunes: 0.6,
                oasis: 0.4,
                ruins: 0.25,
                ridge: 0.25,
                "river-lava": 0.1,
              },
            },
            {
              name: "jungle",
              moistureRange: [6, 8],
              tempRange: [6, 8],
              features: {
                "river-water": 0.6,
                lake: 0.35,
                ruins: 0.25,
                lagoon: 0.25,
                mycelium: 0.4,
              },
            },
            {
              name: "wetlands",
              moistureRange: [7, 8],
              tempRange: [4, 6],
              features: {
                "river-water": 0.7,
                lake: 0.45,
                lagoon: 0.4,
                mycelium: 0.3,
                ruins: 0.15,
              },
            },
            {
              name: "highlands",
              moistureRange: [3, 5],
              tempRange: [2, 4],
              features: {
                "river-water": 0.3,
                mountain: 0.7,
                ridge: 0.6,
                lake: 0.2,
                "river-lava": 0.15,
                ruins: 0.2,
              },
            },
            {
              name: "islands",
              moistureRange: [5, 7],
              tempRange: [4, 6],
              features: {
                "river-water": 0.25,
                lake: 0.2,
                reef: 0.7,
                lagoon: 0.6,
                dunes: 0.2,
                ruins: 0.25,
              },
            },
            {
              name: "badlands",
              moistureRange: [1, 3],
              tempRange: [5, 7],
              features: {
                "river-water": 0.15,
                mountain: 0.4,
                ridge: 0.6,
                dunes: 0.3,
                ruins: 0.35,
                "river-lava": 0.2,
                "dead trees": 0.3,
              },
            },
            {
              name: "crystal barrens",
              moistureRange: [1, 3],
              tempRange: [5, 7],
              features: {
                "river-water": 0.15,
                "river-lava": 0.2,
                dunes: 0.35,
                ridge: 0.45,
                ruins: 0.3,
                crystals: 0.7,
                "dead trees": 0.25,
              },
            },
            {
              name: "fungal expanse",
              moistureRange: [6, 8],
              tempRange: [4, 6],
              features: {
                mycelium: 0.8,
                lake: 0.25,
                "river-water": 0.35,
                ruins: 0.2,
                "dead trees": 0.3,
              },
            },
            {
              name: "ashen plains",
              moistureRange: [1, 3],
              tempRange: [6, 8],
              features: {
                "river-lava": 0.5,
                dunes: 0.25,
                ridge: 0.4,
                mountain: 0.3,
                ruins: 0.25,
                "dead trees": 0.45,
              },
            },
            {
              name: "shattered coast",
              moistureRange: [5, 7],
              tempRange: [4, 6],
              features: {
                beaches: 0.6,
                reef: 0.55,
                lake: 0.25,
                "river-water": 0.3,
                ruins: 0.2,
                dunes: 0.15,
                crystals: 0.2,
              },
            },
            {
              name: "hollow grove",
              moistureRange: [5, 7],
              tempRange: [3, 5],
              features: {
                mycelium: 0.45,
                "dead trees": 0.65,
                "river-water": 0.25,
                lake: 0.2,
                ruins: 0.35,
                ridge: 0.25,
              },
            },
            {
              name: "obsidian high desert",
              moistureRange: [1, 2],
              tempRange: [7, 8],
              features: {
                dunes: 0.55,
                oasis: 0.2,
                "river-lava": 0.35,
                ridge: 0.4,
                mountain: 0.25,
                ruins: 0.3,
              },
            }
          ],
          factionsN1: [
            "Order",
            "Guild",
            "Clan",
            "Court",
            "Circle",
            "Syndicate",
            "Chapter",
            "Coven",
            "Brotherhood",
            "Company",
            "League",
            "Consulate",
            "Caravan",
            "Enclave",
            "Assembly",
            "Dominion",
            "Conclave",
            "Pact",
            "Sect",
            "Keep",
            "Banner",
            "Throng",
            "Kin",
            "House",
            "Hollow",
            "Sanctum",
            "Forge",
            "Crusade",
            "March",
            "Host",
          ],
          factionsN2: [
            "of the",
            "of",
            "for the",
            "under",
            "against the",
            "beneath the",
            "among the",
            "beyond the",
            "within the",
            "beside the",
            "before the",
            "after the",
            "toward the",
            "upon the",
          ],
          roles: [
            "Wardens",
            "Archivists",
            "Bonepickers",
            "Skyfarers",
            "Prospectors",
            "Scribes",
            "Wayfinders",
            "Stormcallers",
            "Reclaimers",
            "Oathkeepers",
            "Lamplighters",
            "Seers",
            "Witchbinders",
            "Lorehunters",
            "Pathmakers",
            "Gravetenders",
            "Runesmiths",
            "Beastwalkers",
            "Spellweavers",
            "Hearthguard",
            "Frostborn",
            "Flamebearers",
            "Thornwatch",
            "Miststriders",
          ],
          motives: [
            "cleansing",
            "binding",
            "awakening",
            "silencing",
            "tending",
            "unlocking",
            "consecrating",
          ],
          motiveGlue: [
            "the only remaining",
            "a",
            "an ancient",
            "a forgotten",
            "a cursed",
            "the last",
            "a sacred",
            "a sealed",
            "an abandoned",
            "a hidden",
            "a buried",
            "a ruined",
            "a lost",
            "a reclaimed",
          ],
          relicAdjectives: [
            "ancient",
            "forgotten",
            "sealed",
            "cracked",
            "hallowed",
            "bound",
            "runed",
            "sunken",
            "twilight",
            "blood-marked",
            "iron-bound",
            "frosted",
            "echoing",
            "cursed",
            "blessed",
            "hidden",
            "star-forged",
            "bone-carved",
          ],
          relicNouns: [
            "tablet",
            "idol",
            "scroll",
            "blade",
            "mask",
            "sigil",
            "key",
            "horn",
            "stone",
            "ring",
            "crown",
            "lens",
            "staff",
            "seal",
            "totem",
            "mirror",
            "lock",
            "gem",
            "vessel",
            "pendant",
          ],
          pois: [
            "relic line",
            "leyline path",
            "star-iron vein",
            "storm cycle",
            "dune-wyrm pact",
            "glowmoss field",
            "floodgate",
            "hearthhold",
            "shattered runestone",
            "cursed grove",
            "rootbound enclave",
            "dormant sentinel",
            "emberfield",
            "sealed vault",
            "moonshade beast",
            "sky-bridge",
          ],
          weather: [
            "light wind",
            "fine dust in the air",
            "low thunder",
            "steady breeze",
            "scattered clouds",
            "brief gusts",
            "thin mist",
            "dry air",
            "occasional flashes",
            "soft rainfall",
            "distant rumble",
            "light haze",
            "static in the air",
            "drifting ash",
            "stillness before change",
            "faint crackling",
            "settling silt",
            "air thick with pollen",
            "cool drafts",
            "humid stillness",
          ],
          hooks: [
            "an oath breaks",
            "a relic goes missing",
            "a boundary marker is moved",
            "the river changes course",
            "the caravan doesn't arrive",
            "a ward stops working",
            "a beast emerges from the quarry",
            "a gate opens without warning",
            "a name is removed from the scrolls",
            "the harvest comes too early",
            "the flame marks someone new",
            "the map is altered",
            "a rival claims blood-right",
            "the tithe causes unrest",
            "the monolith sinks faster",
            "the plants react to movement",
            "a vault is uncovered",
            "the sky cracks at dawn",
            "a sigil appears",
            "the well runs dry",
          ],
          hookMods: [
            "near the <poi>",
            "within the biome",
            "beneath the <poi>",
            "around the <poi>",
            "amid <weather>",
            "under <weather> skies",
          ],
          hookConsequences: [
            "the enclave seals its gates",
            "<faction> demands a blood-right hearing",
            "a patrol searches the <poi>",
            "a rival clan claims the <poi>",
            "a warden is stripped of their mark",
            "the tithe is doubled at the <poi>",
            "a messenger from <poi> vanishes",
            "<npc> is tasked to retrieve it",
            "trade along the <poi> is suspended",
            "a quiet exodus begins from the <poi>",
          ],
        },

        scifi: {
          biome: [
            {
              name: "oceanic world",
              moistureRange: [6, 8],
              tempRange: [4, 6],
              features: {
                reef: 0.8,
                lagoon: 0.7,
                "river-water": 0.3,
                lake: 0.2,
                ruins: 0.15,
              },
            },
            {
              name: "barren craters",
              moistureRange: [1, 3],
              tempRange: [2, 5],
              features: {
                ridge: 0.6,
                mountain: 0.4,
                "river-lava": 0.2,
                ruins: 0.2,
                lake: 0.05,
              },
            },
            {
              name: "lava fields",
              moistureRange: [1, 3],
              tempRange: [7, 8],
              features: {
                "river-lava": 0.8,
                mountain: 0.5,
                ridge: 0.4,
                ruins: 0.15,
              },
            },
            {
              name: "arboreal belts",
              moistureRange: [4, 7],
              tempRange: [4, 6],
              features: {
                "river-water": 0.5,
                lake: 0.3,
                ruins: 0.2,
                mycelium: 0.25,
              },
            },
            {
              name: "fungal mats",
              moistureRange: [6, 8],
              tempRange: [4, 6],
              features: {
                mycelium: 0.9,
                lake: 0.25,
                "river-water": 0.35,
                ruins: 0.2,
              },
            },
            {
              name: "erg desert",
              moistureRange: [1, 2],
              tempRange: [7, 8],
              features: {
                dunes: 0.8,
                oasis: 0.35,
                "watering hole": 0.2,
                "river-water": 0.15,
                ruins: 0.2,
              },
            },
            {
              name: "ice shelf",
              moistureRange: [2, 4],
              tempRange: [1, 2],
              features: {
                lake: 0.3,
                "river-water": 0.2,
                ridge: 0.35,
                mountain: 0.3,
                ruins: 0.1,
              },
            },
            {
              name: "toxic bogs",
              moistureRange: [7, 8],
              tempRange: [4, 6],
              features: {
                "river-water": 0.5,
                lake: 0.4,
                lagoon: 0.25,
                ruins: 0.2,
                mycelium: 0.7,
              },
            },
            {
              name: "megacity sector",
              moistureRange: [3, 6],
              tempRange: [4, 6],
              features: {
                ruins: 0.6,
                ridge: 0.3,
                "river-water": 0.25,
                lake: 0.15,
              },
            },
            {
              name: "ring habitat",
              moistureRange: [4, 7],
              tempRange: [4, 6],
              features: {
                "river-water": 0.35,
                lake: 0.25,
                lagoon: 0.3,
                ridge: 0.2,
                ruins: 0.2,
              },
            },
            {
              name: "tidal wetlands",
              moistureRange: [7, 8],
              tempRange: [4, 6],
              features: {
                "river-water": 0.6,
                lagoon: 0.6,
                reef: 0.4,
                lake: 0.3,
                mycelium: 0.2,
              },
            },
          ],
          factionsN1: [
            "Consortium",
            "Syndicate",
            "Research Cell",
            "Freeport",
            "Colonial Office",
            "Outer Rim Guild",
            "Scavenger Crew",
            "Offworld Temple",
            "AI Collective",
            "Orbital Chapter",
            "Relay Cartel",
            "Trade Assembly",
            "Quantum Union",
            "Terraform Bureau",
            "Signal Corps",
            "Drift Network",
            "Cryo Division",
            "Echo Fleet",
            "Archive Node",
            "Security Cluster",
            "Mining Authority",
          ],
          factionsN2: [
            "of",
            "for",
            "operating in",
            "under",
            "over",
            "near",
            "within",
            "against",
            "aligned with",
            "based in",
          ],
          roles: [
            "Surveyors",
            "Archivists",
            "Salvagers",
            "Datawrights",
            "Terraformers",
            "Smugglers",
            "Peacekeepers",
            "Prospectors",
            "Hackers",
            "Vigil AIs",
            "Skyfarers",
            "Signalers",
            "Cryotechs",
            "Synthbinders",
          ],
          motives: [
            "activating",
            "decrypting",
            "hacking",
            "monitoring",
            "rebooting",
          ],
          motiveGlue: [
            "the only remaining",
            "a",
            "an old",
            "a sealed",
            "a forgotten",
            "a derelict",
            "a hidden",
            "an encrypted",
          ],
          relicAdjectives: [
            "encrypted",
            "forgotten",
            "sealed",
            "quantum",
            "bio-locked",
            "holographic",
            "corrupted",
            "archived",
          ],
          relicNouns: [
            "core",
            "drive",
            "node",
            "key",
            "vault",
            "chip",
            "beacon",
            "archive",
            "relay",
            "protocol",
          ],
          pois: [
            "orbital spine",
            "seed vault",
            "phase-burned crater",
            "maglev trench",
            "signal relay",
            "data vault",
            "drift station",
          ],
          weather: [
            "static rain",
            "an ion flash",
            "dust drift",
            "signal interference",
            "electrical haze",
            "solar flare scatter",
          ],
          hooks: [
            "a ghost ping repeats each dusk",
            "a vault opens for the first time",
            "a comms blackout spreads",
            "a relay node reboots unexpectedly",
            "a drone fails to report",
            "a beacon activates without command",
          ],
          hookMods: [
            "near the <poi>",
            "inside the <poi>",
            "amid <weather>",
            "under <weather> skies",
          ],
          hookConsequences: [
            "<faction> claims salvage rights on the <poi>",
            "a quarantine ring is raised around the <poi>",
            "the drift station issues a muster call",
            "<npc> is dispatched to secure the <poi>",
            "trade codes for the <poi> are revoked",
            "a signal bounty is posted across the system",
            "the relay grid throttles all traffic",
            "crew shifts double along the <poi>",
          ],
        },

        apocalypse: {
          biome: [
            {
              name: "ruined city",
              moistureRange: [3, 6],
              tempRange: [4, 6],
              features: {
                ruins: 0.9,
                "river-water": 0.25,
                lake: 0.15,
                ridge: 0.2,
                mycelium: 0.2,
              },
            },
            {
              name: "wasteland",
              moistureRange: [1, 3],
              tempRange: [6, 8],
              features: {
                ruins: 0.4,
                ridge: 0.4,
                mountain: 0.3,
                "river-lava": 0.15,
                dunes: 0.25,
                "watering hole": 0.1,
                "dead trees": 0.4,
              },
            },
            {
              name: "overgrowth",
              moistureRange: [6, 8],
              tempRange: [4, 6],
              features: {
                "river-water": 0.5,
                lake: 0.3,
                ruins: 0.35,
                mycelium: 0.5,
                lagoon: 0.2,
              },
            },
            {
              name: "floodplain",
              moistureRange: [6, 8],
              tempRange: [4, 6],
              features: {
                "river-water": 0.75,
                lake: 0.5,
                lagoon: 0.35,
                ruins: 0.2,
                reef: 0.1,
              },
            },
            {
              name: "ash desert",
              moistureRange: [1, 2],
              tempRange: [7, 8],
              features: {
                dunes: 0.7,
                "river-lava": 0.35,
                ridge: 0.3,
                ruins: 0.25,
                oasis: 0.15,
                "watering hole": 0.2,
                "dead trees": 0.3,
              },
            },
            {
              name: "irradiated zone",
              moistureRange: [2, 5],
              tempRange: [5, 7],
              features: {
                ruins: 0.4,
                ridge: 0.3,
                "river-lava": 0.2,
                lake: 0.2,
                mycelium: 0.25,
              },
            },
            {
              name: "salt flats",
              moistureRange: [1, 2],
              tempRange: [6, 8],
              features: {
                lake: 0.25,
                dunes: 0.4,
                ridge: 0.3,
                "river-water": 0.15,
                ruins: 0.2,
                oasis: 0.1,
              },
            },
            {
              name: "scrapyard dunes",
              moistureRange: [1, 2],
              tempRange: [7, 8],
              features: {
                dunes: 0.8,
                ruins: 0.5,
                ridge: 0.3,
                "river-lava": 0.2,
                "watering hole": 0.1,
                "dead trees": 0.25,
              },
            },
            {
              name: "bunker valley",
              moistureRange: [3, 5],
              tempRange: [3, 5],
              features: {
                mountain: 0.4,
                ridge: 0.5,
                "river-water": 0.25,
                lake: 0.2,
                ruins: 0.35,
              },
            },
            {
              name: "shattered highlands",
              moistureRange: [2, 5],
              tempRange: [3, 6],
              features: {
                mountain: 0.7,
                ridge: 0.7,
                "river-lava": 0.25,
                ruins: 0.25,
                lake: 0.15,
                "dead trees": 0.25,
                crystals: 0.3,
              },
            },
            {
              name: "canal maze",
              moistureRange: [7, 8],
              tempRange: [4, 6],
              features: {
                "river-water": 0.8,
                lagoon: 0.6,
                lake: 0.4,
                ruins: 0.3,
                reef: 0.1,
              },
            },
          ],
          factionsN1: [
            "Remnants",
            "Road Kings",
            "Canal Commune",
            "Vault Kin",
            "Scrap Choir",
            "Spore Ward",
            "Signal House",
          ],
          factionsN2: [
            "of",
            "at",
            "over",
            "under",
            "through",
            "against",
            "within",
            "near",
            "beyond",
            "inside",
            "along",
            "beneath",
          ],
          roles: [
            "Scavvers",
            "Archivists",
            "Pickers",
            "Claimants",
            "Watchers",
            "Riggers",
            "Spanners",
            "Guides",
            "Slingers",
          ],
          motives: ["claiming", "fighting", "hoarding", "towing", "trading"],
          motiveGlue: [
            "the only remaining",
            "a",
            "an old",
            "a sealed",
            "a flooded",
            "a broken",
            "a buried",
            "a rusted",
            "a forgotten",
          ],
          relicAdjectives: [
            "sealed",
            "rusted",
            "burned",
            "coded",
            "scrapped",
            "buried",
            "cracked",
            "patched",
            "irradiated",
            "forgotten",
          ],
          relicNouns: [
            "vault",
            "badge",
            "drive",
            "mask",
            "chip",
            "tag",
            "key",
            "module",
            "canister",
            "token",
            "seal",
            "crate",
          ],
          pois: [
            "interchange",
            "metro mouth",
            "signal tower",
            "mall",
            "canal gate",
            "salt pit",
            "water plant",
          ],
          weather: [
            "static rain",
            "polluted snow",
            "heat shimmer",
            "metallic drizzle",
            "smoke squalls",
            "acid mist",
            "radio interference",
          ],
          hooks: [
            "a treaty flag burns",
            "a convoy goes missing",
            "a bunker door opens on its own",
            "a warning light blinks without power",
            "a flare goes up with no claim",
          ],
          hookMods: [
            "near the <poi>",
            "inside the <poi>",
            "amid <weather>",
            "under <weather> skies",
          ],
          hookConsequences: [
            "<faction> claims the <poi> as protected ground",
            "a scavenger gang marks the <poi> as taboo",
            "the signal tower posts a bounty",
            "<npc> goes missing while investigating",
            "trade routes detour around the <poi>",
            "a curfew is declared near the <poi>",
            "water rations are cut at the <poi>",
            "a warning fire burns all night",
          ],
        },
      };
      const fieldMotiveVerbs = [
        "guarding",
        "defending",
        "protecting",
        "restoring",
        "sealing",
        "unsealing",
        "mining",
        "harvesting",
        "excavating",
        "mapping",
        "exploring",
        "tracking",
        "studying",
        "scanning",
        "salvaging",
        "charting",
        "reclaiming",
        "repairing",
        "constructing",
        "investigating",
        "surveying",
        "patrolling",
      ];
      const npcTasks = {
        faction: [
          "recruiting new members for a difficult assignment",
          "screening applicants after a recent breach",
          "guarding a cache of supplies near <poi>",
          "guarding a sealed storehouse whose lock has begun to fail",
          "escorting a courier between safehouses",
          "escorting a dignitary through contested ground",
          "training new initiates in {protocol|discipline}",
          "drilling a response team for an expected incursion",
          "auditing {relics|records|inventories} for discrepancies",
          "investigating forged credentials circulating among allies",
          "negotiating a fragile truce over access to <poi>",
          "enforcing a disputed boundary marker near <poi>",
          "recovering a stolen insignia tied to {leadership|authority}",
          "hunting an infiltrator who knows internal routes",
          "coordinating a joint operation with an uneasy partner",
          "planning a raid or recovery mission timed with <weather>",
          "intercepting contraband moving through the biome",
          "protecting a witness scheduled to testify at a council",
          "relocating a vulnerable cell before the next crackdown",
          "disabling a rival outpost overlooking <poi>",
          "repairing a failing {ward|gate|lock|access point}",
          "attempting to reactivate a dormant asset at <poi>",
          "silencing rumors that could fracture the ranks",
          "delivering an ultimatum to a rival faction",
          "hosting a tribunal for a member accused of betrayal",
          "tracking a missing squad last seen near <poi>",
          "securing a route for a coming convoy",
          "mapping contacts and loyalties inside a contested district",
          "recovering a lost map that details hidden approaches",
          "testing a {prototype tool|ritual} under field conditions",
          "containing an outbreak of panic after <weather>",
          "negotiating trade rights in exchange for protection",
          "redistributing rations after an unexpected shortage",
          "guarding a prisoner transfer through hostile ground",
          "searching for a specialist needed to stabilize <poi>",
          "tending a wounded leader while rivals circle",
          "covering up a mistake before it becomes public",
          "investigating a sabotage incident in the faction's stores",
          "retrieving a message that must not be read by outsiders",
          "{binding|sealing|securing} a dangerous discovery at <poi>",
          "monitoring a repeating {signal|omen} tied to <poi>",
          "setting a trap for a rival team operating near <poi>",
          "running security for a clandestine meeting during <weather>",
          "conducting a census of members and dependents",
          "escorting a defector who wants asylum",
          "protecting a critical shipment during <weather>",
          "investigating why a long-trusted contact went silent",
          "clearing a safehouse compromised by an unknown contaminant",
        ],

        settlement: [
          "repairing the waterworks after <weather>",
          "patching leaks and reinforcing cisterns ahead of <weather>",
          "restoring {power|heat|light} to a key block of homes",
          "fixing a jammed {gate|lift|lock|access mechanism} at <poi>",
          "tracking a series of thefts that target essentials",
          "investigating a break-in at a storeroom near <poi>",
          "organizing a trade caravan and negotiating safe passage",
          "preparing a ration exchange with an unreliable partner",
          "hosting a tense council meeting about <poi>",
          "mediating a feud that threatens to split the community",
          "surveying new housing sites away from known hazards",
          "mapping structural risks in older {tunnels|buildings}",
          "investigating a strange illness spreading after <weather>",
          "quarantining a block and tracing the source to <poi>",
          "clearing rubble to reopen a route to <poi>",
          "reinforcing defenses after a warning sign at <poi>",
          "training volunteers for watch duty and emergency response",
          "rescuing trapped workers during <weather>",
          "finding a replacement {part|resource} the settlement can't do without",
          "recovering a lost tool kit critical to maintenance",
          "auditing stores because supplies don't match the ledgers",
          "running a controlled {burn|purge|cleanup} of a contaminated zone",
          "investigating a suspicious fire that started too cleanly",
          "negotiating a marriage {pact|adoption|sponsorship} to secure alliances",
          "settling a land claim dispute over the edge of the biome",
          "evacuating families after a new hazard appears near <poi>",
          "escorting a visiting envoy through nervous streets",
          "hosting a ceremony that must not be interrupted",
          "burying the dead and appeasing the living after a tragedy",
          "repairing communications lines after <weather>",
          "tracking why patrols keep missing check-ins near <poi>",
          "building a new market route that avoids a dangerous stretch",
          "shoring up walls and walkways before the next <weather>",
          "investigating counterfeit {tokens|ration chits|permits} circulating locally",
          "hunting down a black-market supplier poisoning the town",
          "organizing a salvage lottery that's turning violent",
          "recovering a {child|elder} who wandered toward <poi>",
          "escorting {healers|engineers} to a worksite near <poi>",
          "replacing leadership after a sudden resignation",
          "investigating a ghost story that's driving people away from <poi>",
          "securing a festival with rising tensions and hidden weapons",
          "disarming a booby trap found in a common thoroughfare",
          "patching a collapsed {tunnel|bridge} caused by <weather>",
          "moving the seed {stores|archives|reliquary} to a safer vault",
          "interviewing newcomers whose story doesn't add up",
          "negotiating protection payments under threat",
          "tracking a predator that hunts livestock near <poi>",
          "testing a new {well|route} that may be {cursed|unsafe|unstable}",
          "restoring the local map after someone altered it",
        ],

        world: [
          "mapping an new trail that skirts <poi>",
          "charting safe routes as <weather> builds",
          "guiding travelers through hostile ground to <poi>",
          "escorting {pilgrims|refugees|traders} across the biome",
          "hunting a dangerous creature seen near <poi>",
          "tracking something that leaves no prints after <weather>",
          "recovering a lost expedition last seen near <poi>",
          "searching for a missing scout who vanished during <weather>",
          "salvaging a ruined site for usable parts and supplies",
          "extracting valuable material from a hazardous zone near <poi>",
          "scouting a rival camp positioned near <poi>",
          "observing an encroaching force without being detected",
          "securing a crossing after the terrain shifts near <poi>",
          "repairing a broken {bridge|lift|passageway} at <poi>",
          "investigating why an old marker no longer matches the land",
          "following a repeating {signal|omen} that points toward <poi>",
          "{closing|sealing|stabilizing} a breach at <poi>",
          "unsealing a site at <poi> under strict precautions",
          "retrieving a {relic|container|data-cache} rumored to be in <poi>",
          "delivering a message through a zone nobody wants to cross",
          "recovering a downed {cart|sled|rig} stranded by <weather>",
          "clearing a path through {overgrowth|rubble|drifted dunes} near <poi>",
          "setting up a remote observation post overlooking <poi>",
          "testing whether the {water|air|soil} is safe beyond the ridge",
          "tracking a {poacher|scavenger crew} operating near <poi>",
          "negotiating {passage|terms} with a territorial group beyond the border",
          "discovering why local the {wildlife|fauna|tribe} avoids <poi>",
          "finding the source of strange {lights|sounds} near <poi>",
          "recovering supplies dropped during a retreat",
          "investigating an abandoned camp where everything was left behind",
          "locating a hidden {cache|<item>} mapped only in partial coordinates",
          "escorting a specialist needed to handle <poi>",
          "running a diversion to pull attention away from <poi>",
          "delivering {emergency medicine|supplies|equipment} to an isolated outpost",
          "surveying terrain for a future {settlement site|outpost|relay station}",
          "finding fresh water in a parched stretch of the biome",
          "tracking the movement of a storm front that behaves oddly",
          "recovering a stolen map and identifying who copied it",
          "investigating a boundary marker that was moved overnight",
          "following a trail of messages {carved|encoded} along the route",
          "retrieving proof of a rival's wrongdoing from <poi>",
          "rescuing captives taken toward <poi>",
          "destroying a hazard source without triggering worse consequences",
          "confirming whether <poi> is truly empty or merely silent",
          "bringing back a {sample|artifact} from <poi> without contamination",
          "finding a safer detour after <weather> made the main route impassable",
          "tracking a caravan that never arrived from the direction of <poi>",
          "retrieving a lost {heirloom|<item>} that may start a war if mishandled",
          "investigating a new {sinkhole|collapse} revealed after <weather>",
        ],
      };

      // #endregion Theme Tables
      // #region Tileset + Glyphs
      /* ====================== Tileset ========================================== */
      const tileset = {
        water: { depthGlyphs: { 1: ["~", "âˆ¾", "Ëœ", "âˆ¿", "Ë·"], 2: "â‰ˆ", 3: "â‰‹" } },
        lava: { depthGlyphs: { 1: ["~", "âˆ¾", "Ëœ", "âˆ¿"], 2: "â‰ˆ", 3: "â‰‹" } },
        plains: ["Â·", "â€§", "âˆ™"],
        stone: ["Â·", "â€§", "âˆ™"],
        beach: ["Â·", "â€§", "âˆ™"],
        grass: ["áµž", "Ë¯", "Ë¬", "Ë‡", "â€¦", "âµˆ", '"', "'"],
        forest: {
          base: ["â¯­", "ð™˜", "â†‘", "âƒ", "ðŒ’", "á»Œ", "ð™¢", "ðŠ¾", "â†Ÿ"],
          coniferous: ["âƒ", "ð™¢", "ðŠ¾","ð™¢"],
          dead: ["ð™˜", "â†‘", "â†Ÿ"],
          deciduous: ["ðŒ’", "á»Œ", "ð™±", "ð™²"],
        },
        desert: ["â‰ˆ"],
        mycelium: ["áµ ", "âµˆ", "Â·", "â€§", "âˆ™"],
        mountain: {
          base: ["^"],
          height: { 1: "ê˜", 2: "á¨ˆ", 3: "á´§", 4: "Î›", 5: "Î”" },
        },
        settlement: ["â›©", "âŒ‚", "ð˜®", "ð™", "ð›…", "ð›˜", "ð¡", "ð€", "ð", "ð‚§", "ðƒ€", "ðœ£"],
        ruins: [
          "âŒ‚",
          // TODO: use linear B block to add more ruined buildings and not have crossover with settlement variants: https://unicodeplus.com/block/10000
          "ð˜®",
          "ð™",
          "ð›…",
          "ð›˜",
          "ð¡",
          "ð€",
          "ð",
          "ð‚§",
          "ðƒ€",
        ],
        camp: [
          // TODO: use linear B block to add better tents and camps: https://unicodeplus.com/block/10000
          "á—‘",
          "á°",
          "á„",
        ],
        poi: ["ð€€", "ð€‡", "ð€’", "ð€š", "ð€›", "ð€£", "ð€µ", "ð˜„", "ð˜‡", "ð˜™", "ð˜", "ð˜¤", "ð", "ð•"],
        religious: {
          death: [
            "âš±",
            "âš°",
            "ðš¬",
            "ðš­",
            "ðŸª¦",
            "ðš®",
            "ðš¯",
            "ðŸº",
            // "âš±ï¸",
            // "âœ",
            // "âœž",
            // "âœŸ",
          ],
          monastery: [
            "â›¨",
            "â›§",
            "â˜ª",
            "âšš",
            "ðœ¨",
            // "âš•ï¸",
            "ðŸµ",
            // "ðŸ•¯ï¸",
            // "âœ ",
            // "â˜¯",
          ],
        },
        road: {
          glyphs: {
            nsew: "â•¬",
            nsw: "â•£",
            nse: "â• ",
            nwe: "â•©",
            swe: "â•¦",
            ns: "â•‘",
            we: "â•",
            ne: "â•š",
            nw: "â•",
            se: "â•”",
            sw: "â•—",
            n: "â•‘",
            s: "â•‘",
            w: "â•",
            e: "â•",
          },
        },
        crystal: ["Ð¶", "â©•", "ê˜", "X"],
      };

      function baseGlyphs(def) {
        if (!def) return null;
        if (Array.isArray(def)) return def;
        if (Array.isArray(def.base)) return def.base;
        if (typeof def.base === "string") return [def.base];
        return null;
      }

      function firstBaseGlyph(def, fallback = "?") {
        const base = baseGlyphs(def);
        return (base && base[0]) || fallback;
      }

      tileset["fungal-settlement"] = baseGlyphs(tileset.settlement);
      tileset["fungal-ruins"] = baseGlyphs(tileset.ruins);
      tileset["overgrown-ruins"] = baseGlyphs(tileset.ruins);

      const TILE_SET = new Set(Object.keys(tileset));

      function validateTileset(tilesetDef) {
        if (!DEBUG) return;
        for (const key of TILE_SET) {
          const def = tilesetDef[key];
          if (!def) {
            debugWarn(`Missing tileset entry for "${key}"`);
            continue;
          }
          if (key === "water" || key === "lava") {
            if (!def.depthGlyphs) {
              debugWarn(`Tileset "${key}" missing depthGlyphs`);
              continue;
            }
            for (const depth of [1, 2, 3]) {
              if (!def.depthGlyphs[depth])
                debugWarn(`Tileset "${key}" missing depthGlyphs[${depth}]`);
            }
            continue;
          }
          if (key === "mountain") {
            if (!def.height) {
              debugWarn(`Tileset "mountain" missing height map`);
              continue;
            }
            for (const h of [1, 2, 3, 4, 5]) {
              if (!def.height[h])
                debugWarn(`Tileset "mountain" missing height[${h}]`);
            }
            continue;
          }
          if (key === "religious") {
            if (!def.death || !def.monastery)
              debugWarn(
                `Tileset "religious" missing glyphs for death/monastery`,
              );
            continue;
          }
          if (key === "road") {
            if (!def.glyphs)
              debugWarn(`Tileset "road" missing glyphs`);
            continue;
          }
          if (!baseGlyphs(def)?.length)
            debugWarn(`Tileset "${key}" missing base glyphs`);
        }
      }

      validateTileset(tileset);

      // #endregion Tileset + Glyphs
      // #region Lexicon Data
      const syllablePool = [
        "aer",
        "al",
        "an",
        "ath",
        "bah",
        "bel",
        "bit",
        "bat",
        "bra",
        "brie",
        "bur",
        "by",
        "cal",
        "col",
        "da",
        "dei",
        "dra",
        "dul",
        "el",
        "fen",
        "fie",
        "fun",
        "fus",
        "gal",
        "gol",
        "grah",
        "gre",
        "grie",
        "hak",
        "hal",
        "hel",
        "hur",
        "ian",
        "il",
        "ins",
        "ion",
        "ios",
        "ir",
        "is",
        "ith",
        "je",
        "jan",
        "jha",
        "jor",
        "ka",
        "kra",
        "kar",
        "kel",
        "kha",
        "kor",
        "lai",
        "lan",
        "lem",
        "len",
        "lha",
        "lon",
        "lor",
        "mal",
        "mar",
        "mel",
        "mes",
        "mor",
        "mor",
        "mun",
        "myr",
        "nal",
        "nel",
        "nera",
        "nir",
        "nor",
        "oa",
        "oar",
        "or",
        "ora",
        "os",
        "oth",
        "pha",
        "pil",
        "pis",
        "pol",
        "pra",
        "pul",
        "pyr",
        "qar",
        "qua",
        "rah",
        "reo",
        "ri",
        "ros",
        "ryn",
        "sat",
        "ser",
        "sus",
        "set",
        "sha",
        "sta",
        "tai",
        "ter",
        "thal",
        "thar",
        "ti",
        "tie",
        "to",
        "tor",
        "tra",
        "tua",
        "tur",
        "toa",
        "ume",
        "una",
        "ur",
        "uth",
        "vak",
        "vek",
        "vor",
        "yal",
        "zal",
        "zan",
        "zek",
        "zir",
        "zul",
        "zuth",
      ];
      const namePostfixes = [
        " Hold",
        " Castle",
        " Reach",
        " Fall",
        " Falls",
        " Gate",
        " Prime",
        " Camp",
        " Cliffs",
        " Fold",
        " Crown",
        " Wilds",
        " Hollow",
        " Vale",
        " Peaks",
        " Grove",
        " Keep",
        " Commune",
        " Verge",
        " Wastes",
        " Spire",
        " Fields",
        " Flats",
        " Basin",
        " Spine",
        " Fault",
        " Deep",
        " Steppe",
        " Maw",
        " Province",
      ];
      const settlementTypes = {
        base: [
          "hamlet",
          "village",
          "farmstead",
          "ranch",
          "outpost",
          "fortified village",
          "manor",
          "keep",
          "stronghold",
          "castle",
          "city-state",
          "military base",
          "lodge",
          "suburbs",
          "campus",
          "complex",
          "farm",
          "settlement",
          "fort",
          "borough",
          "town",
          "city",
          "capital",
          "stronghold",
          "citadel",
          "bastion",
          "garrison",
          "enclave",
          "outpost",
          "fortress",
          "metropolis",
          "megacity",
        ],
        nearWater: [
          "port",
          "harbor",
          "docktown",
          "fishing village",
          "river town",
          "canal city",
          "delta town",
          "lakeside town",
          "wharf",
        ],
        nearMountain: [
          "mining town",
          "mountain hold",
          "cliffside village",
          "ridgefort",
          "highpass outpost",
          "quarry town",
          "peakstead",
        ],
        nearPaths: [
          "waystation",
          "roadhouse",
          "trade hub",
          "trading post",
          "exchange",
          "merchant quarter",
          "market town",
          "trading post",
          "trade hub",
          "rest stop",
          "crossroads",
        ],
      };
      const factionNameTemplates = [
        {
          name: "Title+Lineage",
          weight: 12,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.titles)} ${rngUtil.oneOf(r, L.lineages)}`,
        },
        {
          name: "Title+Toponym",
          weight: 6,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.titles)} ${rngUtil.oneOf(r, L.toponyms)}`,
        },
        {
          name: "The+Collective+of+Role",
          weight: 16,
          build: (r, L) =>
            `The ${rngUtil.oneOf(r, L.collectives)} ${rngUtil.oneOf(r, L.prepsOf)} ${rngUtil.oneOf(r, L.roles)}`,
        },
        {
          name: "Role+of+Toponym",
          weight: 14,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.roles)} ${rngUtil.oneOf(r, L.prepsOf)} ${rngUtil.oneOf(r, L.toponyms)}`,
        },
        {
          name: "The+Collective+of+Toponym",
          weight: 12,
          build: (r, L) =>
            `The ${rngUtil.oneOf(r, L.collectives)} ${rngUtil.oneOf(r, L.prepsOf)} ${rngUtil.oneOf(r, L.toponyms)}`,
        },
        {
          name: "Abstract+of+Region",
          weight: 10,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.abstracts)} ${rngUtil.oneOf(r, L.prepsOf)} ${rngUtil.oneOf(r, L.regions)}`,
        },
        {
          name: "Toponym+Company",
          weight: 8,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.toponyms)} ${rngUtil.oneOf(r, L.tradeBodies)}`,
        },
        {
          name: "The+Nickname",
          weight: 7,
          build: (r, L) => `The ${rngUtil.oneOf(r, L.nicknames)}`,
        },
        {
          name: "Hybrid",
          weight: 9,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.titles)} ${rngUtil.oneOf(r, L.lineages)} ${rngUtil.oneOf(r, L.prepsOf)} ${rngUtil.oneOf(r, L.toponyms)}`,
        },
        {
          name: "Role+Preposition+Site",
          weight: 6,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.roles)} ${rngUtil.oneOf(r, L.prepsSite)} ${rngUtil.oneOf(r, L.sites)}`,
        },
      ];

      /* ====================== Faction naming (fixed deterministic lexicon) ====================== */
      const defaultCollectives = [
        "Order",
        "Guild",
        "Clan",
        "Court",
        "Circle",
        "Syndicate",
        "Chapter",
        "Coven",
        "Brotherhood",
        "Company",
        "League",
        "Consulate",
        "Caravan",
        "Enclave",
        "Assembly",
        "Dominion",
        "Conclave",
        "Pact",
        "Sect",
        "Keep",
        "Banner",
        "Kin",
        "House",
        "Hollow",
        "Sanctum",
        "Forge",
        "Crusade",
        "March",
        "Host",
      ];
      const defaultRoles = [
        "Wardens",
        "Archivists",
        "Bonepickers",
        "Skyfarers",
        "Prospectors",
        "Scribes",
        "Wayfinders",
        "Stormcallers",
        "Reclaimers",
        "Oathkeepers",
        "Lamplighters",
        "Seers",
        "Witchbinders",
        "Lorehunters",
        "Pathmakers",
        "Gravetenders",
        "Runesmiths",
        "Beastwalkers",
        "Spellweavers",
        "Hearthguard",
        "Frostborn",
        "Flamebearers",
        "Thornwatch",
        "Miststriders",
      ];
      const lineageRoots = [
        "Var",
        "Tor",
        "Ash",
        "Hale",
        "Brenn",
        "Keth",
        "Mor",
        "Vale",
        "Dun",
        "Rav",
        "Fen",
        "Grey",
        "Orv",
        "Nyx",
        "Cal",
        "Zan",
        "Luth",
        "Syl",
        "Drak",
        "Ael",
        "Jor",
        "Kor",
        "Lyr",
        "Vel",
        "Xan",
      ];
      const lineageSuffixes = [
        "yn",
        "ell",
        "ath",
        "ek",
        "ar",
        "os",
        "en",
        "ard",
        "ir",
        "an",
        "oth",
        "ic",
        "as",
        "is",
        "or",
        "ul",
        "em",
        "irn",
        "ur",
        "il",
        "eus",
        "ias",
      ];
      const toponymRoots = [
        "Ash",
        "Red",
        "Thorn",
        "Hollow",
        "River",
        "Stone",
        "Mist",
        "Oak",
        "Wolf",
        "Raven",
        "Sun",
        "Star",
        "Ember",
        "Frost",
        "Gold",
        "Mire",
        "Holt",
        "Rev",
        "Shale",
        "Writ",
        "Wind",
      ];
      const toponymSuffixes = [
        "mere",
        "holt",
        "gate",
        "brig",
        "brook",
        "field",
        "wood",
        "veld",
        "keep",
        "bridge",
        "ward",
        "reach",
        "shire",
        "watch",
        "march",
        "moor",
        "ford",
        "fell",
        "crest",
        "vale",
        "dell",
        "dale",
        "fen",
        "scythe",
        "glen",
        "ryn",
      ];
      const regionQualifiers = [
        "Low",
        "Upper",
        "High",
        "Outer",
        "Far",
        "Near",
        "Old",
        "New",
        "North",
        "South",
        "East",
        "West",
        "Great",
        "Little",
        "Deep",
        "Bright",
        "Dark",
        "Cold",
        "Windy",
        "Silent",
      ];
      const regionPlurals = [
        "Marches",
        "Hills",
        "Moors",
        "Flats",
        "Wastes",
        "Reaches",
        "Wards",
        "Downs",
        "Heaths",
        "Fells",
        "Glades",
        "Steppes",
        "Shires",
        "Dales",
        "Crests",
        "Vales",
        "Bogs",
        "Swamps",
        "Wilds",
        "Bluffs",
      ];
      const nicknameColors = [
        "Black",
        "Red",
        "Grey",
        "White",
        "Gold",
        "Green",
        "Blue",
        "Silver",
        "White",
        "Ash",
        "Umber",
        "Sable",
        "Crimson",
        "Azure",
        "Silver",
        "Bronze",
        "Ivory",
        "Onyx",
        "Jade",
        "Copper",
        "Scarlet",
        "Vermilion",
        "Cobalt",
        "Emerald",
        "Ruby",
        "Obsidian",
        "Topaz",
      ];
      const nicknameThings = [
        "Thorn",
        "Hand",
        "Lantern",
        "Crow",
        "Hound",
        "Spear",
        "Moth",
        "Mason",
        "Key",
        "Hammer",
        "Watch",
        "Blade",
        "Wolf",
        "Fox",
        "Raven",
        "Bear",
        "Stag",
        "Serpent",
        "Shield",
        "Arrow",
        "Flame",
        "Fang",
        "Briar",
        "Star",
        "Stone",
        "Branch",
        "Root",
      ];
      const prepsOf = [
        "of",
        "of the",
        "from",
        "from the",
        "in",
        "in the",
        "for",
        "for the",
      ];
      const prepsSite = [
        "at",
        "under",
        "within",
        "beside",
        "along",
        "near",
        "by",
        "beyond",
        "above",
        "below",
      ];
      const abstractTerms = [
        "Pact",
        "Dominion",
        "March",
        "Compact",
        "Confederacy",
        "Concord",
        "Mandate",
        "League",
        "Charter",
        "Accord",
        "Covenant",
        "Unity",
        "Alliance",
        "Fellowship",
        "Union",
      ];
      const tradeBodies = [
        "Company",
        "Charter",
        "Shipping",
        "Freight",
        "Exchange",
        "Syndicate",
        "Cartage",
        "Caravan",
        "Consortium",
        "Traders",
        "Merchants",
        "Outfit",
      ];
      const titleWords = [
        "House",
        "Clan",
        "Order",
        "Circle",
        "Court",
        "Conclave",
        "Banner",
        "Keep",
        "Forge",
        "Sanctum",
        "Host",
        "Enclave",
        "Dominion",
        "Assembly",
        "Coven",
        "Brotherhood",
        "Guild",
        "Sect",
        "Kin",
        "Company",
      ];
      const siteBases = [
        "Gate",
        "Bridge",
        "Wayhouse",
        "Watch",
        "Spire",
        "Hollow",
        "Vault",
        "Crossing",
        "Ford",
        "Hall",
        "Tower",
        "Works",
        "Outpost",
        "Station",
        "Relay",
        "Point",
        "Post",
        "Hold",
        "Camp",
        "Fort",
      ];
      const deathMarkers = [
        "ossuary",
        "cairn",
        "vault",
        "necropolis",
        "catacombs",
        "burial ground",
        "funerary mound",
        "memorial",
        "tomb",
        "crypt",
        "graveyard",
        "sepulchre",
        "cemetery",
        "mausoleum",
        "crematorium",
        "monument",
      ];
      const monasteryMarkers = [
        "Shrine",
        "Synagogue",
        "Pagoda",
        "Zendo",
        "Monastery",
        "Abbey",
        "Hermitage",
        "Sacred Grove",
        "Sacred Spring",
        "Temple",
        "Chapel",
        "Sanctum",
        "Sanctuary",
        "Stone Circle",
        "Oratory",
        "Cloister",
        "Mission",
        "Convent",
        "Cathedral",
        "Basilica",
        "Grotto",
      ];
      const deathGroups = [
        "mourners",
        "undertakers",
        "gravediggers",
        "deathwatch",
        "ossuary wardens",
        "memorialists",
        "grievers",
        "kin",
        "bereaved",
        "lamenters",
      ];
      const religiousGroups = [
        "devout",
        "ascetics",
        "clergy",
        "monks",
        "priests",
        "hermits",
        "pilgrims",
        "zealots",
        "brothers",
        "sisters",
        "cultists",
        "missionaries",
        "nuns",
        "friars",
        "elders",
        "druids",
        "seekers",
        "wayfarers",
        "penitents",
        "acolytes",
        "undertakers",
        "mediums",
        "shamans",
        "oracles",
        "prophets",
        "necromancers",
      ];
      const poiStructureKeywords = [
        "abbey",
        "bunker",
        "cathedral",
        "chapel",
        "citadel",
        "dock",
        "forge",
        "fort",
        "gate",
        "hall",
        "keep",
        "mall",
        "metro",
        "monastery",
        "outpost",
        "plant",
        "port",
        "relay",
        "sanctum",
        "settlement",
        "shrine",
        "signal",
        "spine",
        "spire",
        "station",
        "tower",
        "temple",
        "vault",
        "wayhouse",
      ];

      const biomeFeaturesByName = (() => {
        const out = {};
        for (const tt of Object.values(themes)) {
          const biomes = tt?.biome || [];
          for (const biome of biomes) {
            if (!biome) continue;
            if (typeof biome === "object") {
              const name = String(
                "name" in biome ? (biome.name ?? "") : biome,
              ).toLowerCase();
              if (name && !out[name])
                out[name] =
                  biome.features && typeof biome.features === "object"
                    ? biome.features
                    : {};
            } else if (typeof biome === "string") {
              const name = biome.toLowerCase();
              if (!out[name]) out[name] = {};
            }
          }
        }
        return out;
      })();

      /* ====================== Core Utilities ====================== */
      function resolveInlineOptions(s, r) {
        if (typeof s !== "string") return s;
        const rand = typeof r === "function" ? r : Math.random;
        return s.replace(/\{([^{}]+)\}/g, (_, body) => {
          const parts = body
            .split("|")
            .map((p) => p.trim())
            .filter((p) => p.length);
          if (!parts.length) return "";
          return parts[(rand() * parts.length) | 0];
        });
      }

      function ensure(arr, fallback) {
        return Array.isArray(arr) && arr.length ? arr : fallback;
      }

      function uniqN(n, fn) {
        const out = new Set();
        let guard = 0;
        while (out.size < n && guard++ < n * 20) out.add(fn());
        return Array.from(out);
      }

      function cartesian(a, b) {
        const out = [];
        for (let i = 0; i < a.length; i++)
          for (let j = 0; j < b.length; j++) out.push([a[i], b[j]]);
        return out;
      }

      function escAttr(s) {
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/"/g, "&quot;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function escHtml(s) {
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function escRe(s) {
        return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      function xref(cell, label) {
        return `<span class="xref" data-cell="${escAttr(cell)}">${escHtml(label)}</span>`;
      }

      function linkifyRefs(text, refs) {
        let out = escHtml(text);
        if (!Array.isArray(refs) || !refs.length) return out;
        const ordered = refs
          .map((ref) => {
            const name = String(ref?.name ?? "");
            return { ...ref, name, _escName: escHtml(name) };
          })
          .filter((ref) => ref.name.length)
          .sort((a, b) => b.name.length - a.name.length);
        for (const ref of ordered) {
          const re = new RegExp(escRe(ref._escName), "g");
          out = out.replace(re, xref(ref.cell, ref.name));
        }
        return out;
      }

      function pickFromOptions(r, list, fallback) {
        const pick = rngUtil.oneOf(r, list);
        if (Array.isArray(pick)) return rngUtil.oneOf(r, pick) ?? fallback;
        return pick ?? fallback;
      }

      /* ====================== RNG Utilities ====================== */
      // #endregion Lexicon Data
      // #region RNG Utilities
      function h32(s) {
        let h = 5381 >>> 0;
        const str = String(s ?? "");
        for (let i = 0; i < str.length; i++)
          h = ((h * 33) ^ str.charCodeAt(i)) >>> 0;
        return h >>> 0;
      }

      function xs32(seed) {
        let x = seed >>> 0;
        return () => {
          x ^= x << 13;
          x ^= x >>> 17;
          x ^= x << 5;
          return (x >>> 0) / 4294967296;
        };
      }

      function n2(seed, x, y) {
        let v = (seed ^ ((x * 374761393) | 0) ^ ((y * 668265263) | 0)) >>> 0;
        v ^= v >>> 13;
        v = Math.imul(v, 1274126177) >>> 0;
        v ^= v >>> 16;
        return (v >>> 0) / 4294967296;
      }

      function randSeed() {
        const a = new Uint32Array(1);
        if (typeof crypto !== "undefined" && crypto.getRandomValues) {
          crypto.getRandomValues(a);
        } else {
          a[0] = (Math.random() * 4294967296) >>> 0;
        }
        return a[0].toString(36);
      }

      function oneOf(r, src) {
        if (!src) return undefined;
        if (Array.isArray(src)) {
          const picked = src[(r() * src.length) | 0];
          return resolveInlineOptions(picked, r);
        }
        if (typeof src === "object") {
          const keys = Object.keys(src);
          if (!keys.length) return undefined;
          const k = keys[(r() * keys.length) | 0];
          return resolveInlineOptions(src[k], r);
        }
        return resolveInlineOptions(src, r);
      }

      function pickWeighted(r, items) {
        const sum = items.reduce((acc, it) => acc + (it.weight || 1), 0);
        const roll = r() * sum;
        let acc = 0;
        for (const it of items) {
          acc += it.weight || 1;
          if (roll < acc) return it;
        }
        return items[items.length - 1];
      }

      function maybe(rng, chance = 0.5) {
        return typeof rng === "function"
          ? rng() < chance
          : Math.random() < chance;
      }

      function shuffleDet(r, arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = (r() * (i + 1)) | 0;
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      const rngUtil = {
        h32,
        xs32,
        n2,
        randSeed,
        oneOf,
        pickWeighted,
        shuffleDet,
        maybe,
      };

      // #endregion RNG Utilities
      // #region Naming + Lexicon Builders
      /* ====================== Naming + Lexicon ====================== */
      class NameGenerator {
        constructor(
          rng,
          { syllables = syllablePool, postfixes = namePostfixes } = {},
        ) {
          this.r = rng;
          this.syllables = syllables;
          this.postfixes = postfixes;
        }

        baseName({ allowExtraSyllable = true, apostropheChance = 0.1 } = {}) {
          const n = 2 + (allowExtraSyllable && this.r() > 0.7);
          let s = "";
          for (let i = 0; i < n; i++) {
            let syl = this.syllables[(this.r() * this.syllables.length) | 0];
            s += syl;
            
            if (i < n - 1 && maybe(this.r, apostropheChance)) {
              s += "'";
            }
          }
          return s.charAt(0).toUpperCase() + s.slice(1);
        }

        placeName() {
          let s = this.baseName();
          if (this.r() > 0.5)
            s += this.postfixes[(this.r() * this.postfixes.length) | 0];
          return s;
        }

        npcName() {
          return this.baseName();
        }
      }

      class LexiconBuilder {
        constructor(rng, themeTables) {
          this.r = rng;
          this.tt = themeTables;
        }

        buildLineages(r, count = 12) {
          return uniqN(
            count,
            () =>
              lineageRoots[(r() * lineageRoots.length) | 0] +
              lineageSuffixes[(r() * lineageSuffixes.length) | 0],
          );
        }

        buildToponyms(r, count = 20) {
          return uniqN(
            count,
            () =>
              toponymRoots[(r() * toponymRoots.length) | 0] +
              toponymSuffixes[(r() * toponymSuffixes.length) | 0],
          );
        }

        buildRegionsFromToponyms(r, tops, count = 10, regionizer_chance = 0.5) {
          return uniqN(count, () => {
            const top = tops[(r() * tops.length) | 0];
            const addRegionizer = r() < regionizer_chance;
            const addPlural = r() < 0.4;
            const rr = regionQualifiers[(r() * regionQualifiers.length) | 0];
            const prefix = addRegionizer ? rr + " " : "";
            if (addPlural) {
              const p = regionPlurals[(r() * regionPlurals.length) | 0];
              return `${prefix}${top} ${p}`;
            }
            return `${prefix}${top}`;
          });
        }

        buildNicknames(r) {
          return cartesian(nicknameColors, nicknameThings).map(
            ([c, t]) => `${c} ${t}${rngUtil.maybe(r, 0.5) ? "s" : ""}`,
          );
        }

        buildLexicon(tt, r) {
          const roles = ensure(tt.roles, defaultRoles);
          const collectives = ensure(tt.factionsN1, defaultCollectives);

          const lineages = this.buildLineages(r, 12);
          const toponyms = this.buildToponyms(r, 20);
          const regions = this.buildRegionsFromToponyms(r, toponyms, 10);
          const nicknames = this.buildNicknames(r);

          const sites = siteBases.map((s) =>
            rngUtil.maybe(r, 0.5) ? `the ${s}` : s,
          );

          return {
            roles,
            collectives,
            prepsOf,
            prepsSite,
            abstracts: abstractTerms,
            tradeBodies,
            titles: titleWords,
            lineages,
            toponyms,
            regions,
            nicknames,
            sites,
          };
        }
      }

      function factionName(r, theme = "fantasy") {
        const tt = themes[theme] || {};
        const lexicon = new LexiconBuilder(r, tt);
        const L = lexicon.buildLexicon(tt, r);
        const template = rngUtil.pickWeighted(r, factionNameTemplates);
        return template.build(r, L);
      }

      function namedPOI(nameGen, poiType) {
        const r = nameGen.r;
        const style = (r() * 4) | 0;
        const base = nameGen.placeName();
        if (style === 0) return `${base} ${poiType}`;
        if (style === 1) return `The ${poiType} of ${base}`;
        if (style === 2)
          return `${poiType.charAt(0).toUpperCase() + poiType.slice(1)} at ${base}`;
        return `${base}'s ${poiType}`;
      }

      function poiIsStructure(poiType) {
        const s = String(poiType || "").toLowerCase();
        for (const word of poiStructureKeywords) {
          if (s.includes(word)) return true;
        }
        return false;
      }

      // #endregion Naming + Lexicon Builders
      // #region World Builder
      /* ====================== World Placement ====================== */
      class WorldBuilder {
        constructor(mapGen, tileset, themeTables = themes) {
          this.mapGen = mapGen;
          this.tileset = tileset;
          this.themes = themeTables;
        }

        pickTempTier(r, tempTable, biome) {
          const temp = tempTable;
          const range = biome?.tempRange;
          let tierFromRange = null;
          if (Array.isArray(range) && range.length >= 2) {
            const lo = Number(range[0]);
            const hi = Number(range[1]);
            if (Number.isFinite(lo) && Number.isFinite(hi)) {
              const min = clamp(Math.min(lo, hi), 1, 8);
              const max = clamp(Math.max(lo, hi), 1, 8);
              tierFromRange = min + Math.floor(r() * (max - min + 1));
            }
          } else if (range && typeof range === "object") {
            const lo = Number(range.min);
            const hi = Number(range.max);
            if (Number.isFinite(lo) && Number.isFinite(hi)) {
              const min = clamp(Math.min(lo, hi), 1, 8);
              const max = clamp(Math.max(lo, hi), 1, 8);
              tierFromRange = min + Math.floor(r() * (max - min + 1));
            }
          }
          if (Number.isFinite(tierFromRange)) {
            const tier = clamp(tierFromRange, 1, 8);
            if (temp && typeof temp === "object" && !Array.isArray(temp)) {
              if (Object.prototype.hasOwnProperty.call(temp, tier))
                return { tier, label: String(temp[tier]) };
            }
            if (Array.isArray(temp) && temp.length) {
              const idx = clamp(tier - 1, 0, temp.length - 1);
              const pick = temp[idx];
              const label =
                Array.isArray(pick) && pick.length
                  ? rngUtil.oneOf(r, pick)
                  : pick;
              return { tier, label: String(label ?? "mild") };
            }
            const label = pickFromOptions(r, temp, "mild");
            return { tier, label: String(label) };
          }
          if (temp && typeof temp === "object" && !Array.isArray(temp)) {
            const keys = Object.keys(temp)
              .map((k) => Number(k))
              .filter((n) => Number.isFinite(n))
              .sort((a, b) => a - b);
            if (keys.length) {
              const tier = keys[(r() * keys.length) | 0];
              return { tier, label: String(temp[tier]) };
            }
          }
          const label = pickFromOptions(r, temp, "mild");
          return { tier: 4, label: String(label) };
        }

        pickRainIndex(r, biome) {
          const rain = moistureLevels;
          const range = biome?.moistureRange;
          let idx = null;
          if (Array.isArray(range) && range.length >= 2) {
            const lo = Number(range[0]);
            const hi = Number(range[1]);
            if (Number.isFinite(lo) && Number.isFinite(hi)) {
              const min = clamp(Math.min(lo, hi), 1, 8);
              const max = clamp(Math.max(lo, hi), 1, 8);
              const tier = min + Math.floor(r() * (max - min + 1));
              idx = clamp(tier - 1, 0, rain.length - 1);
            }
          } else if (range && typeof range === "object") {
            const lo = Number(range.min);
            const hi = Number(range.max);
            if (Number.isFinite(lo) && Number.isFinite(hi)) {
              const min = clamp(Math.min(lo, hi), 1, 8);
              const max = clamp(Math.max(lo, hi), 1, 8);
              const tier = min + Math.floor(r() * (max - min + 1));
              idx = clamp(tier - 1, 0, rain.length - 1);
            }
          }
          if (!Number.isFinite(idx)) idx = (r() * rain.length) | 0;
          const pick = rain[idx];
          const label =
            Array.isArray(pick) && pick.length ? rngUtil.oneOf(r, pick) : pick;
          return { idx, label: String(label || "arid") };
        }

        coord(r) {
          const lat = (r() * 160 - 80).toFixed(2),
            lon = (r() * 360 - 180).toFixed(2);
          const NS = lat >= 0 ? "N" : "S",
            EW = lon >= 0 ? "E" : "W";
          return `${Math.abs(lat)}Â° ${NS}, ${Math.abs(lon)}Â° ${EW}`;
        }

        resolvePlaceholders(s, ctx, r) {
          const base = resolveInlineOptions(s, r);
          return base
            .replace(/<poi>/g, () => ctx.poi?.() ?? "site")
            .replace(/<weather>/g, () => ctx.weather?.() ?? "weather")
            .replace(/<faction>/g, () => ctx.faction?.() ?? "local faction")
            .replace(/<npc>/g, () => ctx.npc?.() ?? "a local guide");
        }

        stem(s) {
          return s.replace(/^(the|a|an)\s+/i, "").split(" ")[0];
        }

        composeHook(r, tt, ctx = {}) {
          const trigger = rngUtil.oneOf(r, tt.hooks);
          const mod =
            tt.hookMods && rngUtil.maybe(r, 0.6)
              ? this.resolvePlaceholders(rngUtil.oneOf(r, tt.hookMods), ctx, r)
              : null;
          const consequence =
            tt.hookConsequences && rngUtil.maybe(r, 0.3)
              ? this.resolvePlaceholders(
                  rngUtil.oneOf(r, tt.hookConsequences),
                  ctx,
                  r,
                )
              : null;

          const left = mod ? `${trigger} ${mod}` : trigger;
          const leftCap = left.charAt(0).toUpperCase() + left.slice(1);
          if (!consequence) return `${leftCap}.`;
          return `${leftCap}. ${consequence.charAt(0).toUpperCase()}${consequence.slice(1)}.`;
        }

        composeMotive(
          r,
          tt,
          { adjChance = 0.6, forceAdj = false, normalizeSpacing = true } = {},
        ) {
          const motive = rngUtil.oneOf(r, fieldMotiveVerbs.concat(tt.motives));
          const glue = rngUtil.oneOf(r, tt.motiveGlue);
          const includeAdj = forceAdj || rngUtil.maybe(r, adjChance);
          const adj = includeAdj ? rngUtil.oneOf(r, tt.relicAdjectives) : null;
          const noun = rngUtil.oneOf(r, tt.relicNouns);

          let line = `${motive} ${glue} ${adj ? adj + " " : ""}${noun}`;
          if (normalizeSpacing) line = line.replace(/\s{2,}/g, " ").trim();
          return line;
        }

        buildSettlementNames(nameGen, count) {
          return uniqN(count, () => nameGen.placeName());
        }

        placeWorldRefs(
          seedU32,
          theme,
          tileKeyGrid,
          N,
          poiTypes,
          factions,
          rText,
          biome,
        ) {
          const r = rngUtil.xs32(seedU32 ^ 0xa53c9e17);

          const settlements = [];
          const land = [];
          const ruinsCells = [];

          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              const k = tileKeyGrid[y][x];
              const key = `${x},${y}`;
              if (k !== "water" && k !== "lava") land.push(key);
              if (k === "settlement" || k === "fungal-settlement")
                settlements.push(key);
              if (
                k === "ruins" ||
                k === "overgrown-ruins" ||
                k === "fungal-ruins"
              )
                ruinsCells.push(key);
            }
          }

          const settlementOrder = rngUtil.shuffleDet(r, settlements);
          const landOrder = rngUtil.shuffleDet(r, land);

          const nameGen = new NameGenerator(rText);
          const settlementNames = this.buildSettlementNames(
            nameGen,
            Math.max(6, settlements.length),
          );
          const settlementNameByCell = new Map();
          const settlementTypeByCell = new Map();
          settlements.forEach((cell, i) =>
            settlementNameByCell.set(
              cell,
              settlementNames[i % settlementNames.length],
            ),
          );
          settlements.forEach((cell) => {
            const [xStr, yStr] = cell.split(",");
            const x = Number(xStr);
            const y = Number(yStr);
            const nearMountain =
              countNeighbors8Of(tileKeyGrid, N, x, y, "mountain") > 0;

            let type = rngUtil.oneOf(r, settlementTypes.base);
            const contextual = [];
            if (nearMountain)
              contextual.push(...ensure(settlementTypes.nearMountain, []));
            if (contextual.length && rngUtil.maybe(r, 0.6))
              type = rngUtil.oneOf(r, contextual);

            settlementTypeByCell.set(cell, type);
          });

          const poiPlacements = [];
          const poiTypesExpanded = poiTypes.slice();
          const ruinsRarity = this.mapGen.biomeFeatureRarity(biome, "ruins");
          let ruinCount = 0;
          if (ruinsRarity > 0) {
            ruinCount = 1 + Math.floor(ruinsRarity * 2);
            if (r() < ruinsRarity * 0.6) ruinCount += 1;
          }

          for (let i = 0; i < poiTypesExpanded.length; i++) {
            const poiType = poiTypesExpanded[i];
            const poiName = namedPOI(nameGen, poiType);

            const cell =
              settlementOrder[i] ||
              landOrder[i] ||
              `${(seedU32 % N) | 0},${((seedU32 >>> 8) % N) | 0}`;
            poiPlacements.push({ poiType, poiName, cell });
          }

          if (ruinCount > 0) {
            let rIdx = 0;
            const ruinOrder = rngUtil.shuffleDet(r, ruinsCells);
            let ruinIdx = 0;
            for (let i = 0; i < ruinCount; i++) {
              let cell = null;
              while (
                ruinIdx < ruinOrder.length &&
                (settlementNameByCell.has(ruinOrder[ruinIdx]) ||
                  poiPlacements.some((p) => p.cell === ruinOrder[ruinIdx]))
              ) {
                ruinIdx++;
              }
              if (ruinIdx < ruinOrder.length) {
                cell = ruinOrder[ruinIdx++];
              } else {
                while (
                  rIdx < landOrder.length &&
                  (settlementNameByCell.has(landOrder[rIdx]) ||
                    poiPlacements.some((p) => p.cell === landOrder[rIdx]))
                ) {
                  rIdx++;
                }
                cell =
                  landOrder[rIdx++] ||
                  landOrder[0] ||
                  `${(seedU32 % N) | 0},${((seedU32 >>> 8) % N) | 0}`;
              }
              const poiType = "ruins";
              const poiName = namedPOI(nameGen, poiType);
              poiPlacements.push({ poiType, poiName, cell });
            }
          }

          const used = new Set(poiPlacements.map((p) => p.cell));
          const factionPlacements = [];

          let sIdx = poiTypes.length;
          let lIdx = poiTypes.length;

          for (let i = 0; i < factions.length; i++) {
            let cell = null;

            while (
              sIdx < settlementOrder.length &&
              used.has(settlementOrder[sIdx])
            )
              sIdx++;
            if (sIdx < settlementOrder.length) cell = settlementOrder[sIdx++];

            if (!cell) {
              while (lIdx < landOrder.length && used.has(landOrder[lIdx]))
                lIdx++;
              cell =
                landOrder[lIdx++] || landOrder[0] || `${i % N},${(i * 7) % N}`;
            }

            used.add(cell);
            factionPlacements.push({
              factionName: factions[i].name,
              motive: factions[i].motive,
              cell,
            });
          }

          const ann = new Map();
          const ensureCell = (cell) => {
            if (!ann.has(cell)) ann.set(cell, { poi: [], factions: [] });
            return ann.get(cell);
          };

          for (const cell of settlements) {
            const o = ensureCell(cell);
            o.settlementName = settlementNameByCell.get(cell);
            o.settlementType = settlementTypeByCell.get(cell);
          }

          for (const p of poiPlacements) {
            const o = ensureCell(p.cell);
            o.poi.push({ name: p.poiName, type: p.poiType });
            if (poiIsStructure(p.poiType)) o.poiStructure = true;
          }

          for (const f of factionPlacements) {
            const o = ensureCell(f.cell);
            o.factions.push({ name: f.factionName });
            if (!settlementNameByCell.has(f.cell)) o.fieldCamp = true;
          }

          const deathGroupsList = deathGroups;
          const religiousGroupsList = religiousGroups;
          const reserved = new Set([...used, ...settlements]);
          const baseDeathChance = 0.4;
          const baseMonasteryChance = 0.4;
          const decay = 0.3;
          const maxPerKind = 3;

          const rollCount = (baseChance, decayFactor, max) => {
            let count = 0;
            let p = baseChance;
            while (count < max && r() < p) {
              count++;
              p *= decayFactor;
            }
            return count;
          };

          const deathCount = rollCount(baseDeathChance, decay, maxPerKind);
          const monasteryCount = rollCount(
            baseMonasteryChance,
            decay,
            maxPerKind,
          );
          let li = 0;

          const placeReligious = (kind, count) => {
            for (let i = 0; i < count; i++) {
              let cell = null;
              while (li < landOrder.length) {
                const cand = landOrder[li++];
                if (!reserved.has(cand)) {
                  cell = cand;
                  break;
                }
              }
              if (!cell) return;

              let label = "";
              if (kind === "death") {
                label = rngUtil.oneOf(r, deathMarkers);
              } else {
                label = rngUtil.oneOf(r, monasteryMarkers);
              }
              const group =
                kind === "death"
                  ? rngUtil.oneOf(r, deathGroupsList)
                  : rngUtil.oneOf(r, religiousGroupsList);
              const deity = nameGen.baseName();
              label = `${label}: ${group} of ${deity}`;

              const o = ensureCell(cell);
              const rel = {
                kind,
                label,
                glyph: this.tileset?.religious?.[kind],
              };
              o.religious = rel;
              o.poi.push({ name: label, type: "religious" });
              poiPlacements.push({
                poiType: "religious",
                poiName: label,
                cell,
              });
              reserved.add(cell);
            }
          };

          placeReligious("death", deathCount);
          placeReligious("monastery", monasteryCount);

          return {
            annotations: ann,
            poiPlacements,
            factionPlacements,
            settlementNameByCell,
            settlementTypeByCell,
          };
        }

        buildSlice(seedStr, theme) {
          const base = rngUtil.h32(String(seedStr));
          const r = rngUtil.xs32(base);
          const tt = this.themes[theme] || this.themes.fantasy;
          const npcR = rngUtil.xs32(base ^ 0x52dce729);
          const factionOpR = rngUtil.xs32(base ^ 0x1fb77b21);
          const npcGen = new NameGenerator(npcR);
          const npcCount = 2 + ((npcR() * 3) | 0);

          const lexicon = new LexiconBuilder(r, tt);
          const toponyms = lexicon.buildToponyms(r, 20);
          const region = lexicon.buildRegionsFromToponyms(r, toponyms, 1)[0];

          const biome = this.mapGen.normalizeBiome(rngUtil.oneOf(r, tt.biome));
          const biomeName = biome.name;
          const tempPick = this.pickTempTier(r, tempLevels, biome);
          const rainPick = this.pickRainIndex(r, biome);
          const climA = pickFromOptions(r, climateAdjLevels, "mild");
          const coords = this.coord(r);

          const climate = {
            tempTier: tempPick.tier,
            tempLabel: tempPick.label,
            rainIdx: rainPick.idx,
            rainLabel: rainPick.label,
            adj: climA,
          };

          const fCount = 1 + ((r() * 3) | 0);
          const pCount = 2 + ((r() * 3) | 0);

          const factions = [];
          for (let i = 0; i < fCount; i++) {
            const motive = this.composeMotive(r, tt);
            const name = factionName(r, theme);
            factions.push({ name, motive });
          }

          const poiTypes = [];
          for (let i = 0; i < pCount; i++)
            poiTypes.push(rngUtil.oneOf(r, tt.pois));

          const weatherNow = rngUtil.oneOf(r, tt.weather);

          const mapSeed = rngUtil.h32(seedStr + "|map|" + theme);
          const map0 = this.mapGen.genMap(
            mapSeed,
            biomeName,
            this.tileset,
            null,
            climate,
          );
          const landCells = [];
          for (let y = 0; y < map0.N; y++) {
            for (let x = 0; x < map0.N; x++) {
              if (map0.tileKeyGrid[y][x] !== "water")
                landCells.push(`${x},${y}`);
            }
          }
          const worldMeta = this.placeWorldRefs(
            mapSeed,
            theme,
            map0.tileKeyGrid,
            map0.N,
            poiTypes,
            factions,
            r,
            biomeName,
          );
          const settlementEntries = Array.from(
            worldMeta.settlementNameByCell.entries(),
          );
          const poiRefs = worldMeta.poiPlacements.map((p) => ({
            name: p.poiName,
            cell: p.cell,
          }));
          const poiNames = poiRefs.map((p) => p.name);
          const npcLocationKinds = Object.keys(npcTasks);
          const npcs = [];
          const seenNpcNames = new Set();
          let guard = 0;
          const fieldMotiveVerbSet = new Set(fieldMotiveVerbs);

          const pickCell = ({
            rng,
            cells,
            avoid = null,
            filter = null,
            fallback = "0,0",
          }) => {
            const list = Array.isArray(cells) ? cells : [];
            if (!list.length) return fallback;
            const pool = filter ? list.filter(filter) : list;
            if (!pool.length) return null;
            if (avoid === null || avoid === undefined)
              return pool[(rng() * pool.length) | 0] || fallback;
            if (pool.length <= 1) return pool[0] || fallback;
            let cell = avoid;
            for (let i = 0; i < 8 && cell === avoid; i++)
              cell = pool[(rng() * pool.length) | 0] || avoid;
            if (cell === avoid) {
              const idx = pool.indexOf(avoid);
              if (idx >= 0) return pool[(idx + 1) % pool.length];
            }
            return cell;
          };

          const pickLandCell = () => pickCell({ rng: npcR, cells: landCells });

          const pickLandCellForOps = () =>
            pickCell({ rng: factionOpR, cells: landCells });

          function pickDifferentLandCell(avoidCell) {
            return pickCell({ rng: npcR, cells: landCells, avoid: avoidCell });
          }

          const pickLandCellNear = (targetCell, maxDist) => {
            if (!targetCell) return pickLandCell();
            const parts = String(targetCell).split(",");
            const tx = Number(parts[0]);
            const ty = Number(parts[1]);
            if (!Number.isFinite(tx) || !Number.isFinite(ty))
              return pickLandCell();
            const near = pickCell({
              rng: npcR,
              cells: landCells,
              filter: (cell) => {
                const c = cell.split(",");
                const x = Number(c[0]);
                const y = Number(c[1]);
                if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
                return Math.abs(x - tx) + Math.abs(y - ty) <= maxDist;
              },
            });
            if (near) return near;
            return pickLandCell();
          };

          const pickLandCellNearDifferent = (targetCell, maxDist) => {
            if (!targetCell) return pickLandCell();
            const parts = String(targetCell).split(",");
            const tx = Number(parts[0]);
            const ty = Number(parts[1]);
            if (!Number.isFinite(tx) || !Number.isFinite(ty))
              return pickLandCell();
            const near = pickCell({
              rng: npcR,
              cells: landCells,
              filter: (cell) => {
                if (cell === targetCell) return false;
                const c = cell.split(",");
                const x = Number(c[0]);
                const y = Number(c[1]);
                if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
                return Math.abs(x - tx) + Math.abs(y - ty) <= maxDist;
              },
            });
            if (near) return near;
            return pickDifferentLandCell(targetCell);
          };

          const cellDist = (a, b) => {
            const pa = String(a || "").split(",");
            const pb = String(b || "").split(",");
            const ax = Number(pa[0]);
            const ay = Number(pa[1]);
            const bx = Number(pb[0]);
            const by = Number(pb[1]);
            if (
              !Number.isFinite(ax) ||
              !Number.isFinite(ay) ||
              !Number.isFinite(bx) ||
              !Number.isFinite(by)
            )
              return Infinity;
            return Math.abs(ax - bx) + Math.abs(ay - by);
          };

          const pickAltLocation = (avoidCell) => {
            const pool = [];
            for (const [cell, name] of settlementEntries)
              pool.push({ prep: "in", label: name, cell });
            for (const p of worldMeta.poiPlacements)
              pool.push({ prep: "at", label: p.poiName, cell: p.cell });
            const filtered = pool.filter((p) => p.cell !== avoidCell);
            if (filtered.length)
              return filtered[(npcR() * filtered.length) | 0];
            return {
              prep: "out in",
              label: "the wilds",
              cell: pickDifferentLandCell(avoidCell),
            };
          };

          const pickFactionOpLocation = (avoidCell) => {
            if (factionOpR() < 0.3) {
              return {
                prep: "out in",
                label: "the wilds",
                cell: pickLandCellNear(avoidCell, 10),
              };
            }
            const pool = [];
            for (const [cell, name] of settlementEntries)
              pool.push({ prep: "in", label: name, cell });
            for (const p of worldMeta.poiPlacements)
              pool.push({ prep: "at", label: p.poiName, cell: p.cell });
            const filtered = pool.filter(
              (p) => p.cell !== avoidCell && cellDist(p.cell, avoidCell) <= 10,
            );
            if (filtered.length)
              return filtered[(factionOpR() * filtered.length) | 0];
            return {
              prep: "out in",
              label: "the wilds",
              cell: pickLandCellNear(avoidCell, 10),
            };
          };

          const motiveVerb = (motive) =>
            String(motive || "")
              .trim()
              .split(/\s+/)[0]
              ?.toLowerCase() || "";

          const npcLocationFor = (kind) => {
            if (kind === "faction") {
              const pick = rngUtil.oneOf(npcR, worldMeta.factionPlacements);
              if (pick) {
                if (npcR() < 0.45) {
                  const alt = pickAltLocation(pick.cell);
                  return {
                    prep: alt.prep,
                    label: alt.label,
                    cell: alt.cell,
                    affiliation: {
                      prep: "for",
                      label: pick.factionName,
                      cell: pick.cell,
                    },
                  };
                }
                return {
                  prep: "with",
                  label: pick.factionName,
                  cell: pick.cell,
                };
              }
            }
            if (kind === "settlement" && settlementEntries.length) {
              const [cell, name] =
                settlementEntries[(npcR() * settlementEntries.length) | 0];
              return { prep: "in", label: name, cell };
            }
            return { prep: "out in", label: "the wilds", cell: pickLandCell() };
          };

          const npcPoiName = () => {
            if (poiNames.length) return rngUtil.oneOf(npcR, poiNames);
            return rngUtil.oneOf(npcR, tt.pois);
          };

          while (npcs.length < npcCount && guard++ < npcCount * 20) {
            const name = npcGen.npcName();
            if (seenNpcNames.has(name)) continue;
            seenNpcNames.add(name);
            const kind =
              npcLocationKinds[(npcR() * npcLocationKinds.length) | 0];
            const taskTemplate = rngUtil.oneOf(npcR, npcTasks[kind]);
            const taskPoi = npcPoiName();
            const task = this.resolvePlaceholders(
              taskTemplate,
              { poi: () => taskPoi, weather: () => weatherNow },
              npcR,
            );
            const taskHtml = linkifyRefs(task, poiRefs);
            let loc = npcLocationFor(kind);
            const taskUsesPoi = taskTemplate.includes("<poi>");
            const poiMatch = taskUsesPoi
              ? poiRefs.find((p) => p.name === taskPoi)
              : null;
            if (poiMatch) {
              // If the task already names a POI, keep the location in the wilds nearby.
              loc = {
                prep: "out in",
                label: "the wilds",
                cell: pickLandCellNearDifferent(poiMatch.cell, 5),
                affiliation: loc.affiliation,
              };
            } else if (loc.prep === "out in" && loc.label === "the wilds") {
              const nearMatch = poiRefs.find((p) => p.name === taskPoi);
              if (nearMatch)
                loc.cell = pickLandCellNearDifferent(nearMatch.cell, 5);
            }
            npcs.push({
              name,
              task,
              taskHtml,
              prep: loc.prep,
              label: loc.label,
              cell: loc.cell,
              affiliation: loc.affiliation,
            });
          }

          const factionOps = worldMeta.factionPlacements.map((fp) => {
            const verb = motiveVerb(fp.motive);
            if (!fieldMotiveVerbSet.has(verb)) return null;
            const roll = factionOpR();
            if (roll > 0.45) {
              if (roll < 0.85) {
                return {
                  verb,
                  prep: "out in",
                  label: "the wilds",
                  cell: pickLandCellNear(fp.cell, 10),
                };
              }
              return null;
            }
            return { verb, ...pickFactionOpLocation(fp.cell) };
          });

          factionOps.forEach((op, i) => {
            if (!op) return;
            const fp = worldMeta.factionPlacements[i];
            let a = worldMeta.annotations.get(op.cell);
            if (!a) {
              a = { poi: [], factions: [] };
              worldMeta.annotations.set(op.cell, a);
            }
            if (!a.factionOps) a.factionOps = [];
            a.factionOps.push({ name: fp.factionName, verb: op.verb });
          });

          for (const npc of npcs) {
            let a = worldMeta.annotations.get(npc.cell);
            if (!a) {
              a = { poi: [], factions: [] };
              worldMeta.annotations.set(npc.cell, a);
            }
            if (!a.npcs) a.npcs = [];
            a.npcs.push({ name: npc.name, task: npc.task });
          }

          const map1 = this.mapGen.genMap(
            mapSeed,
            biomeName,
            this.tileset,
            worldMeta,
            climate,
          );
          const hookPick = rngUtil.oneOf(r, worldMeta.poiPlacements);
          const hookPOIName = hookPick
            ? hookPick.poiName
            : rngUtil.oneOf(r, tt.pois);
          const hookPOICell = hookPick ? hookPick.cell : null;
          const hookFactionPick = rngUtil.oneOf(r, worldMeta.factionPlacements);
          const hookFactionName = hookFactionPick
            ? hookFactionPick.factionName
            : rngUtil.oneOf(r, factions)?.name;
          const hookNpcPick = rngUtil.oneOf(r, npcs);
          const hookNpcName = hookNpcPick ? hookNpcPick.name : null;

          const hook = this.composeHook(r, tt, {
            poi: () => hookPOIName,
            weather: () => rngUtil.oneOf(r, tt.weather),
            faction: () => hookFactionName ?? "local faction",
            npc: () => hookNpcName ?? "a local guide",
          });

          let hookHtml = escHtml(hook);
          if (hookPick && hookPOIName) {
            const re = new RegExp(escRe(hookPOIName), "g");
            hookHtml = hookHtml.replace(re, xref(hookPOICell, hookPOIName));
          }

          let html = "";
          html += `Theme  : ${escHtml(theme)}\n`;
          html += `Region : ${escHtml(region)}\n`;
          html += `Biome  : ${escHtml(biomeName)}\n`;
          html += `Coords : ${escHtml(coords)}\n`;
          html += `Climate: ${escHtml(tempPick.label)}, ${escHtml(rainPick.label)}, ${escHtml(climA)}\n`;
          html += `Current Weather: ${escHtml(weatherNow)}\n\n`;

          html += `Factions (${factions.length}):\n`;
          worldMeta.factionPlacements.forEach((fp, i) => {
            const baseAnn = worldMeta.annotations.get(fp.cell);
            const baseName = baseAnn?.settlementName
              ? baseAnn.settlementName
              : "Field Camp";
            html += `  ${i + 1}. ${xref(fp.cell, fp.factionName)}\n`;
            const op = factionOps[i];
            html += `\t- ${escHtml(fp.motive)}`;
            if (op) {
              html += ` ${escHtml(op.prep)} ${xref(op.cell, op.label)} @ (${escHtml(op.cell)})`;
            }
            html += "\n";
            html += `\t- Base: ${xref(fp.cell, baseName)} @ (${escHtml(fp.cell)})\n`;
            html += "\n";
          });

          html += `NPCs (${npcs.length}):\n`;
          npcs.forEach((npc) => {
            let line = `  - ${escHtml(npc.name)}: ${npc.taskHtml}`;
            if (npc.affiliation) {
              line += ` ${escHtml(npc.affiliation.prep)} ${xref(npc.affiliation.cell, npc.affiliation.label)}`;
            }
            line += ` ${escHtml(npc.prep)} ${xref(npc.cell, npc.label)}\n`;
            html += line;
          });
          html += "\n";

          html += `Points of Interest (${worldMeta.poiPlacements.length}):\n`;
          const seenFerries = new Set();
          worldMeta.poiPlacements.forEach((p) => {
            const a = worldMeta.annotations.get(p.cell);
            const near = a?.settlementName
              ? `, near ${xref(p.cell, a.settlementName)}`
              : "";
            if (p.poiType === "ferry" && p.ferryId) {
              if (seenFerries.has(p.ferryId)) return;
              seenFerries.add(p.ferryId);
              const baseName = String(p.poiName).replace(
                /\s*\((north|south|east|west)\)\s*$/i,
                "",
              );
              const poiLabel = `<span class="xref" data-cell="${escAttr(p.cell)}" data-ferry-id="${escAttr(p.ferryId)}">${escHtml(baseName)}</span>`;
              html += `  - ${poiLabel}${near} @ (${escHtml(p.cell)})\n`;
              return;
            }
            const poiLabel = xref(p.cell, p.poiName);
            html += `  - ${poiLabel}${near} @ (${escHtml(p.cell)})\n`;
          });

          html += `\nHook: ${hookHtml}\n`;

          const biomeLower = biomeName.toLowerCase();
          const mapFlags = {
            deadTrees: this.mapGen.biomeAllowsFeature(
              biomeName,
              "dead trees",
              0.2,
            ),
            desert: biomeLower.includes("desert"),
          };

          return { html, mapGrid: map1.html, mapFlags };
        }
      }

      // #endregion World Builder
      // #region Map Generation
      /* ====================== Map Generation ====================== */
      class MapGenerator {
        constructor() {}

        normalizeWeights(weights) {
          const total = Object.values(weights).reduce((a, b) => a + b, 0) || 1;
          for (const k in weights) weights[k] /= total;
        }

        normalizeBiomeFeatures(features, fallbackRarity = 0.3) {
          const clampRarity = (value) => Math.max(0, Math.min(1, value));
          if (!features) return {};
          if (Array.isArray(features)) {
            const out = {};
            for (const f of features) {
              if (typeof f === "string") {
                validateFeatureName(f, "biome.features");
                out[f] = fallbackRarity;
                continue;
              }
              if (f && typeof f === "object") {
                const id = "id" in f ? f.id : "name" in f ? f.name : "";
                const rarity = Number.isFinite(f.rarity)
                  ? clampRarity(Number(f.rarity))
                  : fallbackRarity;
                if (id) {
                  validateFeatureName(String(id), "biome.features");
                  out[String(id)] = rarity;
                }
              }
            }
            return out;
          }
          if (typeof features === "object") {
            const out = {};
            for (const [key, value] of Object.entries(features)) {
              if (!key) continue;
              validateFeatureName(String(key), "biome.features");
              const rarity = Number.isFinite(value)
                ? clampRarity(Number(value))
                : fallbackRarity;
              out[String(key)] = rarity;
            }
            return out;
          }
          return {};
        }

        normalizeBiome(biome) {
          const defaultFeatures = {};
          if (!biome) return { name: "", features: {} };
          if (typeof biome === "string") {
            const known = this.normalizeBiomeFeatures(
              biomeFeaturesByName[biome.toLowerCase()],
            );
            return {
              name: biome,
              features: Object.keys(known).length ? known : defaultFeatures,
            };
          }
          if (typeof biome === "object") {
            const name =
              "name" in biome ? String(biome.name ?? "") : String(biome);
            const features = this.normalizeBiomeFeatures(biome.features);
            if (Object.keys(features).length) return { name, features };
            const known = this.normalizeBiomeFeatures(
              biomeFeaturesByName[name.toLowerCase()],
            );
            return {
              name,
              features: Object.keys(known).length ? known : defaultFeatures,
            };
          }
          return { name: String(biome), features: defaultFeatures };
        }

        biomeFeatureRarity(biome, id) {
          validateFeatureName(String(id), "feature lookup");
          const { features } = this.normalizeBiome(biome);
          const rarity = features?.[id];
          return Number.isFinite(rarity) ? rarity : 0;
        }

        biomeAllowsFeature(biome, id, minRarity = 0.25) {
          validateFeatureName(String(id), "feature lookup");
          const { features } = this.normalizeBiome(biome);
          const rarity = features?.[id];
          return Number.isFinite(rarity) && rarity >= minRarity;
        }

        tileWeightsForBiome(biome) {
          const baseWeights = {
            water: 0.12,
            mountain: 0.15,
            forest: 0.25,
            grass: 0.2,
            plains: 0.28,
          };
          const inc = (k, f) =>
            (baseWeights[k] = Math.max(0.01, baseWeights[k] * f));
          if (
            String(biome || "")
              .toLowerCase()
              .includes("desert")
          ) {
            inc("forest", 0.45);
            inc("grass", 0.6);
            inc("plains", 1.35);
            inc("water", 0.85);
            inc("mountain", 1.05);
          }
          const { features } = this.normalizeBiome(biome);
          const applyFeature = (id, minRarity, fn) => {
            const rarity = features?.[id];
            if (!Number.isFinite(rarity) || rarity < minRarity) return;
            fn(rarity);
          };

          applyFeature("dunes", 0.05, (rarity) => {
            inc("plains", 1 + rarity * 1.2);
            inc("forest", 1 - rarity * 0.6);
            inc("grass", 1 - rarity * 0.4);
            inc("water", 1 - rarity * 0.4);
            inc("mountain", 1 - rarity * 0.2);
          });

          applyFeature("oasis", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.5);
            inc("grass", 1 + rarity * 0.8);
            inc("forest", 1 + rarity * 0.4);
            inc("plains", 1 - rarity * 0.2);
          });

          applyFeature("river-water", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.0);
            inc("plains", 1 - rarity * 0.1);
          });

          applyFeature("river-lava", 0.05, (rarity) => {
            inc("mountain", 1 + rarity * 0.5);
            inc("plains", 1 + rarity * 0.2);
            inc("water", 1 - rarity * 0.4);
          });

          applyFeature("lake", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.4);
            inc("plains", 1 - rarity * 0.2);
          });

          applyFeature("reef", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.6);
            inc("plains", 1 - rarity * 0.3);
          });

          applyFeature("lagoon", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.3);
            inc("plains", 1 - rarity * 0.25);
          });

          applyFeature("beaches", 0.05, (rarity) => {
            inc("water", 1 + rarity * 0.6);
            inc("plains", 1 + rarity * 0.4);
          });

          applyFeature("mountain", 0.05, (rarity) => {
            inc("mountain", 1 + rarity * 1.5);
            inc("plains", 1 + rarity * 0.2);
            inc("forest", 1 - rarity * 0.1);
            inc("grass", 1 - rarity * 0.1);
          });

          applyFeature("ridge", 0.05, (rarity) => {
            inc("mountain", 1 + rarity * 1.1);
            inc("plains", 1 + rarity * 0.15);
            inc("forest", 1 - rarity * 0.1);
            inc("grass", 1 - rarity * 0.1);
          });

          applyFeature("ruins", 0.05, (rarity) => {
            inc("plains", 1 + rarity * 0.2);
            inc("grass", 1 + rarity * 0.2);
          });

          applyFeature("mycelium", 0.05, (rarity) => {
            inc("forest", 1 + rarity * 0.5);
            inc("grass", 1 + rarity * 0.4);
          });

          applyFeature("crystals", 0.05, (rarity) => {
            inc("plains", 1 + rarity * 0.5);
            inc("forest", 1 - rarity * 0.45);
            inc("grass", 1 - rarity * 0.35);
            inc("water", 1 - rarity * 0.2);
          });

          applyFeature("dead trees", 0.05, (rarity) => {
            inc("forest", 1 - rarity * 0.2);
            inc("grass", 1 - rarity * 0.15);
            inc("plains", 1 + rarity * 0.1);
          });

          applyFeature("watering hole", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.2);
            inc("grass", 1 + rarity * 0.4);
            inc("plains", 1 - rarity * 0.2);
          });

          this.normalizeWeights(baseWeights);
          return baseWeights;
        }

        pickByWeights(x, weights) {
          const keys = Object.keys(weights);
          let acc = 0;
          for (let i = 0; i < keys.length; i++) {
            const k = keys[i];
            acc += weights[k];
            if (x <= acc) return k;
          }
          return keys[keys.length - 1];
        }

        pickVariant(tileKey, tileset, seed) {
          const def = tileset[tileKey] || tileset.plains;
          const variants = baseGlyphs(def) || baseGlyphs(tileset.plains) || [];
          const index = Math.floor(seed * variants.length);
          return variants[index] || firstBaseGlyph(tileset.plains, "?");
        }

        genMap(seedU32, biome, tileset, worldMeta = null, climate = null) {
          const N = 25;
          const weights = this.tileWeightsForBiome(biome);
          const normalizeWeights = this.normalizeWeights.bind(this);
          const pickByWeights = this.pickByWeights.bind(this);
          const biomeAllowsFeature = this.biomeAllowsFeature.bind(this);
          const biomeFeatureRarity = this.biomeFeatureRarity.bind(this);
          maybeApplyMountainBias(seedU32, weights, normalizeWeights);
          const { riverType, river } = buildRiver(
            seedU32,
            biome,
            N,
            biomeAllowsFeature,
          );
          let tileKeyGrid = initGrid(N, "plains");
          tileKeyGrid = applyInitialTiles(
            seedU32,
            tileKeyGrid,
            weights,
            N,
            riverType,
            river,
            pickByWeights,
          );

          const ridgeRarity = biomeFeatureRarity(biome, "ridge");
          tileKeyGrid = smoothMountains(
            seedU32,
            tileKeyGrid,
            weights,
            N,
            2,
            pickByWeights,
          );
          tileKeyGrid = thinRidges(
            seedU32,
            tileKeyGrid,
            weights,
            N,
            ridgeRarity,
            pickByWeights,
          );
          tileKeyGrid = applyDunePatches(
            seedU32,
            tileKeyGrid,
            N,
            biomeFeatureRarity(biome, "dunes"),
          );
          const desertAll = desertAllEnabled(seedU32, biome);
          tileKeyGrid = applyDesertAll(tileKeyGrid, N, desertAll);
          const oasisResult = applyOasisPatches(
            seedU32,
            tileKeyGrid,
            N,
            biomeFeatureRarity(biome, "oasis"),
          );
          tileKeyGrid = oasisResult.grid;
          const oasisVeg = oasisResult.oasisVeg;
          tileKeyGrid = thinDesertForests(
            seedU32,
            tileKeyGrid,
            N,
            biome,
            climate,
            oasisVeg,
          );
          tileKeyGrid = applyMyceliumPatches(
            seedU32,
            tileKeyGrid,
            N,
            biomeFeatureRarity(biome, "mycelium"),
          );
          tileKeyGrid = applyCrystalPatches(
            seedU32,
            tileKeyGrid,
            N,
            biomeFeatureRarity(biome, "crystals"),
          );
          const ruinCenters =
            worldMeta?.poiPlacements?.filter((p) => p.poiType === "ruins") ||
            [];
          tileKeyGrid = applyRuinsClusters(
            seedU32,
            tileKeyGrid,
            N,
            ruinCenters,
            biomeFeatureRarity(biome, "ruins"),
          );
          tileKeyGrid = applyOvergrownRuins(
            seedU32,
            tileKeyGrid,
            N,
            climate,
          );
          tileKeyGrid = applyLavaEdge(tileKeyGrid, N, worldMeta);
          tileKeyGrid = applyStoneNearLava(tileKeyGrid, N);
          tileKeyGrid = cleanupIsolatedWater(
            seedU32,
            tileKeyGrid,
            weights,
            N,
            pickByWeights,
          );
          tileKeyGrid = cleanupIsolatedWater(
            seedU32,
            tileKeyGrid,
            weights,
            N,
            pickByWeights,
          );

          const depthGrid = buildDepthGrid(
            seedU32,
            tileKeyGrid,
            river,
            N,
            riverType || "water",
          );
          if (worldMeta?.settlementTypeByCell) {
            for (const cell of worldMeta.settlementTypeByCell.keys()) {
              const [xStr, yStr] = cell.split(",");
              const x = Number(xStr);
              const y = Number(yStr);
              if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

              let nearWater = false;
              for (const [nx, ny] of neighbors4(N, x, y)) {
                if (tileKeyGrid[ny][nx] === "water") {
                  nearWater = true;
                  break;
                }
              }

              if (!nearWater) {
                for (let dy = -3; dy <= 3 && !nearWater; dy++) {
                  for (let dx = -3; dx <= 3; dx++) {
                    if (Math.max(Math.abs(dx), Math.abs(dy)) > 3) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;
                    if (
                      tileKeyGrid[ny][nx] === "water" &&
                      depthGrid[ny][nx] >= 2
                    ) {
                      nearWater = true;
                      break;
                    }
                  }
                }
              }

              if (!nearWater) continue;
              const roll = rngUtil.n2(seedU32, 92000 + x, 92100 + y);
              if (roll < 0.8) {
                const list = ensure(settlementTypes.nearWater, []);
                if (list.length) {
                  const cellSeed =
                    seedU32 ^ ((x * 374761393) | 0) ^ ((y * 668265263) | 0);
                  const rPick = rngUtil.xs32(cellSeed ^ 0x4f1a2b3c);
                  worldMeta.settlementTypeByCell.set(
                    cell,
                    rngUtil.oneOf(rPick, list),
                  );
                }
              }
            }
          }
          tileKeyGrid = applyBeachPatches(seedU32, tileKeyGrid, depthGrid, N);
          tileKeyGrid = applyStoneNearRivers(
            seedU32,
            tileKeyGrid,
            river,
            N,
          );
          let heightGrid = buildHeightGrid(tileKeyGrid, N);
          heightGrid = boostMountainHeights(
            heightGrid,
            tileKeyGrid,
            N,
            ridgeRarity,
          );
          const forestTypeGrid = buildForestTypeGrid(
            seedU32,
            tileKeyGrid,
            N,
            biome,
            climate,
            oasisVeg,
            biomeAllowsFeature,
          );
          const roadInfo = buildRoadNetwork(
            seedU32,
            tileKeyGrid,
            heightGrid,
            depthGrid,
            worldMeta,
            N,
          );
          tileKeyGrid = applyVolcanicPeakFlow(
            seedU32,
            tileKeyGrid,
            heightGrid,
            depthGrid,
            N,
            biome,
            biomeAllowsFeature,
            worldMeta,
            roadInfo?.cells,
          );
          tileKeyGrid = applyVolcanicPeakPool(
            seedU32,
            tileKeyGrid,
            heightGrid,
            depthGrid,
            N,
            biome,
            biomeAllowsFeature,
            worldMeta,
            roadInfo?.cells,
          );
          if (worldMeta?.settlementTypeByCell && roadInfo?.cells) {
            for (const cell of worldMeta.settlementTypeByCell.keys()) {
              const [xStr, yStr] = cell.split(",");
              const x = Number(xStr);
              const y = Number(yStr);
              if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

              let roadNeighbors = 0;
              for (const [nx, ny] of neighbors4(N, x, y)) {
                if (roadInfo.cells.has(`${nx},${ny}`)) roadNeighbors++;
              }
              if (roadNeighbors < 2) continue;

              const roll = rngUtil.n2(seedU32, 93000 + x, 93100 + y);
              if (roll < 0.65) {
                const list = ensure(settlementTypes.nearPaths, []);
                if (list.length) {
                  const cellSeed =
                    seedU32 ^ ((x * 374761393) | 0) ^ ((y * 668265263) | 0);
                  const rPick = rngUtil.xs32(cellSeed ^ 0x9a1b2c3d);
                  worldMeta.settlementTypeByCell.set(
                    cell,
                    rngUtil.oneOf(rPick, list),
                  );
                }
              }
            }
          }
          if (worldMeta?.annotations && worldMeta?.settlementTypeByCell) {
            for (const [cell, type] of worldMeta.settlementTypeByCell.entries()) {
              const a = worldMeta.annotations.get(cell);
              if (a) a.settlementType = type;
            }
          }
          const html = renderMapHtml(
            seedU32,
            tileKeyGrid,
            depthGrid,
            heightGrid,
            forestTypeGrid,
            N,
            worldMeta,
            tileset,
            this.pickVariant.bind(this),
            roadInfo,
          );

          return {
            html,
            tileKeyGrid,
            depthGrid,
            heightGrid,
            forestTypeGrid,
            roadCells: roadInfo.cells,
            N,
            river,
          };
        }
      }

      const mapGenerator = new MapGenerator();
      const worldBuilder = new WorldBuilder(mapGenerator, tileset);

      function riverCells(seedU32, N) {
        const cells = new Set();
        const rand = rngUtil.xs32(seedU32 ^ 0x6d2b79f5);
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];

        const addCells = (x, y, width) => {
          const nx = x;
          const ny = y;
          if (nx < 0 || nx >= N || ny < 0 || ny >= N) return;
          cells.add(`${nx},${ny}`);
          if (width <= 1) return;
          const spill = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ];
          for (const [ox, oy] of spill) {
            const sx = x + ox;
            const sy = y + oy;
            if (sx < 0 || sx >= N || sy < 0 || sy >= N) continue;
            cells.add(`${sx},${sy}`);
          }
        };

        const pickDir = () => dirs[(rand() * dirs.length) | 0];
        const downhillAngle = rand() * Math.PI * 2;
        const downhill = {
          x: Math.cos(downhillAngle),
          y: Math.sin(downhillAngle),
        };
        const margin = Math.max(3, Math.floor(N * 0.08));
        const startFromEdge = () => {
          if (Math.abs(downhill.x) > Math.abs(downhill.y)) {
            const x = downhill.x > 0 ? -margin : N - 1 + margin;
            const y = (rand() * N) | 0;
            return { x, y };
          }
          const x = (rand() * N) | 0;
          const y = downhill.y > 0 ? -margin : N - 1 + margin;
          return { x, y };
        };
        const flowDirForCell = (x, y) => {
          const n1 = rngUtil.n2(seedU32, 81000 + x, 82000 + y);
          const n2 = rngUtil.n2(seedU32, 83000 + x, 84000 + y);
          const ang = n1 * Math.PI * 2;
          const mag = 0.45 + n2 * 0.35;
          const vx = downhill.x + Math.cos(ang) * mag;
          const vy = downhill.y + Math.sin(ang) * mag;
          const len = Math.hypot(vx, vy) || 1;
          return { x: vx / len, y: vy / len };
        };
        const pickBiasedDir = (x, y) => {
          const v = flowDirForCell(x, y);
          let best = null;
          let sum = 0;
          const weights = [];
          for (const d of dirs) {
            const dot = d[0] * v.x + d[1] * v.y;
            const w = Math.max(0.02, 0.18 + Math.max(0, dot) * 0.95);
            weights.push(w);
            sum += w;
          }
          let t = rand() * sum;
          for (let i = 0; i < dirs.length; i++) {
            t -= weights[i];
            if (t <= 0) {
              best = dirs[i];
              break;
            }
          }
          return best || dirs[0];
        };
        const lenMain = Math.floor(N * (1.8 + rand() * 0.9));
        const startPos = startFromEdge();
        const start = {
          x: startPos.x,
          y: startPos.y,
          len: lenMain,
          width: 2,
          branchChance: 0.03,
          turnChance: 0.32,
          dir: pickBiasedDir(startPos.x, startPos.y),
        };

        const queue = [start];
        while (queue.length) {
          const p = queue.pop();
          let x = p.x;
          let y = p.y;
          let dx = p.dir[0];
          let dy = p.dir[1];

          for (let i = 0; i < p.len; i++) {
            const width = p.width;
            addCells(x, y, width);

            if (rand() < p.branchChance && p.len - i > 8) {
              queue.push({
                x,
                y,
                len: Math.floor(p.len * (0.45 + rand() * 0.2)),
                width: 2,
                branchChance: p.branchChance * 0.6,
                turnChance: p.turnChance * 0.85,
                dir: pickBiasedDir(x, y),
              });
            }

            if (rand() < p.turnChance) {
              const nd = pickBiasedDir(x, y);
              dx = nd[0];
              dy = nd[1];
            }

            x += dx;
            y += dy;

            if (
              x < -margin ||
              x > N - 1 + margin ||
              y < -margin ||
              y > N - 1 + margin
            )
              break;
          }
        }
        return cells;
      }

      /* ====================== Shared grid helpers ====================== */
      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }

      function neighbors4(N, x, y) {
        const out = [];
        if (y > 0) out.push([x, y - 1]);
        if (x < N - 1) out.push([x + 1, y]);
        if (y < N - 1) out.push([x, y + 1]);
        if (x > 0) out.push([x - 1, y]);
        return out;
      }

      function neighbors8(N, x, y) {
        const out = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx,
              ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < N && ny < N) out.push([nx, ny]);
          }
        }
        return out;
      }

      function countNeighbors8Of(tileKeyGrid, N, x, y, key) {
        let c = 0;
        for (const [nx, ny] of neighbors8(N, x, y))
          if (tileKeyGrid[ny][nx] === key) c++;
        return c;
      }

      function countWaterNeighbors4(tileKeyGrid, N, x, y) {
        const neigh = neighbors4(N, x, y);
        let c = 0;
        for (const [nx, ny] of neigh) if (tileKeyGrid[ny][nx] === "water") c++;
        return c;
      }

      function cleanupIsolatedWater(
        seedU32,
        tileKeyGrid,
        weights,
        N,
        pickByWeights,
      ) {
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "water") continue;
            const waterN4 = countWaterNeighbors4(tileKeyGrid, N, x, y);
            if (waterN4 >= 2) continue;

            const cand = new Map();
            for (const [nx, ny] of neighbors4(N, x, y)) {
              const k = tileKeyGrid[ny][nx];
              if (!k || k === "water" || k === "settlement") continue;
              cand.set(k, (cand.get(k) || 0) + 1);
            }

            let replacement = null;

            if (cand.size) {
              const entries = Array.from(cand.entries());
              entries.sort((a, b) => b[1] - a[1]);
              const topCount = entries[0][1];
              const tied = entries
                .filter((e) => e[1] === topCount)
                .map((e) => e[0]);
              if (tied.length === 1) replacement = tied[0];
              else {
                const roll = rngUtil.n2(seedU32, 19000 + x, 19100 + y);
                replacement = tied[Math.floor(roll * tied.length)];
              }
            } else {
              const roll = rngUtil.n2(seedU32, 19200 + x, 19300 + y);
              const w2 = { ...weights };
              delete w2.water;
              delete w2.settlement;
              const total = Object.values(w2).reduce((a, b) => a + b, 0) || 1;
              for (const k in w2) w2[k] /= total;
              replacement = pickByWeights(roll, w2);
            }

            next[y][x] = replacement || "plains";
          }
        }
        return next;
      }

      // Deterministic "make ranges" pass.
      function smoothMountains(
        seedU32,
        tileKeyGrid,
        weights,
        N,
        rounds = 2,
        pickByWeights,
      ) {
        let cur = tileKeyGrid.map((row) => row.slice());

        for (let round = 0; round < rounds; round++) {
          const next = cur.map((row) => row.slice());

          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              const k = cur[y][x];
              if (k === "water" || k === "settlement") continue;

              const m8 = countNeighbors8Of(cur, N, x, y, "mountain");
              const roll = rngUtil.n2(
                seedU32,
                54000 + round * 1000 + x,
                54100 + round * 1000 + y,
              );

              if (k === "mountain") {
                if (m8 <= 2 && roll < 0.8) {
                  const w2 = { ...weights };
                  delete w2.water;
                  delete w2.settlement;
                  delete w2.mountain;
                  const total =
                    Object.values(w2).reduce((a, b) => a + b, 0) || 1;
                  for (const kk in w2) w2[kk] /= total;
                  next[y][x] = pickByWeights(roll, w2);
                } else if (m8 === 3 && roll < 0.35) {
                  const w2 = { ...weights };
                  delete w2.water;
                  delete w2.settlement;
                  delete w2.mountain;
                  const total =
                    Object.values(w2).reduce((a, b) => a + b, 0) || 1;
                  for (const kk in w2) w2[kk] /= total;
                  next[y][x] = pickByWeights(roll, w2);
                }
              } else {
                if (m8 >= 5 && roll < 0.45) next[y][x] = "mountain";
                else if (m8 === 4 && roll < 0.2) next[y][x] = "mountain";
              }
            }
          }

          cur = next;
        }

        return cur;
      }

      function thinRidges(
        seedU32,
        tileKeyGrid,
        weights,
        N,
        ridgeRarity,
        pickByWeights,
      ) {
        if (!Number.isFinite(ridgeRarity) || ridgeRarity <= 0)
          return tileKeyGrid;
        let cur = tileKeyGrid.map((row) => row.slice());
        const erosionChance = clamp(0.35 + ridgeRarity * 0.35, 0.35, 0.75);
        const growthChance = clamp(0.1 + ridgeRarity * 0.2, 0.1, 0.35);

        const isMountain = (x, y, grid) =>
          x >= 0 && y >= 0 && x < N && y < N && grid[y][x] === "mountain";
        const isStraight = (x, y, grid) => {
          const north = isMountain(x, y - 1, grid);
          const south = isMountain(x, y + 1, grid);
          const east = isMountain(x + 1, y, grid);
          const west = isMountain(x - 1, y, grid);
          return (north && south) || (east && west);
        };

        for (let round = 0; round < 1; round++) {
          const next = cur.map((row) => row.slice());
          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              const k = cur[y][x];
              if (k === "water" || k === "settlement") continue;

              const m8 = countNeighbors8Of(cur, N, x, y, "mountain");
              const straight = isStraight(x, y, cur);
              const roll = rngUtil.n2(
                seedU32,
                56000 + round * 1000 + x,
                56100 + round * 1000 + y,
              );

              if (k === "mountain") {
                if (!straight && m8 <= 3 && roll < erosionChance) {
                  const w2 = { ...weights };
                  delete w2.water;
                  delete w2.settlement;
                  delete w2.mountain;
                  const total =
                    Object.values(w2).reduce((a, b) => a + b, 0) || 1;
                  for (const kk in w2) w2[kk] /= total;
                  next[y][x] = pickByWeights(roll, w2);
                }
              } else {
                const straightNeighbor = isStraight(x, y, cur);
                if (straightNeighbor && roll < growthChance * 1.8)
                  next[y][x] = "mountain";
                else if (m8 >= 6 && roll < growthChance)
                  next[y][x] = "mountain";
              }
            }
          }
          cur = next;
        }
        return cur;
      }

      /* ====================== Water depth via distance-to-land + smoothing ====================== */
      function liquidGlyph(tileKey, depth, tileset, seedU32, x, y) {
        const t = tileset[tileKey] || tileset.water;
        const glyph =
          t.depthGlyphs[depth] ||
          t.depthGlyphs[1] ||
          firstBaseGlyph(tileset.plains, "?");
        if (Array.isArray(glyph)) {
          const roll = Number.isFinite(seedU32)
            ? rngUtil.n2(seedU32, 88000 + x, 88100 + y)
            : Math.random();
          return (
            glyph[Math.floor(roll * glyph.length)] ||
            glyph[0] ||
            firstBaseGlyph(tileset.plains, "?")
          );
        }
        return glyph;
      }

      function distToNonLiquid(tileKeyGrid, N, liquidKey) {
        const INF = 1e9;
        const dist = Array.from({ length: N }, () => Array(N).fill(INF));

        const qx = new Int16Array(N * N);
        const qy = new Int16Array(N * N);
        let head = 0,
          tail = 0;

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) {
              dist[y][x] = 0;
              qx[tail] = x;
              qy[tail] = y;
              tail++;
            }
          }
        }

        while (head < tail) {
          const x = qx[head],
            y = qy[head];
          head++;
          const d = dist[y][x];

          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (dist[ny][nx] > d + 1) {
              dist[ny][nx] = d + 1;
              qx[tail] = nx;
              qy[tail] = ny;
              tail++;
            }
          }
        }

        return dist;
      }

      function smoothDepthsTodo2(
        seedU32,
        tileKeyGrid,
        depthGrid,
        N,
        liquidKey,
      ) {
        const next = depthGrid.map((row) => row.slice());

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            if (next[y][x] <= 1) continue;

            let hasPlainsOrGrass = false;
            for (const [nx, ny] of neighbors8(N, x, y)) {
              if (
                tileKeyGrid[ny][nx] === "plains" ||
                tileKeyGrid[ny][nx] === "grass"
              ) {
                hasPlainsOrGrass = true;
                break;
              }
            }
            if (!hasPlainsOrGrass) continue;
            next[y][x] = 1;
          }
        }

        const next2 = next.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            if (next[y][x] !== 3) continue;

            let touches1 = false;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (tileKeyGrid[ny][nx] === liquidKey && next[ny][nx] === 1) {
                touches1 = true;
                break;
              }
            }
            if (!touches1) continue;

            const roll = rngUtil.n2(seedU32, 62000 + x, 62100 + y);
            if (roll < 0.5) next2[y][x] = 2;
          }
        }

        return next2;
      }

      function bumpDepthCenters(tileKeyGrid, depthGrid, N, liquidKey) {
        const next = depthGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            const d = depthGrid[y][x];
            if (d >= 3) continue;
            let sameOrHigher = true;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (tileKeyGrid[ny][nx] !== liquidKey || depthGrid[ny][nx] < d) {
                sameOrHigher = false;
                break;
              }
            }
            if (sameOrHigher) next[y][x] = d + 1;
          }
        }
        return next;
      }

      function buildDepthGrid(
        seedU32,
        tileKeyGrid,
        river,
        N,
        liquidKey = "water",
      ) {
        const dist = distToNonLiquid(tileKeyGrid, N, liquidKey);

        const depthGrid = Array.from({ length: N }, () => Array(N).fill(0));
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            let d = clamp(dist[y][x], 1, 3);
            if (river?.has(`${x},${y}`)) d = Math.max(d, 2);
            depthGrid[y][x] = d;
          }
        }

        const smoothed = smoothDepthsTodo2(
          seedU32,
          tileKeyGrid,
          depthGrid,
          N,
          liquidKey,
        );
        return bumpDepthCenters(tileKeyGrid, smoothed, N, liquidKey);
      }

      function applyLavaEdge(tileKeyGrid, N, worldMeta) {
        const next = tileKeyGrid.map((row) => row.slice());
        const protectedTiles = new Set([
          "settlement",
          "camp",
          "ruins",
          "overgrown-ruins",
          "religious",
        ]);
        const protectedCells = new Set();
        if (worldMeta?.annotations) {
          for (const cell of worldMeta.annotations.keys())
            protectedCells.add(cell);
        }
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "lava") continue;
            for (const [nx, ny] of neighbors8(N, x, y)) {
              const k = tileKeyGrid[ny][nx];
              if (protectedTiles.has(k)) continue;
              if (protectedCells.has(`${nx},${ny}`)) continue;
              if (k === "mountain" || k === "water") continue;
              next[ny][nx] = "lava";
            }
          }
        }
        return next;
      }

      function applyStoneNearLava(tileKeyGrid, N) {
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "plains") continue;
            if (isAdjacentTo(tileKeyGrid, N, x, y, "lava")) {
              next[y][x] = "stone";
            }
          }
        }
        return next;
      }

      function applyStoneNearRivers(seedU32, tileKeyGrid, river, N) {
        if (!river || !river.size) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const chance = 0.12;
        const allowed = new Set(["plains", "grass"]);
        const blocked = new Set([
          "settlement",
          "fungal-settlement",
          "camp",
          "ruins",
          "overgrown-ruins",
          "fungal-ruins",
          "religious",
          "lava",
        ]);
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            const k = tileKeyGrid[y][x];
            if (!allowed.has(k)) continue;
            let nearRiver = false;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (river.has(`${nx},${ny}`)) {
                nearRiver = true;
                break;
              }
            }
            if (!nearRiver) continue;
            const roll = rngUtil.n2(seedU32, 84500 + x, 84600 + y);
            if (roll < chance) {
              const clumpSize = 2 + ((rngUtil.n2(seedU32, 84700 + x, 84800 + y) * 3) | 0);
              let cx = x;
              let cy = y;
              for (let i = 0; i < clumpSize; i++) {
                if (cx < 0 || cy < 0 || cx >= N || cy >= N) break;
                const ck = next[cy][cx];
                if (!blocked.has(ck)) next[cy][cx] = "stone";
                const d = dirs[(rngUtil.n2(seedU32, 84900 + x + i, 85000 + y + i) * dirs.length) | 0];
                cx = clamp(cx + d[0], 0, N - 1);
                cy = clamp(cy + d[1], 0, N - 1);
              }
            }
          }
        }
        return next;
      }

      function isMountainousBiome(biome, biomeAllowsFeature) {
        if (biomeAllowsFeature?.(biome, "mountain", 0.35)) return true;
        if (biomeAllowsFeature?.(biome, "ridge", 0.45)) return true;
        const name = String(biome?.name ?? biome).toLowerCase();
        return name.includes("mountain") || name.includes("highland");
      }

      function applyVolcanicPeakFlow(
        seedU32,
        tileKeyGrid,
        heightGrid,
        depthGrid,
        N,
        biome,
        biomeAllowsFeature,
        worldMeta,
        roadCells,
      ) {
        if (!isMountainousBiome(biome, biomeAllowsFeature)) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const protectedCells = new Set();
        if (worldMeta?.annotations) {
          for (const cell of worldMeta.annotations.keys())
            protectedCells.add(cell);
        }

        let maxH = 0;
        const candidates = [];
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") continue;
            const cell = `${x},${y}`;
            if (protectedCells.has(cell)) continue;
            const h = heightGrid[y][x] || 0;
            if (h > maxH) {
              maxH = h;
              candidates.length = 0;
              candidates.push({ x, y });
            } else if (h === maxH) {
              candidates.push({ x, y });
            }
          }
        }
        if (maxH < 4 || !candidates.length) return tileKeyGrid;

        const pick =
          candidates[
            Math.floor(
              rngUtil.n2(seedU32, 86200, 86300) * candidates.length,
            )
          ];
        if (!pick) return tileKeyGrid;

        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];
        const maxLen =
          10 + ((rngUtil.n2(seedU32, 86400, 86500) * 10) | 0);
        const startWidth =
          1 + ((rngUtil.n2(seedU32, 86450, 86550) * 3) | 0);
        let cx = pick.x;
        let cy = pick.y;
        let onLandSteps = 0;
        const flowSteps = [];
        const placementDepth = new Map();

        const seedStep = () => {
          const curH = heightGrid[cy][cx] || 0;
          let bestH = Infinity;
          const best = [];
          for (const [dx, dy] of dirs) {
            const nx = cx + dx;
            const ny = cy + dy;
            if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;
            const cell = `${nx},${ny}`;
            if (protectedCells.has(cell)) continue;
            if (roadCells?.has(cell)) continue;
            const nk = tileKeyGrid[ny][nx];
            if (nk === "water") continue;
            const nh = nk === "mountain" ? heightGrid[ny][nx] || 0 : 0;
            if (nh > curH) continue;
            if (nh < bestH) {
              bestH = nh;
              best.length = 0;
              best.push({ x: nx, y: ny, k: nk, h: nh });
            } else if (nh === bestH) {
              best.push({ x: nx, y: ny, k: nk, h: nh });
            }
          }
          if (!best.length) return false;
          const pickIdx = Math.floor(
            rngUtil.n2(seedU32, 86520, 86580) * best.length,
          );
          const step = best[pickIdx] || best[0];
          cx = step.x;
          cy = step.y;
          return true;
        };
        if (!seedStep()) return tileKeyGrid;
        const mouthCell = `${cx},${cy}`;

        for (let i = 0; i < maxLen; i++) {
          const curCell = `${cx},${cy}`;
          if (protectedCells.has(curCell)) break;
          if (roadCells?.has(curCell)) break;
          const width = clamp(
            Math.round(startWidth * (1 - (i / Math.max(1, maxLen - 1)) * 0.7)),
            1,
            startWidth,
          );
          flowSteps.push({ x: cx, y: cy, width });
          if (width > 1) {
            const orth = [
              [0, -1],
              [1, 0],
              [0, 1],
              [-1, 0],
            ];
            for (let w = 1; w <= width - 1; w++) {
              const [ox, oy] = orth[w % orth.length];
              const sx = cx + ox;
              const sy = cy + oy;
              if (sx < 0 || sy < 0 || sx >= N || sy >= N) continue;
              const scell = `${sx},${sy}`;
              if (protectedCells.has(scell)) continue;
              if (roadCells?.has(scell)) continue;
              if (tileKeyGrid[sy][sx] === "water") continue;
              placementDepth.set(scell, placementDepth.get(scell) || 0);
            }
          }

          const curH =
            tileKeyGrid[cy][cx] === "mountain" ? heightGrid[cy][cx] || 0 : 0;
          let bestH = Infinity;
          const best = [];
          for (const [dx, dy] of dirs) {
            const nx = cx + dx;
            const ny = cy + dy;
            if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;
            const cell = `${nx},${ny}`;
            if (protectedCells.has(cell)) continue;
            if (roadCells?.has(cell)) continue;
            const nk = tileKeyGrid[ny][nx];
            if (nk === "water") continue;
            const nh = nk === "mountain" ? heightGrid[ny][nx] || 0 : 0;
            if (nh < bestH) {
              bestH = nh;
              best.length = 0;
              best.push({ x: nx, y: ny, k: nk, h: nh });
            } else if (nh === bestH) {
              best.push({ x: nx, y: ny, k: nk, h: nh });
            }
          }
          if (!best.length) break;

          const pickIdx = Math.floor(
            rngUtil.n2(seedU32, 86600 + i, 86700 + i) * best.length,
          );
          const step = best[pickIdx] || best[0];
          if (!step) break;
          cx = step.x;
          cy = step.y;

          if (step.k !== "mountain") onLandSteps++;
          if (onLandSteps >= 4) break;
          if (step.k !== "mountain" && step.h <= curH) {
            const tailKey = `${cx},${cy}`;
            placementDepth.set(tailKey, Math.max(placementDepth.get(tailKey) || 0, 1));
          }
          if (step.h > curH && curH > 0) break;
        }

        if (flowSteps.length) {
          const stepCount = flowSteps.length;
          const bandDepth = (idx) => {
            if (stepCount === 1) return 3;
            const t = idx / (stepCount - 1);
            if (t < 1 / 3) return 3;
            if (t < 2 / 3) return 2;
            return 1;
          };
          for (let i = 0; i < flowSteps.length; i++) {
            const step = flowSteps[i];
            const centerKey = `${step.x},${step.y}`;
            const depth = bandDepth(i);
            placementDepth.set(
              centerKey,
              Math.max(placementDepth.get(centerKey) || 0, depth),
            );
            if (step.width > 1) {
              for (const [dx, dy] of [
                [0, -1],
                [1, 0],
                [0, 1],
                [-1, 0],
              ]) {
                const sx = step.x + dx;
                const sy = step.y + dy;
                if (sx < 0 || sy < 0 || sx >= N || sy >= N) continue;
                const scell = `${sx},${sy}`;
                if (!placementDepth.has(scell)) continue;
                placementDepth.set(
                  scell,
                  Math.max(
                    placementDepth.get(scell) || 0,
                    Math.max(1, depth - 1),
                  ),
                );
              }
            }
          }
          for (const [cell, d] of placementDepth.entries()) {
            const p = parseCell(cell);
            if (!p) continue;
            next[p.y][p.x] = "lava";
            if (depthGrid?.[p.y]) depthGrid[p.y][p.x] = clamp(d, 1, 3);
          }
        }

        if (worldMeta?.annotations) {
          let a = worldMeta.annotations.get(mouthCell);
          if (!a) {
            a = { poi: [], factions: [] };
            worldMeta.annotations.set(mouthCell, a);
          }
          a.poi.push({ name: "Volcano", type: "volcano" });
          if (worldMeta.poiPlacements) {
            const already =
              worldMeta.poiPlacements.some(
                (p) => p.poiType === "volcano" && p.cell === mouthCell,
              ) || false;
            if (!already)
              worldMeta.poiPlacements.push({
                poiType: "volcano",
                poiName: "Volcano",
                cell: mouthCell,
              });
          }
        }

        return next;
      }

      function applyVolcanicPeakPool(
        seedU32,
        tileKeyGrid,
        heightGrid,
        depthGrid,
        N,
        biome,
        biomeAllowsFeature,
        worldMeta,
        roadCells,
      ) {
        if (!isMountainousBiome(biome, biomeAllowsFeature)) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const protectedCells = new Set();
        if (worldMeta?.annotations) {
          for (const cell of worldMeta.annotations.keys())
            protectedCells.add(cell);
        }

        let maxH = 0;
        const candidates = [];
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") continue;
            const cell = `${x},${y}`;
            if (protectedCells.has(cell)) continue;
            if (roadCells?.has(cell)) continue;
            const h = heightGrid[y][x] || 0;
            if (h < 4) continue;
            let surrounded = true;
            for (let dy = -3; dy <= 3 && surrounded; dy++) {
              for (let dx = -3; dx <= 3; dx++) {
                const dist = Math.abs(dx) + Math.abs(dy);
                if (dist !== 3) continue;
                const nx = x + dx;
                const ny = y + dy;
                if (nx < 0 || ny < 0 || nx >= N || ny >= N) {
                  surrounded = false;
                  break;
                }
                if (tileKeyGrid[ny][nx] !== "mountain") {
                  surrounded = false;
                  break;
                }
                const nh = heightGrid[ny][nx] || 0;
                if (nh < h - 1 || nh > h) {
                  surrounded = false;
                  break;
                }
              }
            }
            if (!surrounded) continue;
            if (h > maxH) {
              maxH = h;
              candidates.length = 0;
              candidates.push({ x, y });
            } else if (h === maxH) {
              candidates.push({ x, y });
            }
          }
        }
        if (maxH < 4 || !candidates.length) return tileKeyGrid;

        const pick =
          candidates[
            Math.floor(
              rngUtil.n2(seedU32, 87200, 87300) * candidates.length,
            )
          ];
        if (!pick) return tileKeyGrid;

        const radius = 2;
        for (let dy = -radius; dy <= radius; dy++) {
          for (let dx = -radius; dx <= radius; dx++) {
            const nx = pick.x + dx;
            const ny = pick.y + dy;
            if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;
            const cell = `${nx},${ny}`;
            if (protectedCells.has(cell)) continue;
            if (roadCells?.has(cell)) continue;
            const dist = Math.abs(dx) + Math.abs(dy);
            if (dist > radius) continue;
            next[ny][nx] = "lava";
            if (depthGrid?.[ny]) {
              depthGrid[ny][nx] = dist <= 1 ? 3 : 2;
            }
          }
        }

        return next;
      }

      /* ====================== Mountain height via distance-to-non-mountain ====================== */
      function distToNonMountain(tileKeyGrid, N) {
        const INF = 1e9;
        const dist = Array.from({ length: N }, () => Array(N).fill(INF));

        const qx = new Int16Array(N * N);
        const qy = new Int16Array(N * N);
        let head = 0,
          tail = 0;

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") {
              dist[y][x] = 0;
              qx[tail] = x;
              qy[tail] = y;
              tail++;
            }
          }
        }

        while (head < tail) {
          const x = qx[head],
            y = qy[head];
          head++;
          const d = dist[y][x];

          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (dist[ny][nx] > d + 1) {
              dist[ny][nx] = d + 1;
              qx[tail] = nx;
              qy[tail] = ny;
              tail++;
            }
          }
        }
        return dist;
      }

      function buildHeightGrid(tileKeyGrid, N) {
        const dist = distToNonMountain(tileKeyGrid, N);
        const heightGrid = Array.from({ length: N }, () => Array(N).fill(0));
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") continue;
            const d = dist[y][x];
            const h = 1 + Math.floor((d - 1) * 2.2);
            heightGrid[y][x] = clamp(h, 1, 5);
          }
        }
        return heightGrid;
      }

      function mountainGlyph(h, tileset) {
        return (
          tileset.mountain.height[h] ||
          tileset.mountain.height[1] ||
          firstBaseGlyph(tileset.mountain) ||
          firstBaseGlyph(tileset.plains, "?")
        );
      }

      function applyDunePatches(seedU32, tileKeyGrid, N, rarity) {
        if (rarity <= 0) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x3e9b1d2f);
        const patches = Math.max(1, Math.floor(1 + rarity * 4));
        const totalCells = Math.floor(N * N * (0.05 + rarity * 0.12));
        const stepsPerPatch = Math.max(10, Math.floor(totalCells / patches));
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];

        const pickStart = () => {
          for (let tries = 0; tries < 100; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (k !== "water" && k !== "mountain" && k !== "settlement")
              return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          let { x, y } = pickStart();
          for (let i = 0; i < stepsPerPatch; i++) {
            if (x < 0 || x >= N || y < 0 || y >= N) break;
            const k = next[y][x];
            if (k !== "water" && k !== "mountain" && k !== "settlement")
              next[y][x] = "desert";
            const d = dirs[(rand() * dirs.length) | 0];
            if (rand() < 0.2) {
              x = clamp(x + d[0] + (rand() < 0.5 ? d[0] : 0), 0, N - 1);
              y = clamp(y + d[1] + (rand() < 0.5 ? d[1] : 0), 0, N - 1);
            } else {
              x = clamp(x + d[0], 0, N - 1);
              y = clamp(y + d[1], 0, N - 1);
            }
          }
        }

        return next;
      }

      // TODO: chance for bigger oasis to spawn
      function applyOasisPatches(seedU32, tileKeyGrid, N, rarity) {
        const oasisVeg = new Set();
        if (rarity <= 0) return { grid: tileKeyGrid, oasisVeg };
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x7f4a7c1b);
        const patches = Math.max(1, Math.floor(1 + rarity * 3));
        const maxRadius = 1 + Math.floor(rarity * 2);

        const pickStart = () => {
          for (let tries = 0; tries < 120; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (k !== "water" && k !== "mountain" && k !== "settlement")
              return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          const { x: cx, y: cy } = pickStart();
          const bigBonus = rand() < 0.35 ? 1 : 0;
          const r = 1 + ((rand() * maxRadius) | 0) + bigBonus;

          for (let y = cy - r - 2; y <= cy + r + 2; y++) {
            for (let x = cx - r - 2; x <= cx + r + 2; x++) {
              if (x < 0 || x >= N || y < 0 || y >= N) continue;
              const dx = x - cx;
              const dy = y - cy;
              const dist = Math.abs(dx) + Math.abs(dy);
              if (dist > r + 2) continue;
              const k = next[y][x];
              if (k === "mountain" || k === "settlement") continue;
              if (dist <= r) {
                next[y][x] = "water";
              } else if (k !== "water") {
                if (dist === r + 2 && rand() < 0.4) continue;
                next[y][x] =
                  rand() < (dist === r + 2 ? 0.7 : 0.6) ? "grass" : "forest";
                oasisVeg.add(`${x},${y}`);
              }
            }
          }
        }

        return { grid: next, oasisVeg };
      }

      function applyMyceliumPatches(seedU32, tileKeyGrid, N, rarity) {
        if (rarity <= 0) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x91a2f5c3);
        const patches = Math.max(1, Math.floor(1 + rarity * 4));
        const totalCells = Math.floor(
          N * N * Math.min(0.95, 0.04 + rarity * 0.35),
        );
        const sizeBoost = 1 + rarity * 1.2;
        const stepsPerPatch = Math.max(
          12,
          Math.floor((totalCells / patches) * sizeBoost),
        );
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
          [1, 1],
          [-1, 1],
          [1, -1],
          [-1, -1],
        ];

        const isBlocked = (k) =>
          k === "water" ||
          k === "lava" ||
          k === "mountain" ||
          k === "desert";
        const fungalVariant = (k) => {
          if (k === "settlement")
            return rand() < 1 / 3 ? "fungal-settlement" : null;
          if (k === "ruins") return rand() < 0.6 ? "fungal-ruins" : null;
          if (k === "fungal-settlement" || k === "fungal-ruins") return k;
          return null;
        };

        const pickStart = () => {
          for (let tries = 0; tries < 140; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (k === "forest") return { x, y };
            if (!isBlocked(k) && rand() < 0.65) return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          let { x, y } = pickStart();
          const stepsThisPatch = Math.max(
            10,
            Math.floor(stepsPerPatch * (0.75 + rand() * 0.6)),
          );
          for (let i = 0; i < stepsThisPatch; i++) {
            if (x < 0 || x >= N || y < 0 || y >= N) break;
            const k = next[y][x];
            const fungal = fungalVariant(k);
            if (fungal) {
              next[y][x] = fungal;
            } else if (k === "settlement") {
              // Leave settlement as-is (2/3 chance) and keep walking.
            } else if (k === "ruins") {
              // Leave ruins as-is (1/2 chance) and keep walking.
            } else if (!isBlocked(k)) {
              next[y][x] = "mycelium";
            }
            const d = dirs[(rand() * dirs.length) | 0];
            if (rand() < 0.25) {
              x = clamp(x + d[0] + (rand() < 0.5 ? d[0] : 0), 0, N - 1);
              y = clamp(y + d[1] + (rand() < 0.5 ? d[1] : 0), 0, N - 1);
            } else {
              x = clamp(x + d[0], 0, N - 1);
              y = clamp(y + d[1], 0, N - 1);
            }
          }
        }

        return next;
      }

      function applyCrystalPatches(seedU32, tileKeyGrid, N, rarity) {
        if (rarity <= 0) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x1b873593);
        const patches = Math.max(1, Math.floor(1 + rarity * 4));
        const totalCells = Math.floor(
          N * N * Math.min(0.85, 0.03 + rarity * 0.22),
        );
        const stepsPerPatch = Math.max(10, Math.floor(totalCells / patches));
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
          [1, 1],
          [-1, 1],
          [1, -1],
          [-1, -1],
        ];

        const isBlocked = (k) =>
          k === "water" ||
          k === "lava" ||
          k === "mountain" ||
          k === "settlement" ||
          k === "fungal-settlement" ||
          k === "ruins" ||
          k === "fungal-ruins";

        const pickStart = () => {
          for (let tries = 0; tries < 140; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (isBlocked(k)) continue;
            if (k === "forest" && rand() < 0.45) continue;
            return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          let { x, y } = pickStart();
          const stepsThisPatch = Math.max(
            10,
            Math.floor(stepsPerPatch * (0.75 + rand() * 0.7)),
          );
          for (let i = 0; i < stepsThisPatch; i++) {
            if (x < 0 || x >= N || y < 0 || y >= N) break;
            const k = next[y][x];
            if (!isBlocked(k)) {
              if (k !== "forest" || rand() < 0.55) next[y][x] = "crystal";
            }
            const d = dirs[(rand() * dirs.length) | 0];
            if (rand() < 0.25) {
              x = clamp(x + d[0] + (rand() < 0.5 ? d[0] : 0), 0, N - 1);
              y = clamp(y + d[1] + (rand() < 0.5 ? d[1] : 0), 0, N - 1);
            } else {
              x = clamp(x + d[0], 0, N - 1);
              y = clamp(y + d[1], 0, N - 1);
            }
          }
        }

        return next;
      }

      function applyBeachPatches(seedU32, tileKeyGrid, depthGrid, N) {
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x2b9f5ac1);
        const centers = [];

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            const k = tileKeyGrid[y][x];
            if (k !== "plains") continue;
            let shallowNeighbor = false;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (
                tileKeyGrid[ny][nx] === "water" &&
                (depthGrid?.[ny]?.[nx] || 1) === 1
              ) {
                shallowNeighbor = true;
                break;
              }
            }
            if (!shallowNeighbor) continue;
            if (rand() < 0.38) centers.push({ x, y });
          }
        }

        const touchesShallowWater = (x, y) => {
          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (
              tileKeyGrid[ny][nx] === "water" &&
              (depthGrid?.[ny]?.[nx] || 1) === 1
            )
              return true;
          }
          return false;
        };

        for (const c of centers) {
          const r = 2 + ((rand() * 4) | 0);
          for (let y = c.y - r - 1; y <= c.y + r + 1; y++) {
            for (let x = c.x - r - 1; x <= c.x + r + 1; x++) {
              if (x < 0 || x >= N || y < 0 || y >= N) continue;
              const k = next[y][x];
              if (k !== "plains") continue;
              const dist = Math.abs(x - c.x) + Math.abs(y - c.y);
              if (dist > r) continue;
              if (dist === r && rand() < 0.35) continue;
              if (!touchesShallowWater(x, y)) continue;
              next[y][x] = "beach";
            }
          }
        }

        return next;
      }

      function applyRuinsClusters(
        seedU32,
        tileKeyGrid,
        N,
        ruinCenters,
        rarity,
      ) {
        if (!Array.isArray(ruinCenters) || !ruinCenters.length || rarity <= 0)
          return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());

        const rand = rngUtil.xs32(seedU32 ^ 0x33b5c5a9);
        const hasMyceliumNeighbor = (x, y) => {
          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (next[ny][nx] === "mycelium") return true;
          }
          return false;
        };

        for (const center of ruinCenters) {
          const parts = String(center?.cell || "").split(",");
          const cx = Number(parts[0]);
          const cy = Number(parts[1]);
          if (!Number.isFinite(cx) || !Number.isFinite(cy)) continue;
          const k = next[cy]?.[cx];
          if (
            !k ||
            k === "water" ||
            k === "lava" ||
            k === "settlement" ||
            k === "fungal-settlement" ||
            k === "fungal-ruins"
          )
            continue;
          const nearMycelium =
            k === "mycelium" || hasMyceliumNeighbor(cx, cy);
          next[cy][cx] = nearMycelium && rand() < 0.6 ? "fungal-ruins" : "ruins";
        }

        return next;
      }

      function applyOvergrownRuins(seedU32, tileKeyGrid, N, climate) {
        const rainIdx = clamp((climate?.rainIdx ?? 3) + 1, 1, 8);
        if (rainIdx < 6) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x6fbd1d97);
        const chance = 0.75;

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (next[y][x] === "ruins" && rand() < chance) {
              next[y][x] = "overgrown-ruins";
            }
          }
        }

        return next;
      }

      /* ====================== Forest typing (biome + climate) ====================== */
      function forestTypeForCell(
        seedU32,
        x,
        y,
        biome,
        climate,
        oasisVeg,
        biomeAllowsFeature,
      ) {
        const s = String(biome || "").toLowerCase();
        const tempTier = clamp(climate?.tempTier ?? 4, 1, 8);
        const rainIdx = clamp((climate?.rainIdx ?? 3) + 1, 1, 8);

        const isDeadBiome = biomeAllowsFeature(biome, "dead trees", 0.2);

        const isColdBiome =
          s.includes("tundra") ||
          s.includes("taiga") ||
          s.includes("ice") ||
          s.includes("highland");
        const isWetBiome =
          s.includes("wetland") ||
          s.includes("bog") ||
          s.includes("marsh") ||
          s.includes("floodplain") ||
          s.includes("jungle") ||
          s.includes("oceanic") ||
          s.includes("tidal") ||
          s.includes("canal") ||
          s.includes("lagoon") ||
          s.includes("reef");

        if (isDeadBiome) {
          if (oasisVeg?.has(`${x},${y}`)) return "deciduous";
          const roll = rngUtil.n2(seedU32, 70000 + x, 70100 + y);
          if (rainIdx >= 6 && roll < 0.18) return "deciduous";
          return "dead";
        }

        if (isColdBiome || tempTier <= 3) return "coniferous";

        if (isWetBiome) {
          if (oasisVeg?.has(`${x},${y}`)) return "deciduous";
          const roll = rngUtil.n2(seedU32, 70150 + x, 70175 + y);
          return roll < 0.9 ? "deciduous" : "coniferous";
        }

        if (tempTier >= 7 && rainIdx <= 2) {
          if (oasisVeg?.has(`${x},${y}`)) return "deciduous";
          if (isDeadBiome) {
            const roll = rngUtil.n2(seedU32, 70200 + x, 70300 + y);
            return roll < 0.6 ? "dead" : "deciduous";
          }
          return "dead";
        }

        if (rainIdx >= 6 && tempTier >= 5) return "deciduous";

        const roll = rngUtil.n2(seedU32, 70400 + x, 70500 + y);
        return roll < 0.18 ? "coniferous" : "deciduous";
      }

      function forestGlyphForType(ft, seed01, tileset) {
        const t = tileset.forest;
        const list =
          ft === "coniferous"
            ? t.coniferous
            : ft === "dead"
              ? t.dead
              : ft === "deciduous"
                ? t.deciduous
                : baseGlyphs(t);
        const idx = Math.floor(seed01 * list.length);
        return list[idx] || firstBaseGlyph(t, "?");
      }

      function initGrid(N, fill = "plains") {
        return Array.from({ length: N }, () => Array(N).fill(fill));
      }

      function maybeApplyMountainBias(seedU32, weights, normalizeWeights) {
        const mountainBias = rngUtil.n2(seedU32, 90500, 90600) < 0.3;
        if (!mountainBias) return weights;
        weights.mountain = Math.max(0.01, weights.mountain * 1.7);
        weights.plains *= 0.85;
        weights.grass *= 0.85;
        weights.forest *= 0.85;
        weights.water *= 0.9;
        normalizeWeights(weights);
        return weights;
      }

      function buildRiver(seedU32, biome, N, biomeAllowsFeature) {
        const riverType = biomeAllowsFeature(biome, "river-lava")
          ? "lava"
          : biomeAllowsFeature(biome, "river-water")
            ? "water"
            : null;
        const river =
          riverType && rngUtil.n2(seedU32, 42000, 43000) > 0.35
            ? riverCells(seedU32 ^ 0x9e3779b9, N)
            : new Set();
        return { riverType, river };
      }

      function applyInitialTiles(
        seedU32,
        tileKeyGrid,
        weights,
        N,
        riverType,
        river,
        pickByWeights,
      ) {
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            let tileKey;
            if (riverType && river.has(`${x},${y}`)) {
              tileKey = riverType;
            } else {
              const r0 = rngUtil.n2(seedU32, x, y);
              tileKey = pickByWeights(r0, weights);
              if (
                tileKey !== "water" &&
                rngUtil.n2(seedU32, 7000 + x, 8000 + y) > 0.985
              )
                tileKey = "settlement";
            }
            next[y][x] = tileKey;
          }
        }
        return next;
      }

      function desertAllEnabled(seedU32, biome) {
        if (
          !String(biome || "")
            .toLowerCase()
            .includes("desert")
        )
          return false;
        return rngUtil.n2(seedU32, 4242, 31337) < 0.5;
      }

      function applyDesertAll(tileKeyGrid, N, desertAll) {
        if (!desertAll) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (next[y][x] === "plains") next[y][x] = "desert";
          }
        }
        return next;
      }

      function thinDesertForests(
        seedU32,
        tileKeyGrid,
        N,
        biome,
        climate,
        oasisVeg = null,
      ) {
        if (
          !String(biome || "")
            .toLowerCase()
            .includes("desert")
        )
          return tileKeyGrid;
        const rainIdx = clamp(climate?.rainIdx ?? 3, 0, 7);
        const isArid = rainIdx <= 1;
        const thinChance = isArid ? 0.75 : 0.55;
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "forest") continue;
            if (oasisVeg?.has(`${x},${y}`)) continue;
            const roll = rngUtil.n2(seedU32, 75000 + x, 76000 + y);
            if (roll < thinChance) next[y][x] = "desert";
          }
        }
        return next;
      }

      function boostMountainHeights(heightGrid, tileKeyGrid, N, ridgeRarity) {
        if (!Number.isFinite(ridgeRarity) || ridgeRarity <= 0)
          return heightGrid;
        const next = heightGrid.map((row) => row.slice());
        const heightBoost = 1 + ridgeRarity * 0.6;
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") continue;
            next[y][x] = clamp(Math.round(next[y][x] * heightBoost), 1, 5);
          }
        }
        return next;
      }

      function buildForestTypeGrid(
        seedU32,
        tileKeyGrid,
        N,
        biome,
        climate,
        oasisVeg,
        biomeAllowsFeature,
      ) {
        const forestTypeGrid = Array.from({ length: N }, () =>
          Array(N).fill(null),
        );
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] === "forest") {
              forestTypeGrid[y][x] = forestTypeForCell(
                seedU32,
                x,
                y,
                biome,
                climate,
                oasisVeg,
                biomeAllowsFeature,
              );
            }
          }
        }
        return forestTypeGrid;
      }

      function parseCell(cell) {
        const parts = String(cell || "").split(",");
        const x = Number(parts[0]);
        const y = Number(parts[1]);
        if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
        return { x, y };
      }

      function manhattanCell(a, b) {
        const pa = parseCell(a);
        const pb = parseCell(b);
        if (!pa || !pb) return Infinity;
        return Math.abs(pa.x - pb.x) + Math.abs(pa.y - pb.y);
      }

      function isMountainPass(tileKeyGrid, heightGrid, x, y) {
        if (tileKeyGrid[y][x] !== "mountain") return false;
        const h = clamp(heightGrid[y][x] || 1, 1, 5);
        return h <= 2;
      }

      function isAdjacentTo(tileKeyGrid, N, x, y, key) {
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (!dx && !dy) continue;
            const nx = x + dx;
            const ny = y + dy;
            if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
            if (tileKeyGrid[ny][nx] === key) return true;
          }
        }
        return false;
      }

      function isAdjacentRoad(roadCells, N, x, y) {
        if (!roadCells) return false;
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];
        for (const [dx, dy] of dirs) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
          if (roadCells.has(`${nx},${ny}`)) return true;
        }
        return false;
      }

      function roadGlyph(roadCells, N, x, y) {
        const has = (dx, dy) => {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || nx >= N || ny < 0 || ny >= N) return false;
          return roadCells.has(`${nx},${ny}`);
        };
        const n = has(0, -1);
        const s = has(0, 1);
        const w = has(-1, 0);
        const e = has(1, 0);

        const g = tileset.road?.glyphs || {};
        if (n && s && w && e) return g.nsew || "â•¬";
        if (n && s && w) return g.nsw || "â•£";
        if (n && s && e) return g.nse || "â• ";
        if (n && w && e) return g.nwe || "â•©";
        if (s && w && e) return g.swe || "â•¦";
        if (n && s) return g.ns || "â•‘";
        if (w && e) return g.we || "â•";
        if (n && e) return g.ne || "â•š";
        if (n && w) return g.nw || "â•";
        if (s && e) return g.se || "â•”";
        if (s && w) return g.sw || "â•—";
        if (n) return g.n || "â•‘";
        if (s) return g.s || "â•‘";
        if (w) return g.w || "â•";
        if (e) return g.e || "â•";
        return g.we || "â•";
      }

      function isPassable(tileKeyGrid, x, y) {
        const k = tileKeyGrid[y][x];
        return k !== "water" && k !== "lava";
      }

      function terrainCost(
        tileKeyGrid,
        heightGrid,
        depthGrid,
        x,
        y,
        roadCells,
        allowWater = false,
      ) {
        const k = tileKeyGrid[y][x];
        if (k === "lava") return Infinity;
        let cost = 1;
        if (k === "water") {
          if (!allowWater) return Infinity;
          const d = clamp(depthGrid?.[y]?.[x] || 1, 1, 3);
          cost = d === 1 ? 6 : d === 2 ? 14 : 22;
        } else if (k === "mountain") {
          const h = clamp(heightGrid[y][x] || 1, 1, 5);
          cost = h <= 2 ? 4 : h === 3 ? 12 : 30;
        } else if (k === "forest") {
          cost = 1.6;
        } else if (k === "desert") {
          cost = 1.4;
        } else if (k === "beach") {
          cost = 1.2;
        } else if (k === "mycelium") {
          cost = 1.5;
        } else if (k === "crystal") {
          cost = 1.5;
        } else if (k === "ruins" || k === "overgrown-ruins") {
          cost = 1.3;
        } else if (k === "grass") {
          cost = 1.1;
        }
        if (roadCells?.has(`${x},${y}`)) cost *= 0.7;
        const N = tileKeyGrid.length;
        if (!roadCells?.has(`${x},${y}`) && isAdjacentRoad(roadCells, N, x, y))
          cost *= 1.2;
        if (isAdjacentTo(tileKeyGrid, N, x, y, "water")) cost *= 0.85;
        if (
          isAdjacentTo(tileKeyGrid, N, x, y, "forest") ||
          isAdjacentTo(tileKeyGrid, N, x, y, "mycelium")
        )
          cost *= 0.9;
        return cost;
      }

      function weightedPick(rand, items) {
        let sum = 0;
        for (const it of items) sum += it.w;
        let t = rand() * sum;
        for (const it of items) {
          t -= it.w;
          if (t <= 0) return it;
        }
        return items[items.length - 1];
      }

      function aStarPath(
        startCell,
        goalCell,
        N,
        tileKeyGrid,
        heightGrid,
        depthGrid,
        roadCells,
        { allowWater = false } = {},
      ) {
        if (!startCell || !goalCell) return null;
        if (startCell === goalCell) return [startCell];

        const start = parseCell(startCell);
        const goal = parseCell(goalCell);
        if (!start || !goal) return null;

        const idx = (x, y) => y * N + x;
        const startIdx = idx(start.x, start.y);
        const goalIdx = idx(goal.x, goal.y);

        const gScore = new Array(N * N).fill(Infinity);
        const fScore = new Array(N * N).fill(Infinity);
        const cameFrom = new Array(N * N).fill(-1);

        const heuristic = (x, y) =>
          Math.abs(x - goal.x) + Math.abs(y - goal.y);

        gScore[startIdx] = 0;
        fScore[startIdx] = heuristic(start.x, start.y);

        const open = [startIdx];
        const openSet = new Set([startIdx]);

        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];

        while (open.length) {
          let bestIndex = 0;
          let best = open[0];
          let bestScore = fScore[best];
          for (let i = 1; i < open.length; i++) {
            const candidate = open[i];
            const score = fScore[candidate];
            if (score < bestScore) {
              bestScore = score;
              best = candidate;
              bestIndex = i;
            }
          }
          open.splice(bestIndex, 1);
          openSet.delete(best);

          if (best === goalIdx) {
            const path = [];
            let cur = best;
            while (cur >= 0) {
              const cx = cur % N;
              const cy = (cur / N) | 0;
              path.push(`${cx},${cy}`);
              cur = cameFrom[cur];
            }
            return path.reverse();
          }

          const cx = best % N;
          const cy = (best / N) | 0;
          for (const [dx, dy] of dirs) {
            const nx = cx + dx;
            const ny = cy + dy;
            if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
            let stepCost = terrainCost(
              tileKeyGrid,
              heightGrid,
              depthGrid,
              nx,
              ny,
              roadCells,
              allowWater,
            );
            if (!Number.isFinite(stepCost)) continue;
            const nidx = idx(nx, ny);
            const tentative = gScore[best] + stepCost;
            if (tentative < gScore[nidx]) {
              cameFrom[nidx] = best;
              gScore[nidx] = tentative;
              fScore[nidx] = tentative + heuristic(nx, ny);
              if (!openSet.has(nidx)) {
                openSet.add(nidx);
                open.push(nidx);
              }
            }
          }
        }
        return null;
      }

      function buildRoadNetwork(
        seedU32,
        tileKeyGrid,
        heightGrid,
        depthGrid,
        worldMeta,
        N,
      ) {
        if (!worldMeta) return { cells: new Set(), kindByCell: new Map() };
        const settlements = Array.from(worldMeta.settlementNameByCell.keys());
        const pois = (worldMeta.poiPlacements || []).map((p) => p.cell);
        if (!settlements.length && !pois.length)
          return { cells: new Set(), kindByCell: new Map() };

        const roadCells = new Set();
        const roadKindByCell = new Map();
        const edges = [];
        const edgeSet = new Set();

        const findNearestPassable = (cell, maxRadius = 4) => {
          const p = parseCell(cell);
          if (!p) return null;
          if (isPassable(tileKeyGrid, p.x, p.y)) return cell;
          for (let r = 1; r <= maxRadius; r++) {
            for (let dy = -r; dy <= r; dy++) {
              for (let dx = -r; dx <= r; dx++) {
                if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
                const nx = p.x + dx;
                const ny = p.y + dy;
                if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
                if (isPassable(tileKeyGrid, nx, ny)) return `${nx},${ny}`;
              }
            }
          }
          return null;
        };

        const addEdge = (a, b) => {
          if (!a || !b || a === b) return;
          const key = a < b ? `${a}|${b}` : `${b}|${a}`;
          if (edgeSet.has(key)) return;
          edgeSet.add(key);
          edges.push({ a, b });
        };

        if (settlements.length >= 2) {
          const pairs = [];
          for (let i = 0; i < settlements.length; i++) {
            for (let j = i + 1; j < settlements.length; j++) {
              const a = settlements[i];
              const b = settlements[j];
              pairs.push({ a, b, d: manhattanCell(a, b) });
            }
          }
          pairs.sort((p, q) => p.d - q.d);

          const parent = new Map();
          const find = (x) => {
            const p = parent.get(x);
            if (!p || p === x) return x;
            const root = find(p);
            parent.set(x, root);
            return root;
          };
          const unite = (a, b) => {
            const ra = find(a);
            const rb = find(b);
            if (ra !== rb) parent.set(ra, rb);
          };
          for (const s of settlements) parent.set(s, s);

          for (const pair of pairs) {
            if (find(pair.a) !== find(pair.b)) {
              unite(pair.a, pair.b);
              addEdge(pair.a, pair.b);
            }
          }
        }

        for (const poi of pois) {
          if (!settlements.length && pois.length > 1) {
            let best = null;
            let bestD = Infinity;
            for (const other of pois) {
              if (other === poi) continue;
              const d = manhattanCell(poi, other);
              if (d < bestD) {
                bestD = d;
                best = other;
              }
            }
            addEdge(poi, best);
            continue;
          }
          let best = null;
          let bestD = Infinity;
          for (const s of settlements) {
            const d = manhattanCell(poi, s);
            if (d < bestD) {
              bestD = d;
              best = s;
            }
          }
          addEdge(poi, best);
        }

        const markRoadCell = (cell, kind) => {
          const existing = roadKindByCell.get(cell);
          if (existing === "primary" && kind === "secondary") return;
          roadCells.add(cell);
          roadKindByCell.set(cell, kind);
        };

        const ferrySet = new Set();
        const ferries = [];
        const addFerryPoi = (name, cell, ferryId) => {
          let a = worldMeta.annotations.get(cell);
          if (!a) {
            a = { poi: [], factions: [] };
            worldMeta.annotations.set(cell, a);
          }
          if (!a.poi) a.poi = [];
          a.poi.push({ name, type: "ferry", ferryId });
          if (!a.ferryIds) a.ferryIds = [];
          a.ferryIds.push(ferryId);
          worldMeta.poiPlacements.push({
            poiType: "ferry",
            poiName: name,
            cell,
            ferryId,
          });
        };

        const ferryFromPath = (path) => {
          if (!path || path.length < 3) return null;
          let lastLand = null;
          let i = 0;
          const waterRuns = [];

          while (i < path.length) {
            const cell = path[i];
            const p = parseCell(cell);
            if (!p) {
              i++;
              continue;
            }
            const k = tileKeyGrid[p.y][p.x];
            if (k !== "water") {
              lastLand = cell;
              i++;
              continue;
            }

            const startLand = lastLand;
            const runStart = i;
            let deepSeen = false;
            while (i < path.length) {
              const wCell = path[i];
              const wp = parseCell(wCell);
              if (!wp) {
                i++;
                continue;
              }
              const wk = tileKeyGrid[wp.y][wp.x];
              if (wk !== "water") break;
              const d = clamp(depthGrid?.[wp.y]?.[wp.x] || 1, 1, 3);
              if (d >= 2) deepSeen = true;
              i++;
            }
            const runEnd = i - 1;
            const endCell = path[i];
            waterRuns.push({ startLand, endCell, deepSeen, runStart, runEnd });
          }

          if (waterRuns.length !== 1) return null;
          const run = waterRuns[0];
          if (!run.startLand || !run.endCell || !run.deepSeen) return null;
          if (run.runStart <= 0 || run.runEnd >= path.length - 1) return null;
          const startP = parseCell(path[run.runStart - 1]);
          const endP = parseCell(path[run.runEnd + 1]);
          if (!startP || !endP) return null;
          if (tileKeyGrid[startP.y][startP.x] === "water") return null;
          if (tileKeyGrid[endP.y][endP.x] === "water") return null;
          return { start: run.startLand, end: run.endCell };
        };

        const ferryLabels = (aCell, bCell) => {
          const a = parseCell(aCell);
          const b = parseCell(bCell);
          if (!a || !b) return ["north", "south"];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          if (Math.abs(dx) >= Math.abs(dy)) {
            return dx >= 0 ? ["west", "east"] : ["east", "west"];
          }
          return dy >= 0 ? ["north", "south"] : ["south", "north"];
        };

        const stampRoadLandOnly = (path, kind = "primary") => {
          if (!path || !path.length) return;
          for (const cell of path) {
            const p = parseCell(cell);
            if (!p) continue;
            const k = tileKeyGrid[p.y][p.x];
            if (k === "water" || k === "lava") continue;
            markRoadCell(cell, kind);
          }
        };

        for (const edge of edges) {
          const { a, b } = edge;
          const edgeSeed = rngUtil.h32(`${seedU32}|${a}|${b}|road`);
          let path = aStarPath(
            a,
            b,
            N,
            tileKeyGrid,
            heightGrid,
            depthGrid,
            roadCells,
            { allowWater: false },
          );
          if (path && path.length) {
            stampRoadLandOnly(path);
            continue;
          }

          path = aStarPath(
            a,
            b,
            N,
            tileKeyGrid,
            heightGrid,
            depthGrid,
            roadCells,
            { allowWater: true },
          );
          if (!path || !path.length) continue;
          const ferry = ferryFromPath(path);
          if (!ferry) {
            const aLand = findNearestPassable(a);
            const bLand = findNearestPassable(b);
            if (aLand && bLand && aLand !== bLand) {
              const secondaryPath = aStarPath(
                aLand,
                bLand,
                N,
                tileKeyGrid,
                heightGrid,
                depthGrid,
                roadCells,
                { allowWater: true },
              );
              const secondaryFerry = ferryFromPath(secondaryPath);
              if (secondaryFerry) {
                const key =
                  secondaryFerry.start < secondaryFerry.end
                    ? `${secondaryFerry.start}|${secondaryFerry.end}`
                    : `${secondaryFerry.end}|${secondaryFerry.start}`;
                if (!ferrySet.has(key)) {
                  ferrySet.add(key);
                  const ferrySeed = rngUtil.h32(
                    `${seedU32}|${secondaryFerry.start}|${secondaryFerry.end}|ferry`,
                  );
                  const ferryNameGen = new NameGenerator(rngUtil.xs32(ferrySeed));
                  const ferryBase = namedPOI(ferryNameGen, "ferry crossing");
                  const [aLabel, bLabel] = ferryLabels(
                    secondaryFerry.start,
                    secondaryFerry.end,
                  );
                  const ferryId = `ferry-${ferrySet.size}`;
                  addFerryPoi(`${ferryBase} (${aLabel})`, secondaryFerry.start, ferryId);
                  addFerryPoi(`${ferryBase} (${bLabel})`, secondaryFerry.end, ferryId);
                  ferries.push({
                    id: ferryId,
                    start: secondaryFerry.start,
                    end: secondaryFerry.end,
                    path: secondaryPath,
                  });
                }
                stampRoadLandOnly(secondaryPath, "secondary");
                continue;
              }

              const landPath = aStarPath(
                aLand,
                bLand,
                N,
                tileKeyGrid,
                heightGrid,
                depthGrid,
                roadCells,
                { allowWater: false },
              );
              if (landPath && landPath.length) {
                stampRoadLandOnly(landPath);
              }
            }
            continue;
          }

          const key =
            ferry.start < ferry.end
              ? `${ferry.start}|${ferry.end}`
              : `${ferry.end}|${ferry.start}`;
          if (!ferrySet.has(key)) {
            ferrySet.add(key);
            const ferrySeed = rngUtil.h32(
              `${seedU32}|${ferry.start}|${ferry.end}|ferry`,
            );
            const ferryNameGen = new NameGenerator(rngUtil.xs32(ferrySeed));
            const ferryBase = namedPOI(ferryNameGen, "ferry crossing");
            const [aLabel, bLabel] = ferryLabels(ferry.start, ferry.end);
            const ferryId = `ferry-${ferrySet.size}`;
            addFerryPoi(`${ferryBase} (${aLabel})`, ferry.start, ferryId);
            addFerryPoi(`${ferryBase} (${bLabel})`, ferry.end, ferryId);
            ferries.push({ id: ferryId, start: ferry.start, end: ferry.end, path });
          }
          stampRoadLandOnly(path);
        }

        return { cells: roadCells, kindByCell: roadKindByCell, ferries };
      }

      function renderMapHtml(
        seedU32,
        tileKeyGrid,
        depthGrid,
        heightGrid,
        forestTypeGrid,
        N,
        worldMeta,
        tileset,
        pickVariant,
        roadInfo,
      ) {
        const ann = worldMeta?.annotations || new Map();
        const rpick = rngUtil.xs32((seedU32 ^ 0x5a5a5a5a) >>> 0);
        const roadCells = roadInfo?.cells || new Set();
        const roadKindByCell = roadInfo?.kindByCell || new Map();
        const ferries = roadInfo?.ferries || [];
        const ferryIdByCell = new Map();
        const ferryPathByCell = new Map();
        const ferryGlyphByCell = new Map();

        for (const ferry of ferries) {
          if (!ferry?.id || !Array.isArray(ferry.path)) continue;
          ferryIdByCell.set(ferry.start, ferry.id);
          ferryIdByCell.set(ferry.end, ferry.id);
          const pathSet = new Set();
          for (const cell of ferry.path) {
            const p = parseCell(cell);
            if (!p) continue;
            if (tileKeyGrid[p.y][p.x] !== "water") continue;
            pathSet.add(cell);
            ferryPathByCell.set(cell, ferry.id);
          }
          if (!pathSet.size) continue;
          for (const cell of pathSet) {
            const p = parseCell(cell);
            if (!p) continue;
            const glyph = roadGlyph(pathSet, N, p.x, p.y);
            ferryGlyphByCell.set(cell, glyph);
          }
        }

        let s = "";
        for (let y = 0; y < N; y++) {
          let row = "";
          for (let x = 0; x < N; x++) {
            const tileKey = tileKeyGrid[y][x];
            const key = `${x},${y}`;
            const a = ann.get(key);
            const ferryId = ferryIdByCell.get(key);
            const ferryPathId = ferryPathByCell.get(key);
            const ferryGlyph = ferryGlyphByCell.get(key);
            const blocksRoadTile =
              a?.poiStructure ||
              a?.fieldCamp ||
              a?.religious ||
              a?.settlementName ||
              a?.poi?.length ||
              tileKey === "settlement" ||
              tileKey === "camp" ||
              tileKey === "ruins" ||
              tileKey === "overgrown-ruins";
            const hasRoad =
              roadCells?.has(key) &&
              tileKey !== "water" &&
              tileKey !== "lava" &&
              !blocksRoadTile;
            let roadKind = roadKindByCell.get(key) || "primary";
            const roadAttr = hasRoad ? ` data-road="${roadKind}"` : "";
            const ferryAttr = ferryId ? ` data-ferry-id="${ferryId}"` : "";
            const ferryPathAttr = ferryPathId
              ? ` data-ferry-path="${ferryPathId}" data-ferry-glyph="${escAttr(ferryGlyph || "")}"`
              : "";

            const contentParts = [];
            if (tileKey === "water" || tileKey === "lava")
              contentParts.push(
                `depth: ${clamp(depthGrid[y][x] || 1, 1, 3)}`,
              );
            if (tileKey === "mountain")
              contentParts.push(
                `height: ${clamp(heightGrid[y][x] || 1, 1, 5)}`,
              );
            if (hasRoad) {
              const label = "Road";
              contentParts.push(
                isMountainPass(tileKeyGrid, heightGrid, x, y)
                  ? `${label} â€” pass`
                  : label,
              );
            }
            if (tileKey === "forest")
              contentParts.push(`forest: ${forestTypeGrid[y][x] || "mixed"}`);
            if (a?.settlementName) {
              contentParts.push(`${a.settlementType}: ${a.settlementName}`);
            }
            if (a?.fieldCamp) contentParts.push("Field Camp");
            if (a?.poi?.length) {
              for (const p of a.poi) {
                if (a?.religious && p.type === "religious") continue;
                contentParts.push(`POI: ${p.name}`);
              }
            }
            if (a?.religious) contentParts.push(a.religious.label);

            const factionParts = [];
            if (a?.factions?.length)
              for (const f of a.factions)
                factionParts.push(`Faction: ${f.name}`);
            if (a?.factionOps?.length)
              for (const f of a.factionOps)
                factionParts.push(`Faction Activity: ${f.name} â€” ${f.verb}`);

            const npcParts = [];
            if (a?.npcs?.length)
              for (const n of a.npcs)
                npcParts.push(`NPC: ${n.name} â€” ${n.task}`);

            const title = escAttr(
              [
                `${tileKey}    ${x},${y}`,
                ...contentParts,
                ...factionParts,
                ...npcParts,
              ]
                .filter(Boolean)
                .join("\n"),
            );

            const showStructure =
              a?.poiStructure &&
              !a?.fieldCamp &&
              !a?.religious &&
              tileKey !== "water";
            const hasVolcanoPoi =
              a?.poi?.some((p) => p.type === "volcano") || false;
            const showPoi =
              a?.poi?.length &&
              !showStructure &&
              !a?.fieldCamp &&
              !a?.religious &&
              tileKey !== "settlement" &&
              tileKey !== "fungal-settlement" &&
              tileKey !== "ruins" &&
              tileKey !== "overgrown-ruins" &&
              tileKey !== "fungal-ruins" &&
              tileKey !== "water" &&
              !(tileKey === "lava" && hasVolcanoPoi);
            const allowRoadGlyph = hasRoad;

            if (showStructure) {
              const variantSeed = rngUtil.n2(seedU32, x + 999, y + 999);
              const ch = pickVariant("settlement", tileset, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="settlement"${roadAttr}${ferryAttr} data-poi="structure" title="${title}">${ch}</span>`;
            } else if (showPoi) {
              const ferryRef = a?.poi?.find((p) => p.type === "ferry");
              const ferryPickSeed = ferryRef?.ferryId
                ? rngUtil.xs32(rngUtil.h32(ferryRef.ferryId))()
                : null;
              const variantSeed =
                ferryPickSeed ?? rngUtil.n2(seedU32, x + 999, y + 999);
              const ch = pickVariant("poi", tileset, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="poi"${roadAttr}${ferryAttr} data-poi="marker" title="${title}">${ch}</span>`;
            } else if (a?.fieldCamp) {
              const ch =
                rngUtil.oneOf(rpick, baseGlyphs(tileset.camp)) ||
                firstBaseGlyph(tileset.settlement) ||
                firstBaseGlyph(tileset.plains, "?");
              row += `<span data-cell="${x},${y}" data-tile="camp"${roadAttr}${ferryAttr} title="${title}">${ch}</span>`;
            } else if (a?.religious) {
              const rel = a.religious;
              const fallbackRel =
                tileset.religious?.death ||
                tileset.religious?.monastery ||
                firstBaseGlyph(tileset.settlement) ||
                firstBaseGlyph(tileset.plains, "?");
              const ch =
                rngUtil.oneOf(rpick, rel.glyph) || rngUtil.oneOf(rpick, tileset.religious?.[rel.kind]) || fallbackRel;
              row += `<span data-cell="${x},${y}" data-tile="religious"${roadAttr}${ferryAttr} data-religious="${escAttr(rel.kind)}" title="${title}">${ch}</span>`;
            } else if (tileKey === "water" || tileKey === "lava") {
              const d = clamp(depthGrid[y][x] || 1, 1, 3);
              const ch = liquidGlyph(tileKey, d, tileset, seedU32, x, y);
              row += `<span data-cell="${x},${y}" data-tile="${tileKey}"${roadAttr}${ferryAttr}${ferryPathAttr} data-depth="${d}" title="${title}">${ch}</span>`;
            } else if (tileKey === "mountain") {
              const h = clamp(heightGrid[y][x] || 1, 1, 5);
              const ch = allowRoadGlyph
                ? `<span class="road-glyph">${roadGlyph(roadCells, N, x, y)}</span>`
                : mountainGlyph(h, tileset);
              row += `<span data-cell="${x},${y}" data-tile="mountain"${roadAttr}${ferryAttr} data-height="${h}" title="${title}">${ch}</span>`;
            } else if (tileKey === "forest") {
              const ft = forestTypeGrid[y][x] || "mixed";
              const variantSeed = rngUtil.n2(seedU32, x + 999, y + 999);
              const ch = allowRoadGlyph
                ? `<span class="road-glyph">${roadGlyph(roadCells, N, x, y)}</span>`
                : forestGlyphForType(ft, variantSeed, tileset);
              row += `<span data-cell="${x},${y}" data-tile="forest"${roadAttr}${ferryAttr} data-forest="${escAttr(ft)}" title="${title}">${ch}</span>`;
            } else if (tileKey === "crystal") {
              const variantSeed = rngUtil.n2(seedU32, x + 777, y + 777);
              const variants = ["blue", "pink", "green"];
              const v =
                variants[Math.floor(variantSeed * variants.length)] || "blue";
              const ch = allowRoadGlyph
                ? `<span class="road-glyph">${roadGlyph(roadCells, N, x, y)}</span>`
                : pickVariant(tileKey, tileset, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="crystal"${roadAttr}${ferryAttr} data-crystal="${v}" title="${title}">${ch}</span>`;
            } else {
              const variantSeed = rngUtil.n2(seedU32, x + 999, y + 999);
              const stoneAttr =
                tileKey === "stone"
                  ? ` data-stone="${(x + y) % 2 ? 2 : 1}"`
                  : "";
              const ch = allowRoadGlyph
                ? `<span class="road-glyph">${roadGlyph(roadCells, N, x, y)}</span>`
                : pickVariant(tileKey, tileset, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="${tileKey}"${roadAttr}${ferryAttr}${stoneAttr} title="${title}">${ch}</span>`;
            }
          }
          s += row + (y < N - 1 ? "\n" : "");
        }

        return s;
      }

      // #endregion Map Generation
      // #region UI + State
      /* ====================== State, Storage, UI ====================== */
      class UIController {
        constructor(doc, storage, worldBuilder, mapGenerator) {
          this.doc = doc;
          this.storage = storage;
          this.worldBuilder = worldBuilder;
          this.mapGenerator = mapGenerator;
        }

        load() {
          return loadLS();
        }

        save() {
          return saveLS();
        }

        renderLists() {
          return renderLists();
        }

        setCurrentSeed(s, push = true) {
          return setCurrentSeed(s, push);
        }

        generate() {
          return generate();
        }

        bindCrossHover() {
          return bindCrossHover();
        }

        wireEvents() {}
      }

      const $ = (sel) => document.querySelector(sel);
      const out = $("#out"),
        mapEl = $("#map"),
        seedIn = $("#seed"),
        seedShow = $("#seedShow"),
        seedPill = document.querySelector(".seedpill"),
        themeSel = $("#theme"),
        btnGen = $("#gen"),
        btnPrev = $("#prev"),
        btnNext = $("#next"),
        btnCopySeed = $("#copySeed"),
        btnShowAll = $("#showAll"),
        histList = $("#hist"),
        favList = $("#favs"),
        btnClrFav = $("#clrFav"),
        // btnSave = $("#save"),
        // btnCopyOut = $("#copyOut"),
        // btnShare = $("#share"),

        LS_H = "sow_history_v2",
        LS_F = "sow_faves_v2",
        MAXH = 99;

      const ui = new UIController(
        document,
        localStorage,
        worldBuilder,
        mapGenerator,
      );

      let histArr = [],
        faves = [],
        idx = -1,
        current = "";

      let showAllMode = false;
      const SHOW_ALL_COLORS = [
        "var(--sw4)",
        "var(--sw5)",
        "var(--sw6)",
        "var(--sw10)",
        "var(--sw11)",
        "var(--sw2)",
        "var(--sw3)",
        "var(--sw9)",
        "var(--sw7)",
        "var(--sw14)",
        "var(--sw13)",
      ];

      function applyShowAll(active) {
        showAllMode = active;
        document.body.classList.toggle("show-all", active);
        if (btnShowAll) {
          btnShowAll.classList.toggle("is-active", active);
          btnShowAll.setAttribute("aria-pressed", active ? "true" : "false");
        }

        const xrefs = out.querySelectorAll(".xref[data-cell]");
        const mapCells = mapEl.querySelectorAll("span[data-cell]");

        if (active) {
          const colorByCell = new Map();
          let colorIndex = 0;
          xrefs.forEach((el) => {
            const cell = el.dataset.cell || "";
            if (!colorByCell.has(cell)) {
              colorByCell.set(
                cell,
                SHOW_ALL_COLORS[colorIndex % SHOW_ALL_COLORS.length],
              );
              colorIndex += 1;
            }
            el.classList.add("is-hot");
            el.style.setProperty(
              "--hot-color",
              colorByCell.get(cell),
            );
          });
          mapCells.forEach((el) => {
            const cell = el.dataset.cell || "";
            const color = colorByCell.get(cell);
            if (!color) return;
            el.classList.add("is-hot");
            el.style.setProperty("--hot-color", color);
          });
          return;
        }

        xrefs.forEach((el) => {
          el.classList.remove("is-hot");
          el.style.removeProperty("--hot-color");
        });
        mapCells.forEach((el) => {
          el.classList.remove("is-hot");
          el.style.removeProperty("--hot-color");
        });
      }

      function loadLS() {
        try {
          histArr = JSON.parse(localStorage.getItem(LS_H) || "[]");
          faves = JSON.parse(localStorage.getItem(LS_F) || "[]");
        } catch (e) {
          histArr = [];
          faves = [];
        }
      }

      function saveLS() {
        localStorage.setItem(LS_H, JSON.stringify(histArr.slice(-MAXH)));
        localStorage.setItem(LS_F, JSON.stringify([...new Set(faves)]));
      }

      function renderLists() {
        if (!histList || !favList) return;

        histList.innerHTML = "";
        const recent = histArr.slice(-MAXH).slice().reverse();
        recent.forEach((s) => {
          const li = document.createElement("li");
          li.textContent = s;
          li.title = "Load seed";
          li.onclick = () => {
            ui.setCurrentSeed(s, true);
            ui.generate();
          };
          histList.appendChild(li);
        });

        favList.innerHTML = "";
        faves.forEach((s) => {
          const li = document.createElement("li");
          li.textContent = s;
          li.title = "Load favorite";
          li.onclick = () => {
            ui.setCurrentSeed(s, true);
            ui.generate();
          };
          favList.appendChild(li);
        });
      }

      function pushHistory(s) {
        if (!s) return;
        if (histArr.length === 0 || histArr[histArr.length - 1] !== s)
          histArr.push(s);
        if (histArr.length > MAXH) histArr = histArr.slice(-MAXH);
        idx = histArr.length - 1;
        ui.save();
        ui.renderLists();
      }

      function navigate(d) {
        if (!histArr.length) return;
        idx = Math.max(0, Math.min(histArr.length - 1, idx + d));
        ui.setCurrentSeed(histArr[idx], false);
        ui.generate();
      }

      function setCurrentSeed(s, push = true) {
        current = s;
        seedShow.textContent = s;
        if (push) pushHistory(s);
        updateHash();
      }

      function parseHash() {
        const h = location.hash.replace(/^#/, "");
        const params = new URLSearchParams(h.includes("=") ? h : "");
        const s = params.get("s"),
          t = params.get("t");
        return {
          s: s ? decodeURIComponent(s) : null,
          t: t ? decodeURIComponent(t) : null,
        };
      }

      function updateHash() {
        if (!current) return;
        const t = themeSel.value;
        const h = `s=${encodeURIComponent(current)}&t=${encodeURIComponent(t)}`;
        if (location.hash !== `#${h}`)
          window.history.replaceState(null, "", `#${h}`);
      }

      function resolveTheme(seed, sel, themeTables) {
        if (sel !== "rnd") return sel;
        const keys = Object.keys(themeTables);
        return keys[rngUtil.h32(seed) % keys.length];
      }

      function doGenerate() {
        const typed = seedIn.value.trim();
        const s = typed || rngUtil.randSeed();
        ui.setCurrentSeed(s, true);
        ui.generate();
      }

      /* ====================== Cross-hover binding ====================== */
      let _crossHoverBound = false;

      function bindCrossHover() {
        if (_crossHoverBound) return;
        _crossHoverBound = true;
        let locked = false;
        const mapTipEl = document.getElementById("mapTip");
        const canShowTip =
          window.matchMedia && window.matchMedia("(pointer: coarse)").matches;

        const clearHot = () => {
          if (showAllMode) return;
          document
            .querySelectorAll(".is-hot")
            .forEach((el) => el.classList.remove("is-hot"));
        };

        const clearFerryPreview = () => {
          if (showAllMode) return;
          mapEl
            .querySelectorAll("span.is-ferry-path")
            .forEach((el) => {
              const orig = el.dataset.ferryOrig;
              if (orig !== undefined) el.textContent = orig;
              el.classList.remove("is-ferry-path");
            });
        };

        const setMapTip = (text) => {
          if (!mapTipEl || !canShowTip) return;
          mapTipEl.textContent = text || "";
        };

        const getTitleForCell = (cell) => {
          if (!cell) return "";
          const esc =
            window.CSS && CSS.escape
              ? CSS.escape(cell)
              : cell.replace(/"/g, '\\"');
          const el = mapEl.querySelector(`span[data-cell="${esc}"]`);
          return el?.getAttribute("title") || "";
        };

        const showFerryPreview = (ferryId) => {
          clearFerryPreview();
          if (!ferryId) return;
          const esc =
            window.CSS && CSS.escape
              ? CSS.escape(ferryId)
              : ferryId.replace(/"/g, '\\"');
          mapEl
            .querySelectorAll(`span[data-ferry-path="${esc}"]`)
            .forEach((el) => {
              if (el.dataset.ferryOrig === undefined)
                el.dataset.ferryOrig = el.textContent;
              const glyph = el.dataset.ferryGlyph;
              if (glyph) el.textContent = glyph;
              el.classList.add("is-ferry-path");
            });
        };

        const markCell = (cell, ferryId = null) => {
          if (showAllMode) return;
          clearHot();
          clearFerryPreview();
          if (!cell) return;

          const esc =
            window.CSS && CSS.escape
              ? CSS.escape(cell)
              : cell.replace(/"/g, '\\"');

          mapEl
            .querySelectorAll(`span[data-cell="${esc}"]`)
            .forEach((el) => el.classList.add("is-hot"));
          out
            .querySelectorAll(`.xref[data-cell="${esc}"]`)
            .forEach((el) => el.classList.add("is-hot"));

          if (ferryId) {
            const ferr =
              window.CSS && CSS.escape
                ? CSS.escape(ferryId)
                : ferryId.replace(/"/g, '\\"');
            mapEl
              .querySelectorAll(`span[data-ferry-id="${ferr}"]`)
              .forEach((el) => el.classList.add("is-hot"));
            out
              .querySelectorAll(`.xref[data-ferry-id="${ferr}"]`)
              .forEach((el) => el.classList.add("is-hot"));
            showFerryPreview(ferryId);
          }
        };

        out.addEventListener("pointerover", (e) => {
          if (showAllMode) return;
          if (locked) return;
          if (e.pointerType && e.pointerType !== "mouse") return;
          const t = e.target.closest?.(".xref[data-cell]");
          if (!t) return;
          markCell(t.dataset.cell, t.dataset.ferryId || null);
        });

        out.addEventListener("pointerout", (e) => {
          if (showAllMode) return;
          if (locked) return;
          if (e.pointerType && e.pointerType !== "mouse") return;
          const t = e.target.closest?.(".xref[data-cell]");
          if (!t) return;
          const rt = e.relatedTarget;
          if (rt && rt.closest?.(".xref[data-cell]")) return;
          clearHot();
          clearFerryPreview();
        });

        mapEl.addEventListener("pointerover", (e) => {
          if (showAllMode) return;
          if (locked) return;
          if (e.pointerType && e.pointerType !== "mouse") return;
          const t = e.target.closest?.("span[data-cell]");
          if (!t) return;
          markCell(t.dataset.cell, t.dataset.ferryId || null);
        });

        mapEl.addEventListener("pointerout", (e) => {
          if (showAllMode) return;
          if (locked) return;
          if (e.pointerType && e.pointerType !== "mouse") return;
          const t = e.target.closest?.("span[data-cell]");
          if (!t) return;
          const rt = e.relatedTarget;
          if (rt && rt.closest?.("span[data-cell]")) return;
          clearHot();
          clearFerryPreview();
        });

        const lockFromTarget = (target) => {
          const t =
            target?.closest?.(".xref[data-cell]") ||
            target?.closest?.("span[data-cell]");
          if (!t) return false;
          locked = true;
          if (!showAllMode) {
            markCell(t.dataset.cell, t.dataset.ferryId || null);
          }
          setMapTip(getTitleForCell(t.dataset.cell));
          return true;
        };

        let touchStart = null;
        const startTouch = (e) => {
          if (e.pointerType === "mouse") return;
          touchStart = {
            id: e.pointerId,
            x: e.clientX,
            y: e.clientY,
            target: e.target,
            moved: false,
          };
        };
        const moveTouch = (e) => {
          if (!touchStart || e.pointerId !== touchStart.id) return;
          const dx = Math.abs(e.clientX - touchStart.x);
          const dy = Math.abs(e.clientY - touchStart.y);
          if (dx > 8 || dy > 8) touchStart.moved = true;
        };
        const endTouch = (e) => {
          if (!touchStart || e.pointerId !== touchStart.id) return;
          const { moved, target } = touchStart;
          touchStart = null;
          if (moved) return;
          if (lockFromTarget(target)) return;
          if (!locked) return;
          locked = false;
          clearHot();
          clearFerryPreview();
          setMapTip("");
        };
        const cancelTouch = (e) => {
          if (touchStart && e.pointerId === touchStart.id) touchStart = null;
        };

        out.addEventListener("pointerdown", startTouch);
        mapEl.addEventListener("pointerdown", startTouch);
        document.addEventListener("pointermove", moveTouch);
        document.addEventListener("pointerup", endTouch);
        document.addEventListener("pointercancel", cancelTouch);
      }

      function generate() {
        if (!current) return;
        const themeUsed = resolveTheme(
          current,
          themeSel.value,
          worldBuilder.themes,
        );
        const { html, mapGrid, mapFlags } = worldBuilder.buildSlice(
          current,
          themeUsed,
        );
        out.innerHTML = html;
        mapEl.innerHTML = mapGrid;
        mapEl.dataset.deadTrees = mapFlags?.deadTrees ? "1" : "";
        mapEl.dataset.desert = mapFlags?.desert ? "1" : "";
        ui.bindCrossHover();
        if (showAllMode) applyShowAll(true);
      }

      function buildTilesetShowcaseGroups() {
        const groups = [];
        const seen = new Set();

        const addGroup = (label) => {
          const group = { label, entries: [] };
          groups.push(group);
          return group;
        };

        const addGlyph = (group, tileKey, glyph, attrs = {}) => {
          if (!glyph || seen.has(glyph)) return;
          seen.add(glyph);
          group.entries.push({ tileKey, glyph, attrs });
        };

        const addList = (group, tileKey, list, attrs = {}) => {
          if (!list) return;
          const arr = Array.isArray(list) ? list : [list];
          for (const glyph of arr) addGlyph(group, tileKey, glyph, attrs);
        };

        const gWater = addGroup("water");
        const water = tileset.water?.depthGlyphs || {};
        addList(gWater, "water", water[1], { depth: 1 });
        addList(gWater, "water", water[2], { depth: 2 });
        addList(gWater, "water", water[3], { depth: 3 });

        const gMountain = addGroup("mountain");
        const mountain = tileset.mountain?.height || {};
        for (const h of [1, 2, 3, 4, 5]) {
          addList(gMountain, "mountain", mountain[h], { height: h });
        }

        const gForest = addGroup("forest");
        const forest = tileset.forest || {};
        addList(gForest, "forest", forest.base, { forest: "mixed" });
        addList(gForest, "forest", forest.coniferous, {
          forest: "coniferous",
        });
        addList(gForest, "forest", forest.dead, { forest: "dead" });
        addList(gForest, "forest", forest.deciduous, {
          forest: "deciduous",
        });

        const gGrass = addGroup("grass");
        addList(gGrass, "grass", tileset.grass);

        const gPlains = addGroup("plains");
        addList(gPlains, "plains", tileset.plains);

        const gBeach = addGroup("beach");
        addList(gBeach, "beach", tileset.beach);

        const gDesert = addGroup("desert");
        addList(gDesert, "desert", tileset.desert);

        const gMyc = addGroup("mycelium");
        addList(gMyc, "mycelium", tileset.mycelium);

        const gSettlement = addGroup("settlement");
        addList(gSettlement, "settlement", tileset.settlement);

        const gRuins = addGroup("ruins");
        addList(gRuins, "ruins", tileset.ruins);

        const gOvergrownRuins = addGroup("overgrown-ruins");
        addList(
          gOvergrownRuins,
          "overgrown-ruins",
          tileset["overgrown-ruins"],
        );

        const gFungalSettlement = addGroup("fungal-settlement");
        addList(gFungalSettlement, "fungal-settlement", tileset["fungal-settlement"]);

        const gFungalRuins = addGroup("fungal-ruins");
        addList(gFungalRuins, "fungal-ruins", tileset["fungal-ruins"]);

        const gCamp = addGroup("camp");
        addList(gCamp, "camp", tileset.camp);

        const gPoi = addGroup("poi");
        addList(gPoi, "poi", tileset.poi);

        const gRel = addGroup("religious");
        const rel = tileset.religious || {};
        addList(gRel, "religious", rel.death, { religious: "death" });
        addList(gRel, "religious", rel.monastery, {
          religious: "monastery",
        });

        const gCrystal = addGroup("crystal");
        addList(gCrystal, "crystal", tileset.crystal);

        const gRoad = addGroup("road");
        const road = tileset.road?.glyphs || {};
        addList(gRoad, "road", Object.values(road));

        return groups.filter((g) => g.entries.length);
      }

      function renderTilesetShowcase() {
        let s = "";
        const groups = buildTilesetShowcaseGroups();
        let row = 0;

        for (const group of groups) {
          const label = `<span class="map-label">${escHtml(group.label)}:</span>`;
          s += label + " ";
          for (let i = 0; i < group.entries.length; i++) {
            const col = i + 1;
            const { tileKey, glyph, attrs } = group.entries[i];
            const cell = `${col},${row}`;

            const dataParts = [
              `data-cell="${cell}"`,
              `data-tile="${tileKey}"`,
            ];
            if (attrs.depth) dataParts.push(`data-depth="${attrs.depth}"`);
            if (attrs.height) dataParts.push(`data-height="${attrs.height}"`);
            if (attrs.forest)
              dataParts.push(`data-forest="${escAttr(attrs.forest)}"`);
            if (attrs.religious)
              dataParts.push(`data-religious="${escAttr(attrs.religious)}"`);

            const titleParts = [tileKey, cell];
            if (attrs.depth) titleParts.push(`depth: ${attrs.depth}`);
            if (attrs.height) titleParts.push(`height: ${attrs.height}`);
            if (attrs.forest) titleParts.push(`forest: ${attrs.forest}`);
            if (attrs.religious)
              titleParts.push(`religious: ${attrs.religious}`);
            const title = titleParts.join("    ");

            s += `<span ${dataParts.join(" ")} title="${escAttr(title)}">${glyph}</span>`;
          }
          row++;
          s += "\n";
        }

        mapEl.innerHTML = s;
        mapEl.dataset.deadTrees = "";
        mapEl.dataset.desert = "";
        out.textContent = "Tileset showcase";
        ui.bindCrossHover();
        if (showAllMode) applyShowAll(true);
      }

      function shareURL() {
        if (!current) return;
        updateHash();
      }

      // #endregion UI + State
      // #region Events + Init
      /* ====================== Events + Init ====================== */
      btnGen.onclick = doGenerate;
      seedIn.addEventListener("keydown", (e) => {
        if (e.key === "Enter") doGenerate();
      });
      btnPrev.onclick = () => navigate(-1);
      btnNext.onclick = () => navigate(1);

      // btnSave.onclick = () => {
      //   if (!current) return;
      //   if (!faves.includes(current)) faves.push(current);
      //   saveLS();
      //   renderLists();
      // };

      btnCopySeed.onclick = () => {
        if (current) navigator.clipboard?.writeText(current);
      };

      if (btnShowAll) {
        btnShowAll.onclick = () => applyShowAll(!showAllMode);
      }

      if (seedPill) {
        seedPill.addEventListener("click", (e) => {
          if (!e.shiftKey) return;
          e.preventDefault();
          e.stopPropagation();
          renderTilesetShowcase();
        });
      }

      // btnCopyOut.onclick = () => navigator.clipboard?.writeText((out.textContent || "") + "\n" + (mapEl.textContent || ""));

      // btnShare.onclick = () => shareURL();

      // if (btnClrFav) {
      //   btnClrFav.onclick = () => {
      //     if (!faves.length) return;
      //     if (!confirm("Clear all favorites?")) return;
      //     faves = [];
      //     ui.save();
      //     ui.renderLists();
      //   };
      // }

      themeSel.onchange = () => {
        ui.generate();
        updateHash();
      };

      window.addEventListener("hashchange", () => {
        const { s, t } = parseHash();
        if (t) themeSel.value = t;
        if (s) {
          ui.setCurrentSeed(s, true);
          ui.generate();
        }
      });

      (function init() {
        ui.load();
        ui.renderLists();
        const { s, t } = parseHash();
        if (t) themeSel.value = t;

        if (s) {
          ui.setCurrentSeed(s, true);
        } else if (histArr.length) {
          ui.setCurrentSeed(histArr[histArr.length - 1], false);
          idx = histArr.length - 1;
        } else {
          ui.setCurrentSeed(rngUtil.randSeed(), true);
        }
        ui.generate();
      })();

      // #endregion Events + Init
    </script>
  </body>
</html>
