<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Slice-of-World Generator</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      @font-face {
        font-family: "unifontex";
        src: url("https://stgiga.github.io/UnifontEX/UnifontExMono.ttf");
        font-style: normal;
        font-weight: 400;
        font-display: block;
      }


      /* ====================== Sweetie16 (ONLY literal colors) ====================== */
      :root {
        --sw0: #1a1c2c;
        --sw1: #5d275d;
        --sw2: #b13e53;
        --sw3: #ef7d57;
        --sw4: #ffcd75;
        --sw5: #a7f070;
        --sw6: #38b764;
        --sw7: #257179;
        --sw8: #29366f;
        --sw9: #3b5dc9;
        --sw10: #41a6f6;
        --sw11: #73eff7;
        --sw12: #f4f4f4;
        --sw13: #94b0c2;
        --sw14: #566c86;
        --sw15: #333c57;

        /* ====================== App semantic vars ====================== */
        --bg: var(--sw0);
        --fg: var(--sw12);
        --mut: var(--sw13);
        --acc: var(--sw5);
        --btn: var(--sw15);
        --br: color-mix(in srgb, var(--sw12) 14%, transparent);

        --pane: var(--sw0);
        --pane2: color-mix(in srgb, black 40%, var(--sw0));
        --pill-bg: color-mix(in srgb, var(--sw0) 60%, var(--sw8));
        --pill-br: color-mix(in srgb, var(--sw7) 55%, transparent);

        /* cross-hover */
        --hot: var(--sw4);
        --hot-bg: color-mix(in srgb, var(--sw5) 14%, transparent);
        --hot-outline: color-mix(in srgb, var(--sw5) 28%, transparent);
        --ring: var(--sw5);

        /* ====================== Tile colors ====================== */
        --tile-water: var(--sw10);
        --tile-water-1: var(--sw10);
        --tile-water-2: var(--sw9);
        --tile-water-3: var(--sw8);
        --tile-lava-1: var(--sw2);
        --tile-lava-2: var(--sw3);
        --tile-lava-3: var(--sw4);

        --tile-mountain-1: var(--sw14);
        --tile-mountain-2: var(--sw13);
        --tile-mountain-3: var(--sw13);
        --tile-mountain-4: var(--sw13);
        --tile-mountain-5: var(--sw12);

        --tile-forest: var(--sw6);
        --tile-forest-deciduous: var(--sw6);
        --tile-forest-coniferous: var(--sw7);
        --tile-forest-dead: color-mix(in srgb, var(--sw4) 20%, var(--sw1));
        --tile-mycelium: color-mix(in srgb, var(--sw9) 50%, var(--sw2));

        --tile-grass: var(--sw6);
        --tile-grass-dead: color-mix(
          in srgb,
          var(--tile-grass) 60%,
          var(--sw1)
        );
        --tile-plains: color-mix(in srgb, var(--sw5) 50%, var(--sw0));
        --tile-settlement: var(--sw2);
        --tile-camp: var(--sw3);
        --tile-ruins: var(--sw14);
        --tile-overgrown-ruins: color-mix(
          in srgb,
          var(--tile-ruins) 50%,
          var(--sw5)
        );
        --tile-fungal-settlement: color-mix(
          in srgb,
          var(--tile-mycelium) 45%,
          var(--tile-settlement)
        );
        --tile-fungal-ruins: color-mix(
          in srgb,
          var(--tile-mycelium) 65%,
          var(--tile-ruins)
        );
        --tile-desert: color-mix(in srgb, var(--sw4) 70%, var(--sw1));
        --tile-religious-death: var(--sw3);
        --tile-religious-monastery: var(--sw11);
        --tile-crystal-blue: color-mix(in srgb, var(--sw11) 70%, var(--sw12));
        --tile-crystal-pink: color-mix(in srgb, var(--sw1) 45%, var(--sw12));
        --tile-crystal-green: color-mix(in srgb, var(--sw5) 55%, var(--sw12));
        --tile-crystal: var(--tile-crystal-blue);
      }

      html {
        font-size: 120%;
      }

      html,
      body {
        height: 100%;
        display: flex;
        flex-direction: column;
        margin: 0;
        padding: 0;
        background: var(--bg);
        color: var(--fg);
        font-family:
          "unifontex",
          "CozetteVector",
          ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          "Courier New",
          monospace;
      }

      header {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
        align-items: center;
        padding: 12px;
        border-bottom: 1px solid var(--br);
      }

      h1 {
        font-size: 1rem;
        margin: 0 12px 0 0;
        color: var(--acc);
        flex: 1;
        white-space: nowrap;
      }

      label {
        color: var(--mut);
        font-size: 0.75rem;
      }

      .menu-toggle {
        position: absolute;
        width: 1px;
        height: 1px;
        margin: -1px;
        border: 0;
        padding: 0;
        overflow: hidden;
        clip: rect(0 0 0 0);
        white-space: nowrap;
      }
      .menu-button {
        display: none;
        align-items: center;
        gap: 6px;
        padding: 7px 10px;
        border: 1px solid var(--br);
        border-radius: 6px;
        background: var(--btn);
        color: var(--fg);
        cursor: pointer;
      }
      .menu-icon {
        display: inline-block;
        width: 16px;
        height: 2px;
        background: currentColor;
        position: relative;
      }
      .menu-icon::before,
      .menu-icon::after {
        content: "";
        position: absolute;
        left: 0;
        width: 16px;
        height: 2px;
        background: currentColor;
      }
      .menu-icon::before {
        top: -5px;
      }
      .menu-icon::after {
        top: 5px;
      }
      .menu-content {
        display: inline-flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      input,
      select,
      button {
        background: var(--btn);
        color: var(--fg);
        border: 1px solid var(--br);
        border-radius: 6px;
        padding: 7px 10px;
      }

      input[type="text"] {
        min-width: 10rem;
      }

      button {
        cursor: pointer;
      }

      button:active {
        transform: translateY(1px);
      }

      .wrap {
        flex-grow: 1;
        padding: 12px;
        display: flex;
        gap: 12px;
      }

      .pane {
        border: 1px solid var(--br);
        border-radius: 8px;
        padding: 10px;
        background: var(--pane2);
        position: relative;
        display: flex;
        gap: 1rem;
        flex-grow: 1;
      }

      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      pre {
        white-space: pre;
        overflow: auto;
        margin: 0;
        font-family:
          "unifontex",
          "CozetteVector",
          ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          "Courier New",
          monospace;
      }

      #out {
        flex: 1;
        text-wrap: balance;
        color: var(--sw13);
      }

      #out .xref {
        text-decoration: underline;
        color: var(--sw6);
        text-decoration-color: var(--sw14);
        transition: all 0.15s ease-in-out;
      }
      #out .xref.is-hot {
        text-decoration: none;
      }

      .mapwrap {
        /* flex: 1; */
        display: flex;
        flex-direction: column;
        align-items: flex-end;
      }

      /* Larger, square-cell minimap */
      #map {
        margin-top: 8px;
        overflow: visible;
        cursor: pointer;
      }
      #map span {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        width: 1.2rem;
        height: 1.2rem;
        transition: all 0.15s ease-in-out;
        border-radius: 50%;
      }
      #map span.map-label {
        width: auto;
        min-width: 12ch;
        justify-content: flex-start;
        color: var(--sw12);
        font-weight: 700;
        letter-spacing: 0.02em;
      }
      #map span:hover {
        transform: scale(1.3);
      }
      #map span.map-label:hover {
        transform: none;
      }

      /* ========= Tile coloring (NO magic colors) ========= */
      #map span[data-tile="water"] {
        color: var(--tile-water);
      }
      #map span[data-tile="water"][data-depth="1"] {
        color: var(--tile-water-1);
      }
      #map span[data-tile="water"][data-depth="2"] {
        color: var(--tile-water-2);
      }
      #map span[data-tile="water"][data-depth="3"] {
        color: var(--tile-water-3);
      }
      #map span[data-tile="lava"][data-depth="1"] {
        color: var(--tile-lava-1);
      }
      #map span[data-tile="lava"][data-depth="2"] {
        color: var(--tile-lava-2);
      }
      #map span[data-tile="lava"][data-depth="3"] {
        color: var(--tile-lava-3);
      }

      #map span[data-tile="mountain"][data-height="1"] {
        color: var(--tile-mountain-1);
      }
      #map span[data-tile="mountain"][data-height="2"] {
        color: var(--tile-mountain-2);
      }
      #map span[data-tile="mountain"][data-height="3"] {
        color: var(--tile-mountain-3);
      }
      #map span[data-tile="mountain"][data-height="4"] {
        color: var(--tile-mountain-4);
      }
      #map span[data-tile="mountain"][data-height="5"] {
        color: var(--tile-mountain-5);
      }

      #map span[data-tile="forest"] {
        color: var(--tile-forest);
      }
      #map span[data-tile="forest"][data-forest="deciduous"] {
        color: var(--tile-forest-deciduous);
      }
      #map span[data-tile="forest"][data-forest="coniferous"] {
        color: var(--tile-forest-coniferous);
      }
      #map span[data-tile="forest"][data-forest="dead"] {
        color: var(--tile-forest-dead);
      }
      #map span[data-tile="mycelium"] {
        color: var(--tile-mycelium);
      }

      #map span[data-tile="grass"] {
        color: var(--tile-grass);
      }
      #map[data-dead-trees="1"] span[data-tile="grass"],
      #map[data-desert="1"] span[data-tile="grass"] {
        color: var(--tile-grass-dead);
      }
      #map span[data-tile="plains"] {
        color: var(--tile-plains);
      }
      #map span[data-tile="settlement"] {
        color: var(--tile-settlement);
      }
      #map span[data-tile="ruins"] {
        color: var(--tile-ruins);
      }
      #map span[data-tile="overgrown-ruins"] {
        color: var(--tile-overgrown-ruins);
      }
      #map span[data-tile="fungal-settlement"] {
        color: var(--tile-fungal-settlement);
      }
      #map span[data-tile="fungal-ruins"] {
        color: var(--tile-fungal-ruins);
      }
      #map span[data-tile="camp"] {
        color: var(--tile-camp);
      }
      #map span[data-tile="desert"] {
        color: var(--tile-desert);
      }
      #map span[data-tile="beach"] {
        color: var(--tile-desert);
      }
      #map span[data-tile="religious"][data-religious="death"] {
        color: var(--tile-religious-death);
      }
      #map span[data-tile="religious"][data-religious="monastery"] {
        color: var(--tile-religious-monastery);
      }
      #map span[data-tile="crystal"] {
        color: var(--tile-crystal);
      }
      #map span[data-tile="crystal"][data-crystal="blue"] {
        color: var(--tile-crystal-blue);
        filter: saturate(1);
      }
      #map span[data-tile="crystal"][data-crystal="pink"] {
        color: var(--tile-crystal-pink);
        filter: saturate(3);
      }
      #map span[data-tile="crystal"][data-crystal="green"] {
        color: var(--tile-crystal-green);
        filter: saturate(1);
      }

      .small {
        font-size: 0.75rem;
        color: var(--mut);
      }

      ul.list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      ul.list li {
        background: var(--btn);
        border: 1px solid var(--br);
        padding: 4px 7px;
        border-radius: 6px;
        cursor: pointer;
      }
      ul.list li:hover {
        border-color: var(--acc);
      }

      .head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .mut {
        color: var(--mut);
      }
      .sep {
        height: 10px;
      }

      .pill {
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid var(--br);
        background: var(--pill-bg);
      }
      .pill.seedpill {
        margin-top: 2rem;
      }
      .nowrap {
        white-space: nowrap;
      }
      .seedpill {
        margin-left: 6px;
        color: var(--fg);
        border-color: var(--pill-br);
        background: var(--pill-bg);
      }

      @media (max-width: 45rem) {
        header {
          align-items: center;
          position: sticky;
          top: 0;
          z-index: 10;
          background: var(--bg);
        }
        .wrap {
          flex-direction: column;
        }
        .pane {
          flex-direction: column-reverse;
          align-items: stretch;
        }
        #out {
          width: 100%;
        }
        .mapwrap {
          width: 100%;
          align-items: flex-start;
        }
        .menu-button {
          display: inline-flex;
          margin-left: auto;
          position: absolute;
          top: 1rem;
          right: 1rem;
        }

        .row {
          flex: 1 1 100%;
        }
        .menu-content {
          display: none;
          width: 100%;
        }
        header:has(.menu-toggle:checked) .menu-content {
          display: flex;
        }
        #map {
          width: 100%;
          font-size: min(1.2rem, 3.5vw);
        }
        #map span {
          width: 1em;
          height: 1em;
          font-size: 1em;
        }
      }

      .hidden {
        display: none;
      }

      button.primary {
        background: color-mix(in srgb, var(--acc) 70%, var(--btn));
        color: var(--bg);
        font-weight: bold;
        transition: all ease-in-out 0.15s;
      }
      button.primary:hover {
        background: color-mix(in srgb, var(--acc) 80%, var(--btn));
      }

      /* ===== cross-hover linking ===== */
      #map span.is-hot {
        position: relative;
        transform-origin: center center;
        transform: scale(1.5);
      }
      #map span.is-hot::before {
        display: flex;
        height: 1.5rem;
        width: 1.5rem;
        border: 2px solid var(--ring);
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        background: var(--bg);
        z-index: -1;
        pointer-events: none;
      }

      #out .xref {
        cursor: pointer;
        border-radius: 4px;
        padding: 0 2px;
      }

      #out .xref.is-hot {
        color: var(--acc);
        background: var(--hot-bg);
        outline: 1px solid var(--hot-outline);
      }
    </style>
  </head>

  <body>
    <header>
      <h1>World Slice</h1>
      <input id="menuToggle" class="menu-toggle" type="checkbox" />
      <div class="row">
        <button id="prev">Prev</button>
        <button id="gen" class="primary">Generate</button>
        <button id="next">Next</button>
        <!-- <button id="save" title="Add current seed to favorites">Save</button> -->
        <span class="menu-content">
          <button id="copySeed" title="Copy current seed">Copy Seed</button>
          <label for="seed">Seed</label>
          <input id="seed" type="text" placeholder="Leave blank for random" />
          <label for="theme">Theme</label>
          <select id="theme" class="nowrap" title="Theme">
            <option value="rnd">Random (seed-based)</option>
            <option value="fantasy">Fantasy</option>
            <option value="scifi">Sci-fi</option>
            <option value="apocalypse">Post-apocalyptic</option>
          </select>
        </span>
        <!-- <button id="copyOut" title="Copy output text">Copy Output</button> -->
        <!-- <button id="share" title="Update URL with current seed/theme">Share</button> -->
      </div>
      <label for="menuToggle" class="menu-button">
        <span class="menu-icon" aria-hidden="true"></span>
        <span class="menu-text">Menu</span>
      </label>
    </header>

    <div class="wrap">
      <div class="pane">
        <pre id="out"></pre>
        <span class="mapwrap">
          <pre id="map"></pre>
          <span class="pill seedpill small">
            Seed:
            <strong id="seedShow">â€”</strong>
          </span>
        </span>
      </div>

      <div class="hidden">
        <div class="head">
          <strong>History</strong><span class="small mut">(latest 5)</span>
        </div>
        <div id="histWrap">
          <ul id="hist" class="list"></ul>
        </div>
        <div class="sep"></div>
        <div class="head favs">
          <strong>Favorites</strong
          ><button id="clrFav" class="pill small">Clear</button>
        </div>
        <ul id="favs" class="list"></ul>
        <div class="sep"></div>
        <div class="small mut">
          Tip: press <strong>Enter</strong> in the seed box to use that seed
          once.
        </div>
      </div>
    </div>

    <script>
      /** 
       * TODO: wrap NPC names in span, color them --sw12
       * TODO: hook grammar makes no sense when it combines multiple modifiers, e.g. "a relic goes missing near the rootbound enclave during light wind conditions". maybe only allow one modifier per hook?
       * 
      **/

      // #region App Script Overview
      // Sections: Constants, Theme Tables, Tileset, Lexicon Data, RNG Utilities,
      // Naming + Lexicon Builders, World Builder, Map Generation, UI/State, Events.
      // #endregion App Script Overview

      // #region Constants + Feature Flags
      /* ====================== Tables (themes) ====================== */
      const geoFeatures = [
        "river-water",
        "river-lava",
        "mountain",
        "beaches",
        "dunes",
        "oasis",
        "ruins",
        "ridge",
        "reef", // not implemented yet
        "mycelium",
        "crystals",
        "dead trees",
      ];
      const moistureLevels = [
        "arid",
        "dry winds",
        "breezy",
        "humid",
        "mist-laden",
        "rainy",
        "soaking",
        "saturated",
      ];

      const DEBUG = false;
      const FEATURE_SET = new Set([...geoFeatures, "lagoon", "watering hole"]);

      function debugWarn(message) {
        if (DEBUG) console.warn(message);
      }

      function validateFeatureName(id, context) {
        if (!DEBUG) return;
        if (!FEATURE_SET.has(id))
          debugWarn(
            `Unknown feature "${id}"${context ? ` in ${context}` : ""}`,
          );
      }

      // #endregion Constants + Feature Flags
      // #region Theme Tables
      const themes = {
        fantasy: {
          biome: [
            {
              name: "tundra",
              features: {
                "river-water": 0.3,
                lake: 0.25,
                mountain: 0.35,
                ridge: 0.4,
                ruins: 0.15,
              },
            },
            {
              name: "taiga",
              features: {
                "river-water": 0.45,
                lake: 0.35,
                mountain: 0.25,
                ridge: 0.3,
                ruins: 0.2,
                mycelium: 0.25,
              },
            },
            {
              name: "temperate forest",
              features: {
                "river-water": 0.5,
                lake: 0.35,
                ruins: 0.2,
                ridge: 0.2,
                mycelium: 0.3,
              },
            },
            {
              name: "steppe",
              features: {
                "river-water": 0.25,
                lake: 0.15,
                "watering hole": 0.3,
                dunes: 0.25,
                ridge: 0.2,
                ruins: 0.15,
              },
            },
            {
              name: "savanna",
              features: {
                "river-water": 0.35,
                lake: 0.2,
                "watering hole": 0.45,
                dunes: 0.2,
                oasis: 0.15,
                ruins: 0.1,
              },
            },
            {
              name: "desert",
              features: {
                "river-water": 0.1,
                lake: 0.05,
                "watering hole": 0.3,
                dunes: 0.6,
                oasis: 0.4,
                ruins: 0.25,
                ridge: 0.25,
                "river-lava": 0.1,
              },
            },
            {
              name: "jungle",
              features: {
                "river-water": 0.6,
                lake: 0.35,
                ruins: 0.25,
                lagoon: 0.25,
                mycelium: 0.4,
              },
            },
            {
              name: "wetlands",
              features: {
                "river-water": 0.7,
                lake: 0.45,
                lagoon: 0.4,
                mycelium: 0.3,
                ruins: 0.15,
              },
            },
            {
              name: "highlands",
              features: {
                "river-water": 0.3,
                mountain: 0.7,
                ridge: 0.6,
                lake: 0.2,
                "river-lava": 0.15,
                ruins: 0.2,
              },
            },
            {
              name: "islands",
              features: {
                "river-water": 0.25,
                lake: 0.2,
                reef: 0.7,
                lagoon: 0.6,
                dunes: 0.2,
                ruins: 0.25,
              },
            },
            {
              name: "badlands",
              features: {
                "river-water": 0.15,
                mountain: 0.4,
                ridge: 0.6,
                dunes: 0.3,
                ruins: 0.35,
                "river-lava": 0.2,
                "dead trees": 0.3,
              },
            },
            {
              name: "crystal barrens",
              features: {
                "river-water": 0.15,
                "river-lava": 0.2,
                dunes: 0.35,
                ridge: 0.45,
                ruins: 0.3,
                crystals: 0.7,
                "dead trees": 0.25,
              },
            },
            {
              name: "fungal expanse",
              features: {
                mycelium: 0.8,
                lake: 0.25,
                "river-water": 0.35,
                ruins: 0.2,
                "dead trees": 0.3,
              },
            },
            {
              name: "ashen plains",
              features: {
                "river-lava": 0.5,
                dunes: 0.25,
                ridge: 0.4,
                mountain: 0.3,
                ruins: 0.25,
                "dead trees": 0.45,
              },
            },
            {
              name: "shattered coast",
              features: {
                beaches: 0.6,
                reef: 0.55,
                lake: 0.25,
                "river-water": 0.3,
                ruins: 0.2,
                dunes: 0.15,
                crystals: 0.2,
              },
            },
            {
              name: "hollow grove",
              features: {
                mycelium: 0.45,
                "dead trees": 0.65,
                "river-water": 0.25,
                lake: 0.2,
                ruins: 0.35,
                ridge: 0.25,
              },
            },
            {
              name: "obsidian high desert",
              features: {
                dunes: 0.55,
                oasis: 0.2,
                "river-lava": 0.35,
                ridge: 0.4,
                mountain: 0.25,
                ruins: 0.3,
              },
            }
          ],
          temp: {
            1: "gelid",
            2: "frigid",
            3: "chill",
            4: "mild",
            5: "warm",
            6: "balmy",
            7: "sultry",
            8: "searing",
          },
          climateAdj: [
            "rocky",
            "dusty",
            "foggy",
            "smoky",
            "cracked",
            "scarred",
            "shadowed",
            "glowing",
            "pitted",
            "overgrown",
            "mossy",
            "fungal",
            "boggy",
            "marshy",
            "rooted",
            "thorny",
            "brambly",
            "ancient",
            "veined",
            "twilight",
            "starlit",
            "moonlit",
            "buried",
            "forgotten",
          ],
          factionsN1: [
            "Order",
            "Guild",
            "Clan",
            "Court",
            "Circle",
            "Syndicate",
            "Chapter",
            "Coven",
            "Brotherhood",
            "Company",
            "League",
            "Consulate",
            "Caravan",
            "Enclave",
            "Assembly",
            "Dominion",
            "Conclave",
            "Pact",
            "Sect",
            "Keep",
            "Banner",
            "Throng",
            "Kin",
            "House",
            "Hollow",
            "Sanctum",
            "Forge",
            "Crusade",
            "March",
            "Host",
          ],
          factionsN2: [
            "of the",
            "of",
            "for the",
            "under",
            "against the",
            "beneath the",
            "among the",
            "beyond the",
            "within the",
            "beside the",
            "before the",
            "after the",
            "toward the",
            "upon the",
          ],
          roles: [
            "Wardens",
            "Archivists",
            "Bonepickers",
            "Skyfarers",
            "Prospectors",
            "Scribes",
            "Wayfinders",
            "Stormcallers",
            "Reclaimers",
            "Oathkeepers",
            "Lamplighters",
            "Seers",
            "Witchbinders",
            "Lorehunters",
            "Pathmakers",
            "Gravetenders",
            "Runesmiths",
            "Beastwalkers",
            "Spellweavers",
            "Hearthguard",
            "Frostborn",
            "Flamebearers",
            "Thornwatch",
            "Miststriders",
          ],
          motives: [
            "cleansing",
            "binding",
            "awakening",
            "silencing",
            "tending",
            "unlocking",
            "consecrating",
          ],
          motiveGlue: [
            "the only remaining",
            "a",
            "an ancient",
            "a forgotten",
            "a cursed",
            "the last",
            "a sacred",
            "a sealed",
            "an abandoned",
            "a hidden",
            "a buried",
            "a ruined",
            "a lost",
            "a reclaimed",
          ],
          relicAdjectives: [
            "ancient",
            "forgotten",
            "sealed",
            "cracked",
            "hallowed",
            "bound",
            "runed",
            "sunken",
            "twilight",
            "blood-marked",
            "iron-bound",
            "frosted",
            "echoing",
            "cursed",
            "blessed",
            "hidden",
            "star-forged",
            "bone-carved",
          ],
          relicNouns: [
            "tablet",
            "idol",
            "scroll",
            "blade",
            "mask",
            "sigil",
            "key",
            "horn",
            "stone",
            "ring",
            "crown",
            "lens",
            "staff",
            "seal",
            "totem",
            "mirror",
            "lock",
            "gem",
            "vessel",
            "pendant",
          ],
          pois: [
            "relic line",
            "forgotten cairn",
            "leyline path",
            "star-iron vein",
            "storm cycle",
            "dune-wyrm pact",
            "glowmoss field",
            "floodgate",
            "hearthhold",
            "shattered runestone",
            "cursed grove",
            "ancestral cairn",
            "rootbound enclave",
            "dormant sentinel",
            "echoing tomb",
            "emberfield",
            "sealed vault",
            "moonshade beast",
            "sky-bridge",
            "sunken sanctuary",
          ],
          weather: [
            "light wind",
            "fine dust in the air",
            "low thunder",
            "steady breeze",
            "scattered clouds",
            "brief gusts",
            "thin mist",
            "dry air",
            "occasional flashes",
            "soft rainfall",
            "distant rumble",
            "light haze",
            "static in the air",
            "drifting ash",
            "stillness before change",
            "faint crackling",
            "settling silt",
            "air thick with pollen",
            "cool drafts",
            "humid stillness",
          ],
          hooks: [
            "an oath breaks",
            "a relic goes missing",
            "a boundary marker is moved",
            "the river changes course",
            "the caravan doesn't arrive",
            "a ward stops working",
            "a beast emerges from the quarry",
            "a gate opens without warning",
            "a name is removed from the scrolls",
            "the harvest comes too early",
            "the flame marks someone new",
            "the map is altered",
            "a rival claims blood-right",
            "the tithe causes unrest",
            "the monolith sinks faster",
            "the plants react to movement",
            "a vault is uncovered",
            "the sky cracks at dawn",
            "a sigil appears",
            "the well runs dry",
          ],
          hookMods: [
            "near the <poi>",
            "within the biome",
            "during <weather> conditions",
            "beneath the <poi>",
            "around the <poi>",
            "when passing through the biome",
            "when the wind shifted to <weather>",
          ],
          hookGlue: [
            "and",
            "but",
            "while",
            "as",
            "yet",
            "then",
            "though",
            "because",
            "when",
            "just as",
          ],
        },

        scifi: {
          biome: [
            {
              name: "oceanic world",
              features: {
                reef: 0.8,
                lagoon: 0.7,
                "river-water": 0.3,
                lake: 0.2,
                ruins: 0.15,
              },
            },
            {
              name: "barren craters",
              features: {
                ridge: 0.6,
                mountain: 0.4,
                "river-lava": 0.2,
                ruins: 0.2,
                lake: 0.05,
              },
            },
            {
              name: "lava fields",
              features: {
                "river-lava": 0.8,
                mountain: 0.5,
                ridge: 0.4,
                ruins: 0.15,
              },
            },
            {
              name: "arboreal belts",
              features: {
                "river-water": 0.5,
                lake: 0.3,
                ruins: 0.2,
                mycelium: 0.25,
              },
            },
            {
              name: "fungal mats",
              features: {
                mycelium: 0.9,
                lake: 0.25,
                "river-water": 0.35,
                ruins: 0.2,
              },
            },
            {
              name: "erg desert",
              features: {
                dunes: 0.8,
                oasis: 0.35,
                "watering hole": 0.2,
                "river-water": 0.15,
                ruins: 0.2,
              },
            },
            {
              name: "ice shelf",
              features: {
                lake: 0.3,
                "river-water": 0.2,
                ridge: 0.35,
                mountain: 0.3,
                ruins: 0.1,
              },
            },
            {
              name: "toxic bogs",
              features: {
                "river-water": 0.5,
                lake: 0.4,
                lagoon: 0.25,
                ruins: 0.2,
                mycelium: 0.7,
              },
            },
            {
              name: "megacity sector",
              features: {
                ruins: 0.6,
                ridge: 0.3,
                "river-water": 0.25,
                lake: 0.15,
              },
            },
            {
              name: "ring habitat",
              features: {
                "river-water": 0.35,
                lake: 0.25,
                lagoon: 0.3,
                ridge: 0.2,
                ruins: 0.2,
              },
            },
            {
              name: "tidal wetlands",
              features: {
                "river-water": 0.6,
                lagoon: 0.6,
                reef: 0.4,
                lake: 0.3,
                mycelium: 0.2,
              },
            },
          ],
          temp: {
            1: "cryonic",
            2: "subzero",
            3: "brisk",
            4: "temperate",
            5: "warm",
            6: "tropic",
            7: "equatorial",
            8: "thermic",
          },
          climateAdj: [
            "rocky",
            "dusty",
            "foggy",
            "smoky",
            "cracked",
            "scarred",
            "shadowed",
            "glowing",
            "pitted",
            "overgrown",
            "synthetic",
            "alien",
            "metallic",
            "magnetic",
            "gravitic",
            "orbital",
            "stellar",
            "lunar",
            "tidal",
            "crystalline",
            "coralline",
            "glassy",
            "mutant",
            "viral",
            "sentient",
            "abandoned",
            "encrypted",
            "rifted",
            "plasmatic",
          ],
          factionsN1: [
            "Consortium",
            "Syndicate",
            "Research Cell",
            "Freeport",
            "Colonial Office",
            "Outer Rim Guild",
            "Scavenger Crew",
            "Offworld Temple",
            "AI Collective",
            "Orbital Chapter",
            "Relay Cartel",
            "Trade Assembly",
            "Quantum Union",
            "Terraform Bureau",
            "Signal Corps",
            "Drift Network",
            "Cryo Division",
            "Echo Fleet",
            "Archive Node",
            "Security Cluster",
            "Mining Authority",
          ],
          factionsN2: [
            "of",
            "for",
            "operating in",
            "under",
            "over",
            "near",
            "within",
            "against",
            "aligned with",
            "based in",
          ],
          roles: [
            "Surveyors",
            "Archivists",
            "Salvagers",
            "Datawrights",
            "Terraformers",
            "Smugglers",
            "Peacekeepers",
            "Prospectors",
            "Hackers",
            "Vigil AIs",
            "Skyfarers",
            "Signalers",
            "Cryotechs",
            "Synthbinders",
          ],
          motives: [
            "activating",
            "decrypting",
            "hacking",
            "monitoring",
            "rebooting",
          ],
          motiveGlue: [
            "the only remaining",
            "a",
            "an old",
            "a sealed",
            "a forgotten",
            "a derelict",
            "a hidden",
            "an encrypted",
          ],
          relicAdjectives: [
            "encrypted",
            "forgotten",
            "sealed",
            "quantum",
            "bio-locked",
            "holographic",
            "corrupted",
            "archived",
          ],
          relicNouns: [
            "core",
            "drive",
            "node",
            "key",
            "vault",
            "chip",
            "beacon",
            "archive",
            "relay",
            "protocol",
          ],
          pois: [
            "orbital spine",
            "seed vault",
            "phase-burned crater",
            "maglev trench",
            "signal relay",
            "data vault",
            "drift station",
          ],
          weather: [
            "static rain",
            "an ion flash",
            "dust drift",
            "signal interference",
            "electrical haze",
            "solar flare scatter",
          ],
          hooks: [
            "a ghost ping repeats each dusk",
            "a vault opens for the first time",
            "a comms blackout spreads",
            "a relay node reboots unexpectedly",
            "a drone fails to report",
            "a beacon activates without command",
          ],
          hookMods: [
            "near the <poi>",
            "inside the <poi>",
            "during <weather>",
            "as <weather> builds",
            "after <weather> clears",
          ],
          hookGlue: [
            "and",
            "but",
            "while",
            "as",
            "yet",
            "then",
            "though",
            "because",
            "even as",
            "just as",
          ],
        },

        apocalypse: {
          biome: [
            {
              name: "ruined city",
              features: {
                ruins: 0.9,
                "river-water": 0.25,
                lake: 0.15,
                ridge: 0.2,
                mycelium: 0.2,
              },
            },
            {
              name: "wasteland",
              features: {
                ruins: 0.4,
                ridge: 0.4,
                mountain: 0.3,
                "river-lava": 0.15,
                dunes: 0.25,
                "watering hole": 0.1,
                "dead trees": 0.4,
              },
            },
            {
              name: "overgrowth",
              features: {
                "river-water": 0.5,
                lake: 0.3,
                ruins: 0.35,
                mycelium: 0.5,
                lagoon: 0.2,
              },
            },
            {
              name: "floodplain",
              features: {
                "river-water": 0.75,
                lake: 0.5,
                lagoon: 0.35,
                ruins: 0.2,
                reef: 0.1,
              },
            },
            {
              name: "ash desert",
              features: {
                dunes: 0.7,
                "river-lava": 0.35,
                ridge: 0.3,
                ruins: 0.25,
                oasis: 0.15,
                "watering hole": 0.2,
                "dead trees": 0.3,
              },
            },
            {
              name: "irradiated zone",
              features: {
                ruins: 0.4,
                ridge: 0.3,
                "river-lava": 0.2,
                lake: 0.2,
                mycelium: 0.25,
              },
            },
            {
              name: "salt flats",
              features: {
                lake: 0.25,
                dunes: 0.4,
                ridge: 0.3,
                "river-water": 0.15,
                ruins: 0.2,
                oasis: 0.1,
              },
            },
            {
              name: "scrapyard dunes",
              features: {
                dunes: 0.8,
                ruins: 0.5,
                ridge: 0.3,
                "river-lava": 0.2,
                "watering hole": 0.1,
                "dead trees": 0.25,
              },
            },
            {
              name: "bunker valley",
              features: {
                mountain: 0.4,
                ridge: 0.5,
                "river-water": 0.25,
                lake: 0.2,
                ruins: 0.35,
              },
            },
            {
              name: "shattered highlands",
              features: {
                mountain: 0.7,
                ridge: 0.7,
                "river-lava": 0.25,
                ruins: 0.25,
                lake: 0.15,
                "dead trees": 0.25,
                crystals: 0.3,
              },
            },
            {
              name: "canal maze",
              features: {
                "river-water": 0.8,
                lagoon: 0.6,
                lake: 0.4,
                ruins: 0.3,
                reef: 0.1,
              },
            },
          ],
          temp: {
            1: "frost-bit",
            2: "cold",
            3: "cool",
            4: "mild",
            5: "warm",
            6: "hot",
            7: "blistering",
            8: "oven-hot",
          },
          climateAdj: [
            "rocky",
            "dusty",
            "foggy",
            "smoky",
            "cracked",
            "scarred",
            "shadowed",
            "glowing",
            "pitted",
            "overgrown",
            "sooty",
            "ashen",
            "shattered",
            "rusted",
            "abandoned",
            "buried",
            "sealed",
            "forgotten",
            "viral",
            "mutant",
            "slimed",
            "broken",
            "ruined",
            "hollow",
          ],
          factionsN1: [
            "Remnants",
            "Road Kings",
            "Canal Commune",
            "Vault Kin",
            "Scrap Choir",
            "Spore Ward",
            "Signal House",
          ],
          factionsN2: [
            "of",
            "at",
            "over",
            "under",
            "through",
            "against",
            "within",
            "near",
            "beyond",
            "inside",
            "along",
            "beneath",
          ],
          roles: [
            "Scavvers",
            "Archivists",
            "Pickers",
            "Claimants",
            "Watchers",
            "Riggers",
            "Spanners",
            "Guides",
            "Slingers",
          ],
          motives: ["claiming", "fighting", "hoarding", "towing", "trading"],
          motiveGlue: [
            "the only remaining",
            "a",
            "an old",
            "a sealed",
            "a flooded",
            "a broken",
            "a buried",
            "a rusted",
            "a forgotten",
          ],
          relicAdjectives: [
            "sealed",
            "rusted",
            "burned",
            "coded",
            "scrapped",
            "buried",
            "cracked",
            "patched",
            "irradiated",
            "forgotten",
          ],
          relicNouns: [
            "vault",
            "badge",
            "drive",
            "mask",
            "chip",
            "tag",
            "key",
            "module",
            "canister",
            "token",
            "seal",
            "crate",
          ],
          pois: [
            "interchange",
            "metro mouth",
            "signal tower",
            "mall",
            "canal gate",
            "rail cathedral",
            "salt pit",
            "water plant",
          ],
          weather: [
            "static rain",
            "polluted snow",
            "heat shimmer",
            "metallic drizzle",
            "smoke squalls",
            "acid mist",
            "radio interference",
          ],
          hooks: [
            "a treaty flag burns",
            "a convoy goes missing",
            "a bunker door opens on its own",
            "a warning light blinks without power",
            "a flare goes up with no claim",
          ],
          hookMods: [
            "near the <poi>",
            "inside the <poi>",
            "during <weather>",
            "as <weather> builds",
            "after <weather> clears",
          ],
          hookGlue: [
            "and",
            "but",
            "while",
            "as",
            "yet",
            "then",
            "though",
            "because",
            "even as",
            "just as",
          ],
        },
      };
      const fieldMotiveVerbs = [
        "guarding",
        "defending",
        "protecting",
        "restoring",
        "sealing",
        "unsealing",
        "mining",
        "harvesting",
        "excavating",
        "mapping",
        "exploring",
        "tracking",
        "studying",
        "scanning",
        "salvaging",
        "charting",
        "reclaiming",
        "repairing",
        "constructing",
        "investigating",
        "surveying",
        "patrolling",
      ];
      const npcTasks = {
        faction: [
          "recruiting new members for a difficult assignment",
          "screening applicants after a recent breach",
          "guarding a cache of supplies near <poi>",
          "guarding a sealed storehouse whose lock has begun to fail",
          "escorting a courier between safehouses",
          "escorting a dignitary through contested ground",
          "training new initiates in {protocol|discipline}",
          "drilling a response team for an expected incursion",
          "auditing {relics|records|inventories} for discrepancies",
          "investigating forged credentials circulating among allies",
          "negotiating a fragile truce over access to <poi>",
          "enforcing a disputed boundary marker near <poi>",
          "recovering a stolen insignia tied to {leadership|authority}",
          "hunting an infiltrator who knows internal routes",
          "coordinating a joint operation with an uneasy partner",
          "planning a raid or recovery mission timed with <weather>",
          "intercepting contraband moving through the biome",
          "protecting a witness scheduled to testify at a council",
          "relocating a vulnerable cell before the next crackdown",
          "disabling a rival outpost overlooking <poi>",
          "repairing a failing {ward|gate|lock|access point}",
          "attempting to reactivate a dormant asset at <poi>",
          "silencing rumors that could fracture the ranks",
          "delivering an ultimatum to a rival faction",
          "hosting a tribunal for a member accused of betrayal",
          "tracking a missing squad last seen near <poi>",
          "securing a route for a coming convoy",
          "mapping contacts and loyalties inside a contested district",
          "recovering a lost map that details hidden approaches",
          "testing a {prototype tool|ritual} under field conditions",
          "containing an outbreak of panic after <weather>",
          "negotiating trade rights in exchange for protection",
          "redistributing rations after an unexpected shortage",
          "guarding a prisoner transfer through hostile ground",
          "searching for a specialist needed to stabilize <poi>",
          "tending a wounded leader while rivals circle",
          "covering up a mistake before it becomes public",
          "investigating a sabotage incident in the faction's stores",
          "retrieving a message that must not be read by outsiders",
          "{binding|sealing|securing} a dangerous discovery at <poi>",
          "monitoring a repeating {signal|omen} tied to <poi>",
          "setting a trap for a rival team operating near <poi>",
          "running security for a clandestine meeting during <weather>",
          "conducting a census of members and dependents",
          "escorting a defector who wants asylum",
          "protecting a critical shipment during <weather>",
          "investigating why a long-trusted contact went silent",
          "clearing a safehouse compromised by an unknown contaminant",
        ],

        settlement: [
          "repairing the waterworks after <weather>",
          "patching leaks and reinforcing cisterns ahead of <weather>",
          "restoring {power|heat|light} to a key block of homes",
          "fixing a jammed {gate|lift|lock|access mechanism} at <poi>",
          "tracking a series of thefts that target essentials",
          "investigating a break-in at a storeroom near <poi>",
          "organizing a trade caravan and negotiating safe passage",
          "preparing a ration exchange with an unreliable partner",
          "hosting a tense council meeting about <poi>",
          "mediating a feud that threatens to split the community",
          "surveying new housing sites away from known hazards",
          "mapping structural risks in older {tunnels|buildings}",
          "investigating a strange illness spreading after <weather>",
          "quarantining a block and tracing the source to <poi>",
          "clearing rubble to reopen a route to <poi>",
          "reinforcing defenses after a warning sign at <poi>",
          "training volunteers for watch duty and emergency response",
          "rescuing trapped workers during <weather>",
          "finding a replacement {part|resource} the settlement can't do without",
          "recovering a lost tool kit critical to maintenance",
          "auditing stores because supplies don't match the ledgers",
          "running a controlled {burn|purge|cleanup} of a contaminated zone",
          "investigating a suspicious fire that started too cleanly",
          "negotiating a marriage {pact|adoption|sponsorship} to secure alliances",
          "settling a land claim dispute over the edge of the biome",
          "evacuating families after a new hazard appears near <poi>",
          "escorting a visiting envoy through nervous streets",
          "hosting a ceremony that must not be interrupted",
          "burying the dead and appeasing the living after a tragedy",
          "repairing communications lines after <weather>",
          "tracking why patrols keep missing check-ins near <poi>",
          "building a new market route that avoids a dangerous stretch",
          "shoring up walls and walkways before the next <weather>",
          "investigating counterfeit {tokens|ration chits|permits} circulating locally",
          "hunting down a black-market supplier poisoning the town",
          "organizing a salvage lottery that's turning violent",
          "recovering a {child|elder} who wandered toward <poi>",
          "escorting {healers|engineers} to a worksite near <poi>",
          "replacing leadership after a sudden resignation",
          "investigating a ghost story that's driving people away from <poi>",
          "securing a festival with rising tensions and hidden weapons",
          "disarming a booby trap found in a common thoroughfare",
          "patching a collapsed {tunnel|bridge} caused by <weather>",
          "moving the seed {stores|archives|reliquary} to a safer vault",
          "interviewing newcomers whose story doesn't add up",
          "negotiating protection payments under threat",
          "tracking a predator that hunts livestock near <poi>",
          "testing a new {well|route} that may be {cursed|unsafe|unstable}",
          "restoring the local map after someone altered it",
        ],

        world: [
          "mapping an new trail that skirts <poi>",
          "charting safe routes as <weather> builds",
          "guiding travelers through hostile ground to <poi>",
          "escorting {pilgrims|refugees|traders} across the biome",
          "hunting a dangerous creature seen near <poi>",
          "tracking something that leaves no prints after <weather>",
          "recovering a lost expedition last seen near <poi>",
          "searching for a missing scout who vanished during <weather>",
          "salvaging a ruined site for usable parts and supplies",
          "extracting valuable material from a hazardous zone near <poi>",
          "scouting a rival camp positioned near <poi>",
          "observing an encroaching force without being detected",
          "securing a crossing after the terrain shifts near <poi>",
          "repairing a broken {bridge|lift|passageway} at <poi>",
          "investigating why an old marker no longer matches the land",
          "following a repeating {signal|omen} that points toward <poi>",
          "{closing|sealing|stabilizing} a breach at <poi>",
          "unsealing a site at <poi> under strict precautions",
          "retrieving a {relic|container|data-cache} rumored to be in <poi>",
          "delivering a message through a zone nobody wants to cross",
          "recovering a downed {cart|sled|rig} stranded by <weather>",
          "clearing a path through {overgrowth|rubble|drifted dunes} near <poi>",
          "setting up a remote observation post overlooking <poi>",
          "testing whether the {water|air|soil} is safe beyond the ridge",
          "tracking a {poacher|scavenger crew} operating near <poi>",
          "negotiating {passage|terms} with a territorial group beyond the border",
          "discovering why local the {wildlife|fauna|tribe} avoids <poi>",
          "finding the source of strange {lights|sounds} near <poi>",
          "recovering supplies dropped during a retreat",
          "investigating an abandoned camp where everything was left behind",
          "locating a hidden {cache|<item>} mapped only in partial coordinates",
          "escorting a specialist needed to handle <poi>",
          "running a diversion to pull attention away from <poi>",
          "delivering {emergency medicine|supplies|equipment} to an isolated outpost",
          "surveying terrain for a future {settlement site|outpost|relay station}",
          "finding fresh water in a parched stretch of the biome",
          "tracking the movement of a storm front that behaves oddly",
          "recovering a stolen map and identifying who copied it",
          "investigating a boundary marker that was moved overnight",
          "following a trail of messages {carved|encoded} along the route",
          "retrieving proof of a rival's wrongdoing from <poi>",
          "rescuing captives taken toward <poi>",
          "destroying a hazard source without triggering worse consequences",
          "confirming whether <poi> is truly empty or merely silent",
          "bringing back a {sample|artifact} from <poi> without contamination",
          "finding a safer detour after <weather> made the main route impassable",
          "tracking a caravan that never arrived from the direction of <poi>",
          "retrieving a lost {heirloom|<item>} that may start a war if mishandled",
          "investigating a new {sinkhole|collapse} revealed after <weather>",
        ],
      };

      // #endregion Theme Tables
      // #region Tileset + Glyphs
      /* ====================== Tileset ========================================== */
      const tileset = {
        water: { depthGlyphs: { 1: ["~", "âˆ¾", "Ëœ", "âˆ¿", "Ë·"], 2: "â‰ˆ", 3: "â‰‹" } },
        lava: { depthGlyphs: { 1: ["~", "âˆ¾", "Ëœ", "âˆ¿"], 2: "â‰ˆ", 3: "â‰‹" } },
        plains: ["Â·", "â€§", "âˆ™"],
        beach: ["Â·", "â€§", "âˆ™"],
        grass: ["áµž", "Ë¯", "Ë¬", "Ë‡", "â€¦", "âµˆ", '"', "'"],
        forest: {
          base: ["â¯­", "ð™˜", "â†‘", "âƒ", "ðŒ’", "á»Œ", "ð™¢", "ðŠ¾", "â†Ÿ"],
          coniferous: ["âƒ", "ð™¢", "ðŠ¾"],
          dead: ["ð™˜", "â†‘", "â†Ÿ"],
          deciduous: ["ðŒ’", "á»Œ"],
        },
        desert: ["â‰ˆ"],
        mycelium: ["áµ ", "âµˆ", "Â·", "â€§", "âˆ™"],
        mountain: {
          base: ["^"],
          height: { 1: "ê˜", 2: "á¨ˆ", 3: "á´§", 4: "Î›", 5: "Î”" },
        },
        settlement: ["â›©", "âŒ‚", "ð˜®", "ð™", "ð›…", "ð›˜", "ð¡", "ð€", "ð", "ð‚§", "ðƒ€"],
        ruins: [
          "âŒ‚",
          // TODO: use linear B block to add more ruined buildings and not have crossover with settlement variants: https://unicodeplus.com/block/10000
          "ð˜®",
          "ð™",
          "ð›…",
          "ð›˜",
          "ð¡",
          "ð€",
          "ð",
          "ð‚§",
          "ðƒ€",
        ],
        camp: [
          // TODO: use linear B block to add better tents and camps: https://unicodeplus.com/block/10000
          "á—‘",
          "á°",
          "á„",
        ],
        religious: {
          death: [
            "âš±",
            "âš±ï¸",
            "âš°",
            "ðŸº",
            // "âœ",
            // "âœž",
            // "âœŸ",
          ],
          monastery: [
            "â›¨",
            "â›§",
            "â˜ª",
            "âšš",
            "âš•ï¸",
            "ðŸµ",
            "ðŸ•¯ï¸",
            // "âœ ",
            // "â˜¯",
          ],
        },
        crystal: ["Ð¶", "â©•", "ê˜", "X"],
      };

      function baseGlyphs(def) {
        if (!def) return null;
        if (Array.isArray(def)) return def;
        if (Array.isArray(def.base)) return def.base;
        if (typeof def.base === "string") return [def.base];
        return null;
      }

      function firstBaseGlyph(def, fallback = "?") {
        const base = baseGlyphs(def);
        return (base && base[0]) || fallback;
      }

      tileset["fungal-settlement"] = baseGlyphs(tileset.settlement);
      tileset["fungal-ruins"] = baseGlyphs(tileset.ruins);
      tileset["overgrown-ruins"] = baseGlyphs(tileset.ruins);

      const TILE_SET = new Set(Object.keys(tileset));

      function validateTileset(tilesetDef) {
        if (!DEBUG) return;
        for (const key of TILE_SET) {
          const def = tilesetDef[key];
          if (!def) {
            debugWarn(`Missing tileset entry for "${key}"`);
            continue;
          }
          if (key === "water" || key === "lava") {
            if (!def.depthGlyphs) {
              debugWarn(`Tileset "${key}" missing depthGlyphs`);
              continue;
            }
            for (const depth of [1, 2, 3]) {
              if (!def.depthGlyphs[depth])
                debugWarn(`Tileset "${key}" missing depthGlyphs[${depth}]`);
            }
            continue;
          }
          if (key === "mountain") {
            if (!def.height) {
              debugWarn(`Tileset "mountain" missing height map`);
              continue;
            }
            for (const h of [1, 2, 3, 4, 5]) {
              if (!def.height[h])
                debugWarn(`Tileset "mountain" missing height[${h}]`);
            }
            continue;
          }
          if (key === "religious") {
            if (!def.death || !def.monastery)
              debugWarn(
                `Tileset "religious" missing glyphs for death/monastery`,
              );
            continue;
          }
          if (!baseGlyphs(def)?.length)
            debugWarn(`Tileset "${key}" missing base glyphs`);
        }
      }

      validateTileset(tileset);

      // #endregion Tileset + Glyphs
      // #region Lexicon Data
      const syllablePool = [
        "aer",
        "al",
        "an",
        "ath",
        "bah",
        "bel",
        "bit",
        "bat",
        "bra",
        "brie",
        "bur",
        "by",
        "cal",
        "col",
        "da",
        "dei",
        "dra",
        "dul",
        "el",
        "fen",
        "fie",
        "fun",
        "fus",
        "gal",
        "gol",
        "grah",
        "gre",
        "grie",
        "hak",
        "hal",
        "hel",
        "hur",
        "ian",
        "il",
        "ins",
        "ion",
        "ios",
        "ir",
        "is",
        "ith",
        "jan",
        "jha",
        "jor",
        "ka",
        "kra",
        "kar",
        "kel",
        "kha",
        "kor",
        "lai",
        "lan",
        "lem",
        "len",
        "lha",
        "lon",
        "lor",
        "mal",
        "mar",
        "mel",
        "mes",
        "mor",
        "mor",
        "mun",
        "myr",
        "nal",
        "nel",
        "nera",
        "nir",
        "nor",
        "oa",
        "oar",
        "or",
        "ora",
        "os",
        "oth",
        "pha",
        "pil",
        "pis",
        "pol",
        "pra",
        "pul",
        "pyr",
        "qar",
        "qua",
        "rah",
        "reo",
        "ri",
        "ros",
        "ryn",
        "sat",
        "ser",
        "set",
        "sha",
        "sta",
        "tai",
        "ter",
        "thal",
        "thar",
        "ti",
        "tie",
        "to",
        "tor",
        "tra",
        "tua",
        "tur",
        "toa",
        "ume",
        "una",
        "ur",
        "uth",
        "vak",
        "vek",
        "vor",
        "yal",
        "zal",
        "zan",
        "zek",
        "zir",
        "zul",
        "zuth",
      ];
      const namePostfixes = [
        " Hold",
        " Castle",
        " Reach",
        " Fall",
        " Falls",
        " Gate",
        " Prime",
        " Camp",
        " Cliffs",
        " Fold",
        " Crown",
        " Wilds",
        " Hollow",
        " Vale",
        " Peaks",
        " Grove",
        " Keep",
        " Commune",
        " Verge",
        " Wastes",
        " Spire",
        " Fields",
        " Flats",
        " Basin",
        " Spine",
        " Fault",
        " Deep",
        " Steppe",
        " Maw",
        " Province",
      ];
      const settlementTypes = [
        "hamlet",
        "village",
        "farmstead",
        "settlement",
        "fort",
        "crossroads",
        "borough",
        "town",
        "city",
        "capital",
        "trade hub",
        "stronghold",
        "citadel",
        "bastion",
        "garrison",
        "enclave",
        "outpost",
        "fortress",
        "metropolis",
        "megacity",
      ];
      const factionNameTemplates = [
        {
          name: "Title+Lineage",
          weight: 12,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.titles)} ${rngUtil.oneOf(r, L.lineages)}`,
        },
        {
          name: "Title+Toponym",
          weight: 6,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.titles)} ${rngUtil.oneOf(r, L.toponyms)}`,
        },
        {
          name: "The+Collective+of+Role",
          weight: 16,
          build: (r, L) =>
            `The ${rngUtil.oneOf(r, L.collectives)} ${rngUtil.oneOf(r, L.prepsOf)} ${rngUtil.oneOf(r, L.roles)}`,
        },
        {
          name: "Role+of+Toponym",
          weight: 14,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.roles)} ${rngUtil.oneOf(r, L.prepsOf)} ${rngUtil.oneOf(r, L.toponyms)}`,
        },
        {
          name: "The+Collective+of+Toponym",
          weight: 12,
          build: (r, L) =>
            `The ${rngUtil.oneOf(r, L.collectives)} ${rngUtil.oneOf(r, L.prepsOf)} ${rngUtil.oneOf(r, L.toponyms)}`,
        },
        {
          name: "Abstract+of+Region",
          weight: 10,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.abstracts)} ${rngUtil.oneOf(r, L.prepsOf)} ${rngUtil.oneOf(r, L.regions)}`,
        },
        {
          name: "Toponym+Company",
          weight: 8,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.toponyms)} ${rngUtil.oneOf(r, L.tradeBodies)}`,
        },
        {
          name: "The+Nickname",
          weight: 7,
          build: (r, L) => `The ${rngUtil.oneOf(r, L.nicknames)}`,
        },
        {
          name: "Hybrid",
          weight: 9,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.titles)} ${rngUtil.oneOf(r, L.lineages)} ${rngUtil.oneOf(r, L.prepsOf)} ${rngUtil.oneOf(r, L.toponyms)}`,
        },
        {
          name: "Role+Preposition+Site",
          weight: 6,
          build: (r, L) =>
            `${rngUtil.oneOf(r, L.roles)} ${rngUtil.oneOf(r, L.prepsSite)} ${rngUtil.oneOf(r, L.sites)}`,
        },
      ];

      /* ====================== Faction naming (fixed deterministic lexicon) ====================== */
      const defaultCollectives = [
        "Order",
        "Guild",
        "Clan",
        "Court",
        "Circle",
        "Syndicate",
        "Chapter",
        "Coven",
        "Brotherhood",
        "Company",
        "League",
        "Consulate",
        "Caravan",
        "Enclave",
        "Assembly",
        "Dominion",
        "Conclave",
        "Pact",
        "Sect",
        "Keep",
        "Banner",
        "Kin",
        "House",
        "Hollow",
        "Sanctum",
        "Forge",
        "Crusade",
        "March",
        "Host",
      ];
      const defaultRoles = [
        "Wardens",
        "Archivists",
        "Bonepickers",
        "Skyfarers",
        "Prospectors",
        "Scribes",
        "Wayfinders",
        "Stormcallers",
        "Reclaimers",
        "Oathkeepers",
        "Lamplighters",
        "Seers",
        "Witchbinders",
        "Lorehunters",
        "Pathmakers",
        "Gravetenders",
        "Runesmiths",
        "Beastwalkers",
        "Spellweavers",
        "Hearthguard",
        "Frostborn",
        "Flamebearers",
        "Thornwatch",
        "Miststriders",
      ];
      const lineageRoots = [
        "Var",
        "Tor",
        "Ash",
        "Hale",
        "Brenn",
        "Keth",
        "Mor",
        "Vale",
        "Dun",
        "Rav",
        "Fen",
        "Grey",
        "Orv",
        "Nyx",
        "Cal",
        "Zan",
        "Luth",
        "Syl",
        "Drak",
        "Ael",
        "Jor",
        "Kor",
        "Lyr",
        "Vel",
        "Xan",
      ];
      const lineageSuffixes = [
        "yn",
        "ell",
        "ath",
        "ek",
        "ar",
        "os",
        "en",
        "ard",
        "ir",
        "an",
        "oth",
        "ic",
        "as",
        "is",
        "or",
        "ul",
        "em",
        "irn",
        "ur",
        "il",
        "eus",
        "ias",
      ];
      const toponymRoots = [
        "Ash",
        "Red",
        "Thorn",
        "Hollow",
        "River",
        "Stone",
        "Mist",
        "Oak",
        "Wolf",
        "Raven",
        "Sun",
        "Star",
        "Ember",
        "Frost",
        "Gold",
        "Mire",
        "Holt",
        "Rev",
        "Shale",
        "Writ",
        "Wind",
      ];
      const toponymSuffixes = [
        "mere",
        "holt",
        "gate",
        "brig",
        "brook",
        "field",
        "wood",
        "veld",
        "keep",
        "bridge",
        "ward",
        "reach",
        "shire",
        "watch",
        "march",
        "moor",
        "ford",
        "fell",
        "crest",
        "vale",
        "dell",
        "dale",
        "fen",
        "scythe",
        "glen",
        "ryn",
      ];
      const regionQualifiers = [
        "Low",
        "Upper",
        "High",
        "Outer",
        "Far",
        "Near",
        "Old",
        "New",
        "North",
        "South",
        "East",
        "West",
        "Great",
        "Little",
        "Deep",
        "Bright",
        "Dark",
        "Cold",
        "Windy",
        "Silent",
      ];
      const regionPlurals = [
        "Marches",
        "Hills",
        "Moors",
        "Flats",
        "Wastes",
        "Reaches",
        "Wards",
        "Downs",
        "Heaths",
        "Fells",
        "Glades",
        "Steppes",
        "Shires",
        "Dales",
        "Crests",
        "Vales",
        "Bogs",
        "Swamps",
        "Wilds",
        "Bluffs",
      ];
      const nicknameColors = [
        "Black",
        "Red",
        "Grey",
        "White",
        "Gold",
        "Green",
        "Blue",
        "Silver",
        "White",
        "Ash",
        "Umber",
        "Sable",
        "Crimson",
        "Azure",
        "Silver",
        "Bronze",
        "Ivory",
        "Onyx",
        "Jade",
        "Copper",
        "Scarlet",
        "Vermilion",
        "Cobalt",
        "Emerald",
        "Ruby",
        "Obsidian",
        "Topaz",
      ];
      const nicknameThings = [
        "Thorn",
        "Hand",
        "Lantern",
        "Crow",
        "Hound",
        "Spear",
        "Moth",
        "Mason",
        "Key",
        "Hammer",
        "Watch",
        "Blade",
        "Wolf",
        "Fox",
        "Raven",
        "Bear",
        "Stag",
        "Serpent",
        "Shield",
        "Arrow",
        "Flame",
        "Fang",
        "Briar",
        "Star",
        "Stone",
        "Branch",
        "Root",
      ];
      const prepsOf = [
        "of",
        "of the",
        "from",
        "from the",
        "in",
        "in the",
        "for",
        "for the",
      ];
      const prepsSite = [
        "at",
        "under",
        "within",
        "beside",
        "along",
        "near",
        "by",
        "beyond",
        "above",
        "below",
      ];
      const abstractTerms = [
        "Pact",
        "Dominion",
        "March",
        "Compact",
        "Confederacy",
        "Concord",
        "Mandate",
        "League",
        "Charter",
        "Accord",
        "Covenant",
        "Unity",
        "Alliance",
        "Fellowship",
        "Union",
      ];
      const tradeBodies = [
        "Company",
        "Charter",
        "Shipping",
        "Freight",
        "Exchange",
        "Syndicate",
        "Cartage",
        "Caravan",
        "Consortium",
        "Traders",
        "Merchants",
        "Outfit",
      ];
      const titleWords = [
        "House",
        "Clan",
        "Order",
        "Circle",
        "Court",
        "Conclave",
        "Banner",
        "Keep",
        "Forge",
        "Sanctum",
        "Host",
        "Enclave",
        "Dominion",
        "Assembly",
        "Coven",
        "Brotherhood",
        "Guild",
        "Sect",
        "Kin",
        "Company",
      ];
      const siteBases = [
        "Gate",
        "Bridge",
        "Wayhouse",
        "Watch",
        "Spire",
        "Hollow",
        "Vault",
        "Crossing",
        "Ford",
        "Hall",
        "Tower",
        "Works",
        "Outpost",
        "Station",
        "Relay",
        "Point",
        "Post",
        "Hold",
        "Camp",
        "Fort",
      ];
      const deathMarkers = [
        "ossuary",
        "cairn",
        "vault",
        "necropolis",
        "catacombs",
        "burial ground",
        "funerary mound",
        "memorial",
        "tomb",
        "crypt",
        "graveyard",
        "sepulchre",
        "cemetery",
        "mausoleum",
        "crematorium",
        "monument",
      ];
      const monasteryMarkers = [
        "Shrine",
        "Synagogue",
        "Pagoda",
        "Zendo",
        "Monastery",
        "Abbey",
        "Hermitage",
        "Sacred Grove",
        "Sacred Spring",
        "Temple",
        "Chapel",
        "Sanctum",
        "Sanctuary",
        "Stone Circle",
        "Oratory",
        "Cloister",
        "Mission",
        "Convent",
        "Cathedral",
        "Basilica",
        "Grotto",
      ];
      const deathGroups = [
        "mourners",
        "undertakers",
        "gravediggers",
        "deathwatch",
        "ossuary wardens",
        "memorialists",
        "grievers",
        "kin",
        "bereaved",
        "lamenters",
      ];
      const religiousGroups = [
        "devout",
        "ascetics",
        "clergy",
        "monks",
        "priests",
        "hermits",
        "pilgrims",
        "zealots",
        "brothers",
        "sisters",
        "cultists",
        "missionaries",
        "nuns",
        "friars",
        "elders",
        "druids",
        "seekers",
        "wayfarers",
        "penitents",
        "acolytes",
        "undertakers",
        "mediums",
        "shamans",
        "oracles",
        "prophets",
        "necromancers",
      ];
      const poiStructureKeywords = [
        "abbey",
        "bunker",
        "cathedral",
        "chapel",
        "citadel",
        "dock",
        "forge",
        "fort",
        "gate",
        "hall",
        "keep",
        "mall",
        "metro",
        "monastery",
        "outpost",
        "plant",
        "port",
        "relay",
        "sanctum",
        "settlement",
        "shrine",
        "signal",
        "spine",
        "spire",
        "station",
        "tower",
        "temple",
        "vault",
        "wayhouse",
      ];

      const biomeFeaturesByName = (() => {
        const out = {};
        for (const tt of Object.values(themes)) {
          const biomes = tt?.biome || [];
          for (const biome of biomes) {
            if (!biome) continue;
            if (typeof biome === "object") {
              const name = String(
                "name" in biome ? (biome.name ?? "") : biome,
              ).toLowerCase();
              if (name && !out[name])
                out[name] =
                  biome.features && typeof biome.features === "object"
                    ? biome.features
                    : {};
            } else if (typeof biome === "string") {
              const name = biome.toLowerCase();
              if (!out[name]) out[name] = {};
            }
          }
        }
        return out;
      })();

      /* ====================== Core Utilities ====================== */
      function resolveInlineOptions(s, r) {
        if (typeof s !== "string") return s;
        const rand = typeof r === "function" ? r : Math.random;
        return s.replace(/\{([^{}]+)\}/g, (_, body) => {
          const parts = body
            .split("|")
            .map((p) => p.trim())
            .filter((p) => p.length);
          if (!parts.length) return "";
          return parts[(rand() * parts.length) | 0];
        });
      }

      function ensure(arr, fallback) {
        return Array.isArray(arr) && arr.length ? arr : fallback;
      }

      function uniqN(n, fn) {
        const out = new Set();
        let guard = 0;
        while (out.size < n && guard++ < n * 20) out.add(fn());
        return Array.from(out);
      }

      function cartesian(a, b) {
        const out = [];
        for (let i = 0; i < a.length; i++)
          for (let j = 0; j < b.length; j++) out.push([a[i], b[j]]);
        return out;
      }

      function escAttr(s) {
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/"/g, "&quot;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function escHtml(s) {
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function escRe(s) {
        return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      function xref(cell, label) {
        return `<span class="xref" data-cell="${escAttr(cell)}">${escHtml(label)}</span>`;
      }

      function linkifyRefs(text, refs) {
        let out = escHtml(text);
        if (!Array.isArray(refs) || !refs.length) return out;
        const ordered = refs
          .map((ref) => {
            const name = String(ref?.name ?? "");
            return { ...ref, name, _escName: escHtml(name) };
          })
          .filter((ref) => ref.name.length)
          .sort((a, b) => b.name.length - a.name.length);
        for (const ref of ordered) {
          const re = new RegExp(escRe(ref._escName), "g");
          out = out.replace(re, xref(ref.cell, ref.name));
        }
        return out;
      }

      /* ====================== RNG Utilities ====================== */
      // #endregion Lexicon Data
      // #region RNG Utilities
      function h32(s) {
        let h = 5381 >>> 0;
        const str = String(s ?? "");
        for (let i = 0; i < str.length; i++)
          h = ((h * 33) ^ str.charCodeAt(i)) >>> 0;
        return h >>> 0;
      }

      function xs32(seed) {
        let x = seed >>> 0;
        return () => {
          x ^= x << 13;
          x ^= x >>> 17;
          x ^= x << 5;
          return (x >>> 0) / 4294967296;
        };
      }

      function n2(seed, x, y) {
        let v = (seed ^ ((x * 374761393) | 0) ^ ((y * 668265263) | 0)) >>> 0;
        v ^= v >>> 13;
        v = Math.imul(v, 1274126177) >>> 0;
        v ^= v >>> 16;
        return (v >>> 0) / 4294967296;
      }

      function randSeed() {
        const a = new Uint32Array(1);
        if (typeof crypto !== "undefined" && crypto.getRandomValues) {
          crypto.getRandomValues(a);
        } else {
          a[0] = (Math.random() * 4294967296) >>> 0;
        }
        return a[0].toString(36);
      }

      function oneOf(r, src) {
        if (!src) return undefined;
        if (Array.isArray(src)) {
          const picked = src[(r() * src.length) | 0];
          return resolveInlineOptions(picked, r);
        }
        if (typeof src === "object") {
          const keys = Object.keys(src);
          if (!keys.length) return undefined;
          const k = keys[(r() * keys.length) | 0];
          return resolveInlineOptions(src[k], r);
        }
        return resolveInlineOptions(src, r);
      }

      function pickWeighted(r, items) {
        const sum = items.reduce((acc, it) => acc + (it.weight || 1), 0);
        const roll = r() * sum;
        let acc = 0;
        for (const it of items) {
          acc += it.weight || 1;
          if (roll < acc) return it;
        }
        return items[items.length - 1];
      }

      function maybe(rng, chance = 0.5) {
        return typeof rng === "function"
          ? rng() < chance
          : Math.random() < chance;
      }

      function shuffleDet(r, arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = (r() * (i + 1)) | 0;
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      const rngUtil = {
        h32,
        xs32,
        n2,
        randSeed,
        oneOf,
        pickWeighted,
        shuffleDet,
        maybe,
      };

      // #endregion RNG Utilities
      // #region Naming + Lexicon Builders
      /* ====================== Naming + Lexicon ====================== */
      class NameGenerator {
        constructor(
          rng,
          { syllables = syllablePool, postfixes = namePostfixes } = {},
        ) {
          this.r = rng;
          this.syllables = syllables;
          this.postfixes = postfixes;
        }

        baseName({ allowExtraSyllable = true, apostropheChance = 0.1 } = {}) {
          const n = 2 + (allowExtraSyllable && this.r() > 0.7);
          let s = "";
          for (let i = 0; i < n; i++) {
            let syl = this.syllables[(this.r() * this.syllables.length) | 0];
            s += syl;
            
            if (i < n - 1 && maybe(this.r, apostropheChance)) {
              s += "'";
            }
          }
          return s.charAt(0).toUpperCase() + s.slice(1);
        }

        placeName() {
          let s = this.baseName();
          if (this.r() > 0.5)
            s += this.postfixes[(this.r() * this.postfixes.length) | 0];
          return s;
        }

        npcName() {
          return this.baseName();
        }
      }

      class LexiconBuilder {
        constructor(rng, themeTables) {
          this.r = rng;
          this.tt = themeTables;
        }

        buildLineages(r, count = 12) {
          return uniqN(
            count,
            () =>
              lineageRoots[(r() * lineageRoots.length) | 0] +
              lineageSuffixes[(r() * lineageSuffixes.length) | 0],
          );
        }

        buildToponyms(r, count = 20) {
          return uniqN(
            count,
            () =>
              toponymRoots[(r() * toponymRoots.length) | 0] +
              toponymSuffixes[(r() * toponymSuffixes.length) | 0],
          );
        }

        buildRegionsFromToponyms(r, tops, count = 10, regionizer_chance = 0.5) {
          return uniqN(count, () => {
            const top = tops[(r() * tops.length) | 0];
            const addRegionizer = r() < regionizer_chance;
            const addPlural = r() < 0.4;
            const rr = regionQualifiers[(r() * regionQualifiers.length) | 0];
            const prefix = addRegionizer ? rr + " " : "";
            if (addPlural) {
              const p = regionPlurals[(r() * regionPlurals.length) | 0];
              return `${prefix}${top} ${p}`;
            }
            return `${prefix}${top}`;
          });
        }

        buildNicknames(r) {
          return cartesian(nicknameColors, nicknameThings).map(
            ([c, t]) => `${c} ${t}${rngUtil.maybe(r, 0.5) ? "s" : ""}`,
          );
        }

        buildLexicon(tt, r) {
          const roles = ensure(tt.roles, defaultRoles);
          const collectives = ensure(tt.factionsN1, defaultCollectives);

          const lineages = this.buildLineages(r, 12);
          const toponyms = this.buildToponyms(r, 20);
          const regions = this.buildRegionsFromToponyms(r, toponyms, 10);
          const nicknames = this.buildNicknames(r);

          const sites = siteBases.map((s) =>
            rngUtil.maybe(r, 0.5) ? `the ${s}` : s,
          );

          return {
            roles,
            collectives,
            prepsOf,
            prepsSite,
            abstracts: abstractTerms,
            tradeBodies,
            titles: titleWords,
            lineages,
            toponyms,
            regions,
            nicknames,
            sites,
          };
        }
      }

      function factionName(r, theme = "fantasy") {
        const tt = themes[theme] || {};
        const lexicon = new LexiconBuilder(r, tt);
        const L = lexicon.buildLexicon(tt, r);
        const template = rngUtil.pickWeighted(r, factionNameTemplates);
        return template.build(r, L);
      }

      function namedPOI(nameGen, poiType) {
        const r = nameGen.r;
        const style = (r() * 4) | 0;
        const base = nameGen.placeName();
        if (style === 0) return `${base} ${poiType}`;
        if (style === 1) return `The ${poiType} of ${base}`;
        if (style === 2)
          return `${poiType.charAt(0).toUpperCase() + poiType.slice(1)} at ${base}`;
        return `${base}'s ${poiType}`;
      }

      function poiIsStructure(poiType) {
        const s = String(poiType || "").toLowerCase();
        for (const word of poiStructureKeywords) {
          if (s.includes(word)) return true;
        }
        return false;
      }

      // #endregion Naming + Lexicon Builders
      // #region World Builder
      /* ====================== World Placement ====================== */
      class WorldBuilder {
        constructor(mapGen, tileset, themeTables = themes) {
          this.mapGen = mapGen;
          this.tileset = tileset;
          this.themes = themeTables;
        }

        pickTempTier(r, tt) {
          const temp = tt?.temp;
          if (temp && typeof temp === "object" && !Array.isArray(temp)) {
            const keys = Object.keys(temp)
              .map((k) => Number(k))
              .filter((n) => Number.isFinite(n))
              .sort((a, b) => a - b);
            if (keys.length) {
              const tier = keys[(r() * keys.length) | 0];
              return { tier, label: String(temp[tier]) };
            }
          }
          const label = rngUtil.oneOf(r, temp) ?? "mild";
          return { tier: 4, label: String(label) };
        }

        pickRainIndex(r) {
          const rain = moistureLevels;
          const idx = (r() * rain.length) | 0;
          return { idx, label: String(rain[idx] || "arid") };
        }

        coord(r) {
          const lat = (r() * 160 - 80).toFixed(2),
            lon = (r() * 360 - 180).toFixed(2);
          const NS = lat >= 0 ? "N" : "S",
            EW = lon >= 0 ? "E" : "W";
          return `${Math.abs(lat)}Â° ${NS}, ${Math.abs(lon)}Â° ${EW}`;
        }

        resolvePlaceholders(s, ctx, r) {
          const base = resolveInlineOptions(s, r);
          return base
            .replace(/<poi>/g, () => ctx.poi?.() ?? "site")
            .replace(/<weather>/g, () => ctx.weather?.() ?? "weather");
        }

        stem(s) {
          return s.replace(/^(the|a|an)\s+/i, "").split(" ")[0];
        }

        composeHook(r, tt, ctx = {}) {
          const h1 = rngUtil.oneOf(r, tt.hooks);
          const m1 = rngUtil.maybe(r, 0.6)
            ? this.resolvePlaceholders(rngUtil.oneOf(r, tt.hookMods), ctx, r)
            : null;

          const hasSecond = rngUtil.maybe(r, 0.65);
          if (!hasSecond) return m1 ? `${h1} ${m1}.` : `${h1}.`;

          const glue = rngUtil.oneOf(r, tt.hookGlue);

          const h2 = (() => {
            let v;
            let guard = 0;
            do {
              v = rngUtil.oneOf(r, tt.hooks);
            } while (
              (v === h1 || this.stem(v) === this.stem(h1)) &&
              guard++ < 5
            );
            return v;
          })();

          const m2 = rngUtil.maybe(r, 0.6)
            ? this.resolvePlaceholders(rngUtil.oneOf(r, tt.hookMods), ctx, r)
            : null;

          let left = m1 ? `${h1} ${m1}` : h1;
          const right = m2 ? `${h2} ${m2}` : h2;

          left = left.charAt(0).toUpperCase() + left.slice(1);
          return `${left}, ${glue} ${right}.`;
        }

        composeMotive(
          r,
          tt,
          { adjChance = 0.6, forceAdj = false, normalizeSpacing = true } = {},
        ) {
          const motive = rngUtil.oneOf(r, fieldMotiveVerbs.concat(tt.motives));
          const glue = rngUtil.oneOf(r, tt.motiveGlue);
          const includeAdj = forceAdj || rngUtil.maybe(r, adjChance);
          const adj = includeAdj ? rngUtil.oneOf(r, tt.relicAdjectives) : null;
          const noun = rngUtil.oneOf(r, tt.relicNouns);

          let line = `${motive} ${glue} ${adj ? adj + " " : ""}${noun}`;
          if (normalizeSpacing) line = line.replace(/\s{2,}/g, " ").trim();
          return line;
        }

        buildSettlementNames(nameGen, count) {
          return uniqN(count, () => nameGen.placeName());
        }

        placeWorldRefs(
          seedU32,
          theme,
          tileKeyGrid,
          N,
          poiTypes,
          factions,
          rText,
          biome,
        ) {
          const r = rngUtil.xs32(seedU32 ^ 0xa53c9e17);

          const settlements = [];
          const land = [];

          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              const k = tileKeyGrid[y][x];
              const key = `${x},${y}`;
              if (k !== "water" && k !== "lava") land.push(key);
              if (k === "settlement" || k === "fungal-settlement")
                settlements.push(key);
            }
          }

          const settlementOrder = rngUtil.shuffleDet(r, settlements);
          const landOrder = rngUtil.shuffleDet(r, land);

          const nameGen = new NameGenerator(rText);
          const settlementNames = this.buildSettlementNames(
            nameGen,
            Math.max(6, settlements.length),
          );
          const settlementNameByCell = new Map();
          const settlementTypeByCell = new Map();
          settlements.forEach((cell, i) =>
            settlementNameByCell.set(
              cell,
              settlementNames[i % settlementNames.length],
            ),
          );
          settlements.forEach((cell) =>
            settlementTypeByCell.set(cell, rngUtil.oneOf(r, settlementTypes)),
          );

          const poiPlacements = [];
          const poiTypesExpanded = poiTypes.slice();
          const ruinsRarity = this.mapGen.biomeFeatureRarity(biome, "ruins");
          let ruinCount = 0;
          if (ruinsRarity > 0) {
            ruinCount = 1 + Math.floor(ruinsRarity * 2);
            if (r() < ruinsRarity * 0.6) ruinCount += 1;
          }

          for (let i = 0; i < poiTypesExpanded.length; i++) {
            const poiType = poiTypesExpanded[i];
            const poiName = namedPOI(nameGen, poiType);

            const cell =
              settlementOrder[i] ||
              landOrder[i] ||
              `${(seedU32 % N) | 0},${((seedU32 >>> 8) % N) | 0}`;
            poiPlacements.push({ poiType, poiName, cell });
          }

          if (ruinCount > 0) {
            let rIdx = 0;
            for (let i = 0; i < ruinCount; i++) {
              while (
                rIdx < landOrder.length &&
                (settlementNameByCell.has(landOrder[rIdx]) ||
                  poiPlacements.some((p) => p.cell === landOrder[rIdx]))
              ) {
                rIdx++;
              }
              const cell =
                landOrder[rIdx++] ||
                landOrder[0] ||
                `${(seedU32 % N) | 0},${((seedU32 >>> 8) % N) | 0}`;
              const poiType = "ruins";
              const poiName = namedPOI(nameGen, poiType);
              poiPlacements.push({ poiType, poiName, cell });
            }
          }

          const used = new Set(poiPlacements.map((p) => p.cell));
          const factionPlacements = [];

          let sIdx = poiTypes.length;
          let lIdx = poiTypes.length;

          for (let i = 0; i < factions.length; i++) {
            let cell = null;

            while (
              sIdx < settlementOrder.length &&
              used.has(settlementOrder[sIdx])
            )
              sIdx++;
            if (sIdx < settlementOrder.length) cell = settlementOrder[sIdx++];

            if (!cell) {
              while (lIdx < landOrder.length && used.has(landOrder[lIdx]))
                lIdx++;
              cell =
                landOrder[lIdx++] || landOrder[0] || `${i % N},${(i * 7) % N}`;
            }

            used.add(cell);
            factionPlacements.push({
              factionName: factions[i].name,
              motive: factions[i].motive,
              cell,
            });
          }

          const ann = new Map();
          const ensureCell = (cell) => {
            if (!ann.has(cell)) ann.set(cell, { poi: [], factions: [] });
            return ann.get(cell);
          };

          for (const cell of settlements) {
            const o = ensureCell(cell);
            o.settlementName = settlementNameByCell.get(cell);
            o.settlementType = settlementTypeByCell.get(cell);
          }

          for (const p of poiPlacements) {
            const o = ensureCell(p.cell);
            o.poi.push({ name: p.poiName, type: p.poiType });
            if (poiIsStructure(p.poiType)) o.poiStructure = true;
          }

          for (const f of factionPlacements) {
            const o = ensureCell(f.cell);
            o.factions.push({ name: f.factionName });
            if (!settlementNameByCell.has(f.cell)) o.fieldCamp = true;
          }

          const deathGroupsList = deathGroups;
          const religiousGroupsList = religiousGroups;
          const reserved = new Set([...used, ...settlements]);
          const baseDeathChance = 0.4;
          const baseMonasteryChance = 0.4;
          const decay = 0.3;
          const maxPerKind = 3;

          const rollCount = (baseChance, decayFactor, max) => {
            let count = 0;
            let p = baseChance;
            while (count < max && r() < p) {
              count++;
              p *= decayFactor;
            }
            return count;
          };

          const deathCount = rollCount(baseDeathChance, decay, maxPerKind);
          const monasteryCount = rollCount(
            baseMonasteryChance,
            decay,
            maxPerKind,
          );
          let li = 0;

          const placeReligious = (kind, count) => {
            for (let i = 0; i < count; i++) {
              let cell = null;
              while (li < landOrder.length) {
                const cand = landOrder[li++];
                if (!reserved.has(cand)) {
                  cell = cand;
                  break;
                }
              }
              if (!cell) return;

              let label = "";
              if (kind === "death") {
                label = rngUtil.oneOf(r, deathMarkers);
              } else {
                label = rngUtil.oneOf(r, monasteryMarkers);
              }
              const group =
                kind === "death"
                  ? rngUtil.oneOf(r, deathGroupsList)
                  : rngUtil.oneOf(r, religiousGroupsList);
              const deity = nameGen.baseName();
              label = `${label}: ${group} of ${deity}`;

              const o = ensureCell(cell);
              const rel = {
                kind,
                label,
                glyph: this.tileset?.religious?.[kind],
              };
              o.religious = rel;
              o.poi.push({ name: label, type: "religious" });
              poiPlacements.push({
                poiType: "religious",
                poiName: label,
                cell,
              });
              reserved.add(cell);
            }
          };

          placeReligious("death", deathCount);
          placeReligious("monastery", monasteryCount);

          return {
            annotations: ann,
            poiPlacements,
            factionPlacements,
            settlementNameByCell,
            settlementTypeByCell,
          };
        }

        buildSlice(seedStr, theme) {
          const base = rngUtil.h32(String(seedStr));
          const r = rngUtil.xs32(base);
          const tt = this.themes[theme] || this.themes.fantasy;
          const npcR = rngUtil.xs32(base ^ 0x52dce729);
          const factionOpR = rngUtil.xs32(base ^ 0x1fb77b21);
          const npcGen = new NameGenerator(npcR);
          const npcCount = 2 + ((npcR() * 3) | 0);

          const lexicon = new LexiconBuilder(r, tt);
          const toponyms = lexicon.buildToponyms(r, 20);
          const region = lexicon.buildRegionsFromToponyms(r, toponyms, 1)[0];

          const biome = this.mapGen.normalizeBiome(rngUtil.oneOf(r, tt.biome));
          const biomeName = biome.name;
          const tempPick = this.pickTempTier(r, tt);
          const rainPick = this.pickRainIndex(r, tt);
          const climA = rngUtil.oneOf(r, tt.climateAdj);
          const coords = this.coord(r);

          const climate = {
            tempTier: tempPick.tier,
            tempLabel: tempPick.label,
            rainIdx: rainPick.idx,
            rainLabel: rainPick.label,
            adj: climA,
          };

          const fCount = 1 + ((r() * 3) | 0);
          const pCount = 2 + ((r() * 3) | 0);

          const factions = [];
          for (let i = 0; i < fCount; i++) {
            const motive = this.composeMotive(r, tt);
            const name = factionName(r, theme);
            factions.push({ name, motive });
          }

          const poiTypes = [];
          for (let i = 0; i < pCount; i++)
            poiTypes.push(rngUtil.oneOf(r, tt.pois));

          const weatherNow = rngUtil.oneOf(r, tt.weather);

          const mapSeed = rngUtil.h32(seedStr + "|map|" + theme);
          const map0 = this.mapGen.genMap(
            mapSeed,
            biomeName,
            this.tileset,
            null,
            climate,
          );
          const landCells = [];
          for (let y = 0; y < map0.N; y++) {
            for (let x = 0; x < map0.N; x++) {
              if (map0.tileKeyGrid[y][x] !== "water")
                landCells.push(`${x},${y}`);
            }
          }
          const worldMeta = this.placeWorldRefs(
            mapSeed,
            theme,
            map0.tileKeyGrid,
            map0.N,
            poiTypes,
            factions,
            r,
            biomeName,
          );
          const settlementEntries = Array.from(
            worldMeta.settlementNameByCell.entries(),
          );
          const poiRefs = worldMeta.poiPlacements.map((p) => ({
            name: p.poiName,
            cell: p.cell,
          }));
          const poiNames = poiRefs.map((p) => p.name);
          const npcLocationKinds = Object.keys(npcTasks);
          const npcs = [];
          const seenNpcNames = new Set();
          let guard = 0;
          const fieldMotiveVerbSet = new Set(fieldMotiveVerbs);

          const pickCell = ({
            rng,
            cells,
            avoid = null,
            filter = null,
            fallback = "0,0",
          }) => {
            const list = Array.isArray(cells) ? cells : [];
            if (!list.length) return fallback;
            const pool = filter ? list.filter(filter) : list;
            if (!pool.length) return null;
            if (avoid === null || avoid === undefined)
              return pool[(rng() * pool.length) | 0] || fallback;
            if (pool.length <= 1) return pool[0] || fallback;
            let cell = avoid;
            for (let i = 0; i < 8 && cell === avoid; i++)
              cell = pool[(rng() * pool.length) | 0] || avoid;
            if (cell === avoid) {
              const idx = pool.indexOf(avoid);
              if (idx >= 0) return pool[(idx + 1) % pool.length];
            }
            return cell;
          };

          const pickLandCell = () => pickCell({ rng: npcR, cells: landCells });

          const pickLandCellForOps = () =>
            pickCell({ rng: factionOpR, cells: landCells });

          function pickDifferentLandCell(avoidCell) {
            return pickCell({ rng: npcR, cells: landCells, avoid: avoidCell });
          }

          const pickLandCellNear = (targetCell, maxDist) => {
            if (!targetCell) return pickLandCell();
            const parts = String(targetCell).split(",");
            const tx = Number(parts[0]);
            const ty = Number(parts[1]);
            if (!Number.isFinite(tx) || !Number.isFinite(ty))
              return pickLandCell();
            const near = pickCell({
              rng: npcR,
              cells: landCells,
              filter: (cell) => {
                const c = cell.split(",");
                const x = Number(c[0]);
                const y = Number(c[1]);
                if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
                return Math.abs(x - tx) + Math.abs(y - ty) <= maxDist;
              },
            });
            if (near) return near;
            return pickLandCell();
          };

          const pickLandCellNearDifferent = (targetCell, maxDist) => {
            if (!targetCell) return pickLandCell();
            const parts = String(targetCell).split(",");
            const tx = Number(parts[0]);
            const ty = Number(parts[1]);
            if (!Number.isFinite(tx) || !Number.isFinite(ty))
              return pickLandCell();
            const near = pickCell({
              rng: npcR,
              cells: landCells,
              filter: (cell) => {
                if (cell === targetCell) return false;
                const c = cell.split(",");
                const x = Number(c[0]);
                const y = Number(c[1]);
                if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
                return Math.abs(x - tx) + Math.abs(y - ty) <= maxDist;
              },
            });
            if (near) return near;
            return pickDifferentLandCell(targetCell);
          };

          const cellDist = (a, b) => {
            const pa = String(a || "").split(",");
            const pb = String(b || "").split(",");
            const ax = Number(pa[0]);
            const ay = Number(pa[1]);
            const bx = Number(pb[0]);
            const by = Number(pb[1]);
            if (
              !Number.isFinite(ax) ||
              !Number.isFinite(ay) ||
              !Number.isFinite(bx) ||
              !Number.isFinite(by)
            )
              return Infinity;
            return Math.abs(ax - bx) + Math.abs(ay - by);
          };

          const pickAltLocation = (avoidCell) => {
            const pool = [];
            for (const [cell, name] of settlementEntries)
              pool.push({ prep: "in", label: name, cell });
            for (const p of worldMeta.poiPlacements)
              pool.push({ prep: "at", label: p.poiName, cell: p.cell });
            const filtered = pool.filter((p) => p.cell !== avoidCell);
            if (filtered.length)
              return filtered[(npcR() * filtered.length) | 0];
            return {
              prep: "out in",
              label: "the wilds",
              cell: pickDifferentLandCell(avoidCell),
            };
          };

          const pickFactionOpLocation = (avoidCell) => {
            if (factionOpR() < 0.3) {
              return {
                prep: "out in",
                label: "the wilds",
                cell: pickLandCellNear(avoidCell, 10),
              };
            }
            const pool = [];
            for (const [cell, name] of settlementEntries)
              pool.push({ prep: "in", label: name, cell });
            for (const p of worldMeta.poiPlacements)
              pool.push({ prep: "at", label: p.poiName, cell: p.cell });
            const filtered = pool.filter(
              (p) => p.cell !== avoidCell && cellDist(p.cell, avoidCell) <= 10,
            );
            if (filtered.length)
              return filtered[(factionOpR() * filtered.length) | 0];
            return {
              prep: "out in",
              label: "the wilds",
              cell: pickLandCellNear(avoidCell, 10),
            };
          };

          const motiveVerb = (motive) =>
            String(motive || "")
              .trim()
              .split(/\s+/)[0]
              ?.toLowerCase() || "";

          const npcLocationFor = (kind) => {
            if (kind === "faction") {
              const pick = rngUtil.oneOf(npcR, worldMeta.factionPlacements);
              if (pick) {
                if (npcR() < 0.45) {
                  const alt = pickAltLocation(pick.cell);
                  return {
                    prep: alt.prep,
                    label: alt.label,
                    cell: alt.cell,
                    affiliation: {
                      prep: "for",
                      label: pick.factionName,
                      cell: pick.cell,
                    },
                  };
                }
                return {
                  prep: "with",
                  label: pick.factionName,
                  cell: pick.cell,
                };
              }
            }
            if (kind === "settlement" && settlementEntries.length) {
              const [cell, name] =
                settlementEntries[(npcR() * settlementEntries.length) | 0];
              return { prep: "in", label: name, cell };
            }
            return { prep: "out in", label: "the wilds", cell: pickLandCell() };
          };

          const npcPoiName = () => {
            if (poiNames.length) return rngUtil.oneOf(npcR, poiNames);
            return rngUtil.oneOf(npcR, tt.pois);
          };

          while (npcs.length < npcCount && guard++ < npcCount * 20) {
            const name = npcGen.npcName();
            if (seenNpcNames.has(name)) continue;
            seenNpcNames.add(name);
            const kind =
              npcLocationKinds[(npcR() * npcLocationKinds.length) | 0];
            const taskTemplate = rngUtil.oneOf(npcR, npcTasks[kind]);
            const taskPoi = npcPoiName();
            const task = this.resolvePlaceholders(
              taskTemplate,
              { poi: () => taskPoi, weather: () => weatherNow },
              npcR,
            );
            const taskHtml = linkifyRefs(task, poiRefs);
            let loc = npcLocationFor(kind);
            const taskUsesPoi = taskTemplate.includes("<poi>");
            const poiMatch = taskUsesPoi
              ? poiRefs.find((p) => p.name === taskPoi)
              : null;
            if (poiMatch) {
              // If the task already names a POI, keep the location in the wilds nearby.
              loc = {
                prep: "out in",
                label: "the wilds",
                cell: pickLandCellNearDifferent(poiMatch.cell, 5),
                affiliation: loc.affiliation,
              };
            } else if (loc.prep === "out in" && loc.label === "the wilds") {
              const nearMatch = poiRefs.find((p) => p.name === taskPoi);
              if (nearMatch)
                loc.cell = pickLandCellNearDifferent(nearMatch.cell, 5);
            }
            npcs.push({
              name,
              task,
              taskHtml,
              prep: loc.prep,
              label: loc.label,
              cell: loc.cell,
              affiliation: loc.affiliation,
            });
          }

          const factionOps = worldMeta.factionPlacements.map((fp) => {
            const verb = motiveVerb(fp.motive);
            if (!fieldMotiveVerbSet.has(verb)) return null;
            const roll = factionOpR();
            if (roll > 0.45) {
              if (roll < 0.85) {
                return {
                  verb,
                  prep: "out in",
                  label: "the wilds",
                  cell: pickLandCellNear(fp.cell, 10),
                };
              }
              return null;
            }
            return { verb, ...pickFactionOpLocation(fp.cell) };
          });

          factionOps.forEach((op, i) => {
            if (!op) return;
            const fp = worldMeta.factionPlacements[i];
            let a = worldMeta.annotations.get(op.cell);
            if (!a) {
              a = { poi: [], factions: [] };
              worldMeta.annotations.set(op.cell, a);
            }
            if (!a.factionOps) a.factionOps = [];
            a.factionOps.push({ name: fp.factionName, verb: op.verb });
          });

          for (const npc of npcs) {
            let a = worldMeta.annotations.get(npc.cell);
            if (!a) {
              a = { poi: [], factions: [] };
              worldMeta.annotations.set(npc.cell, a);
            }
            if (!a.npcs) a.npcs = [];
            a.npcs.push({ name: npc.name, task: npc.task });
          }

          const map1 = this.mapGen.genMap(
            mapSeed,
            biomeName,
            this.tileset,
            worldMeta,
            climate,
          );
          const hookPick = rngUtil.oneOf(r, worldMeta.poiPlacements);
          const hookPOIName = hookPick
            ? hookPick.poiName
            : rngUtil.oneOf(r, tt.pois);
          const hookPOICell = hookPick ? hookPick.cell : null;

          const hook = this.composeHook(r, tt, {
            poi: () => hookPOIName,
            weather: () => rngUtil.oneOf(r, tt.weather),
          });

          let hookHtml = escHtml(hook);
          if (hookPick && hookPOIName) {
            const re = new RegExp(escRe(hookPOIName), "g");
            hookHtml = hookHtml.replace(re, xref(hookPOICell, hookPOIName));
          }

          let html = "";
          html += `Theme  : ${escHtml(theme)}\n`;
          html += `Region : ${escHtml(region)}\n`;
          html += `Biome  : ${escHtml(biomeName)}\n`;
          html += `Coords : ${escHtml(coords)}\n`;
          html += `Climate: ${escHtml(tempPick.label)}, ${escHtml(rainPick.label)}, ${escHtml(climA)}\n`;
          html += `Current Weather: ${escHtml(weatherNow)}\n\n`;

          html += `Factions (${factions.length}):\n`;
          worldMeta.factionPlacements.forEach((fp, i) => {
            const baseAnn = worldMeta.annotations.get(fp.cell);
            const baseName = baseAnn?.settlementName
              ? baseAnn.settlementName
              : "Field Camp";
            html += `  ${i + 1}. ${xref(fp.cell, fp.factionName)}\n`;
            const op = factionOps[i];
            html += `\t- ${escHtml(fp.motive)}`;
            if (op) {
              html += ` ${escHtml(op.prep)} ${xref(op.cell, op.label)} @ (${escHtml(op.cell)})`;
            }
            html += "\n";
            html += `\t- Base: ${xref(fp.cell, baseName)} @ (${escHtml(fp.cell)})\n`;
            html += "\n";
          });

          html += `NPCs (${npcs.length}):\n`;
          npcs.forEach((npc) => {
            let line = `  - ${escHtml(npc.name)}: ${npc.taskHtml}`;
            if (npc.affiliation) {
              line += ` ${escHtml(npc.affiliation.prep)} ${xref(npc.affiliation.cell, npc.affiliation.label)}`;
            }
            line += ` ${escHtml(npc.prep)} ${xref(npc.cell, npc.label)}\n`;
            html += line;
          });
          html += "\n";

          html += `Points of Interest (${worldMeta.poiPlacements.length}):\n`;
          worldMeta.poiPlacements.forEach((p) => {
            const a = worldMeta.annotations.get(p.cell);
            const near = a?.settlementName
              ? `, near ${xref(p.cell, a.settlementName)}`
              : "";
            html += `  - ${xref(p.cell, p.poiName)}${near} @ (${escHtml(p.cell)})\n`;
          });

          html += `\nHook: ${hookHtml}\n`;

          const biomeLower = biomeName.toLowerCase();
          const mapFlags = {
            deadTrees: this.mapGen.biomeAllowsFeature(
              biomeName,
              "dead trees",
              0.2,
            ),
            desert: biomeLower.includes("desert"),
          };

          return { html, mapGrid: map1.html, mapFlags };
        }
      }

      // #endregion World Builder
      // #region Map Generation
      /* ====================== Map Generation ====================== */
      class MapGenerator {
        constructor() {}

        normalizeWeights(weights) {
          const total = Object.values(weights).reduce((a, b) => a + b, 0) || 1;
          for (const k in weights) weights[k] /= total;
        }

        normalizeBiomeFeatures(features, fallbackRarity = 0.3) {
          const clampRarity = (value) => Math.max(0, Math.min(1, value));
          if (!features) return {};
          if (Array.isArray(features)) {
            const out = {};
            for (const f of features) {
              if (typeof f === "string") {
                validateFeatureName(f, "biome.features");
                out[f] = fallbackRarity;
                continue;
              }
              if (f && typeof f === "object") {
                const id = "id" in f ? f.id : "name" in f ? f.name : "";
                const rarity = Number.isFinite(f.rarity)
                  ? clampRarity(Number(f.rarity))
                  : fallbackRarity;
                if (id) {
                  validateFeatureName(String(id), "biome.features");
                  out[String(id)] = rarity;
                }
              }
            }
            return out;
          }
          if (typeof features === "object") {
            const out = {};
            for (const [key, value] of Object.entries(features)) {
              if (!key) continue;
              validateFeatureName(String(key), "biome.features");
              const rarity = Number.isFinite(value)
                ? clampRarity(Number(value))
                : fallbackRarity;
              out[String(key)] = rarity;
            }
            return out;
          }
          return {};
        }

        normalizeBiome(biome) {
          const defaultFeatures = {};
          if (!biome) return { name: "", features: {} };
          if (typeof biome === "string") {
            const known = this.normalizeBiomeFeatures(
              biomeFeaturesByName[biome.toLowerCase()],
            );
            return {
              name: biome,
              features: Object.keys(known).length ? known : defaultFeatures,
            };
          }
          if (typeof biome === "object") {
            const name =
              "name" in biome ? String(biome.name ?? "") : String(biome);
            const features = this.normalizeBiomeFeatures(biome.features);
            if (Object.keys(features).length) return { name, features };
            const known = this.normalizeBiomeFeatures(
              biomeFeaturesByName[name.toLowerCase()],
            );
            return {
              name,
              features: Object.keys(known).length ? known : defaultFeatures,
            };
          }
          return { name: String(biome), features: defaultFeatures };
        }

        biomeFeatureRarity(biome, id) {
          validateFeatureName(String(id), "feature lookup");
          const { features } = this.normalizeBiome(biome);
          const rarity = features?.[id];
          return Number.isFinite(rarity) ? rarity : 0;
        }

        biomeAllowsFeature(biome, id, minRarity = 0.25) {
          validateFeatureName(String(id), "feature lookup");
          const { features } = this.normalizeBiome(biome);
          const rarity = features?.[id];
          return Number.isFinite(rarity) && rarity >= minRarity;
        }

        tileWeightsForBiome(biome) {
          const baseWeights = {
            water: 0.12,
            mountain: 0.15,
            forest: 0.25,
            grass: 0.2,
            plains: 0.28,
          };
          const inc = (k, f) =>
            (baseWeights[k] = Math.max(0.01, baseWeights[k] * f));
          if (
            String(biome || "")
              .toLowerCase()
              .includes("desert")
          ) {
            inc("forest", 0.45);
            inc("grass", 0.6);
            inc("plains", 1.35);
            inc("water", 0.85);
            inc("mountain", 1.05);
          }
          const { features } = this.normalizeBiome(biome);
          const applyFeature = (id, minRarity, fn) => {
            const rarity = features?.[id];
            if (!Number.isFinite(rarity) || rarity < minRarity) return;
            fn(rarity);
          };

          applyFeature("dunes", 0.05, (rarity) => {
            inc("plains", 1 + rarity * 1.2);
            inc("forest", 1 - rarity * 0.6);
            inc("grass", 1 - rarity * 0.4);
            inc("water", 1 - rarity * 0.4);
            inc("mountain", 1 - rarity * 0.2);
          });

          applyFeature("oasis", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.5);
            inc("grass", 1 + rarity * 0.8);
            inc("forest", 1 + rarity * 0.4);
            inc("plains", 1 - rarity * 0.2);
          });

          applyFeature("river-water", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.0);
            inc("plains", 1 - rarity * 0.1);
          });

          applyFeature("river-lava", 0.05, (rarity) => {
            inc("mountain", 1 + rarity * 0.5);
            inc("plains", 1 + rarity * 0.2);
            inc("water", 1 - rarity * 0.4);
          });

          applyFeature("lake", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.4);
            inc("plains", 1 - rarity * 0.2);
          });

          applyFeature("reef", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.6);
            inc("plains", 1 - rarity * 0.3);
          });

          applyFeature("lagoon", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.3);
            inc("plains", 1 - rarity * 0.25);
          });

          applyFeature("beaches", 0.05, (rarity) => {
            inc("water", 1 + rarity * 0.6);
            inc("plains", 1 + rarity * 0.4);
          });

          applyFeature("mountain", 0.05, (rarity) => {
            inc("mountain", 1 + rarity * 1.5);
            inc("plains", 1 + rarity * 0.2);
            inc("forest", 1 - rarity * 0.1);
            inc("grass", 1 - rarity * 0.1);
          });

          applyFeature("ridge", 0.05, (rarity) => {
            inc("mountain", 1 + rarity * 1.1);
            inc("plains", 1 + rarity * 0.15);
            inc("forest", 1 - rarity * 0.1);
            inc("grass", 1 - rarity * 0.1);
          });

          applyFeature("ruins", 0.05, (rarity) => {
            inc("plains", 1 + rarity * 0.2);
            inc("grass", 1 + rarity * 0.2);
          });

          applyFeature("mycelium", 0.05, (rarity) => {
            inc("forest", 1 + rarity * 0.5);
            inc("grass", 1 + rarity * 0.4);
          });

          applyFeature("crystals", 0.05, (rarity) => {
            inc("plains", 1 + rarity * 0.5);
            inc("forest", 1 - rarity * 0.45);
            inc("grass", 1 - rarity * 0.35);
            inc("water", 1 - rarity * 0.2);
          });

          applyFeature("dead trees", 0.05, (rarity) => {
            inc("forest", 1 - rarity * 0.2);
            inc("grass", 1 - rarity * 0.15);
            inc("plains", 1 + rarity * 0.1);
          });

          applyFeature("watering hole", 0.05, (rarity) => {
            inc("water", 1 + rarity * 1.2);
            inc("grass", 1 + rarity * 0.4);
            inc("plains", 1 - rarity * 0.2);
          });

          this.normalizeWeights(baseWeights);
          return baseWeights;
        }

        pickByWeights(x, weights) {
          const keys = Object.keys(weights);
          let acc = 0;
          for (let i = 0; i < keys.length; i++) {
            const k = keys[i];
            acc += weights[k];
            if (x <= acc) return k;
          }
          return keys[keys.length - 1];
        }

        pickVariant(tileKey, tileset, seed) {
          const def = tileset[tileKey] || tileset.plains;
          const variants = baseGlyphs(def) || baseGlyphs(tileset.plains) || [];
          const index = Math.floor(seed * variants.length);
          return variants[index] || firstBaseGlyph(tileset.plains, "?");
        }

        genMap(seedU32, biome, tileset, worldMeta = null, climate = null) {
          const N = 25;
          const weights = this.tileWeightsForBiome(biome);
          const normalizeWeights = this.normalizeWeights.bind(this);
          const pickByWeights = this.pickByWeights.bind(this);
          const biomeAllowsFeature = this.biomeAllowsFeature.bind(this);
          const biomeFeatureRarity = this.biomeFeatureRarity.bind(this);
          maybeApplyMountainBias(seedU32, weights, normalizeWeights);
          const { riverType, river } = buildRiver(
            seedU32,
            biome,
            N,
            biomeAllowsFeature,
          );
          let tileKeyGrid = initGrid(N, "plains");
          tileKeyGrid = applyInitialTiles(
            seedU32,
            tileKeyGrid,
            weights,
            N,
            riverType,
            river,
            pickByWeights,
          );

          const ridgeRarity = biomeFeatureRarity(biome, "ridge");
          tileKeyGrid = smoothMountains(
            seedU32,
            tileKeyGrid,
            weights,
            N,
            2,
            pickByWeights,
          );
          tileKeyGrid = thinRidges(
            seedU32,
            tileKeyGrid,
            weights,
            N,
            ridgeRarity,
            pickByWeights,
          );
          tileKeyGrid = applyDunePatches(
            seedU32,
            tileKeyGrid,
            N,
            biomeFeatureRarity(biome, "dunes"),
          );
          const desertAll = desertAllEnabled(seedU32, biome);
          tileKeyGrid = applyDesertAll(tileKeyGrid, N, desertAll);
          const oasisResult = applyOasisPatches(
            seedU32,
            tileKeyGrid,
            N,
            biomeFeatureRarity(biome, "oasis"),
          );
          tileKeyGrid = oasisResult.grid;
          const oasisVeg = oasisResult.oasisVeg;
          tileKeyGrid = thinDesertForests(
            seedU32,
            tileKeyGrid,
            N,
            biome,
            climate,
            oasisVeg,
          );
          tileKeyGrid = applyMyceliumPatches(
            seedU32,
            tileKeyGrid,
            N,
            biomeFeatureRarity(biome, "mycelium"),
          );
          tileKeyGrid = applyCrystalPatches(
            seedU32,
            tileKeyGrid,
            N,
            biomeFeatureRarity(biome, "crystals"),
          );
          const ruinCenters =
            worldMeta?.poiPlacements?.filter((p) => p.poiType === "ruins") ||
            [];
          tileKeyGrid = applyRuinsClusters(
            seedU32,
            tileKeyGrid,
            N,
            ruinCenters,
            biomeFeatureRarity(biome, "ruins"),
          );
          tileKeyGrid = applyOvergrownRuins(
            seedU32,
            tileKeyGrid,
            N,
            climate,
          );
          tileKeyGrid = applyLavaEdge(tileKeyGrid, N);
          tileKeyGrid = cleanupIsolatedWater(
            seedU32,
            tileKeyGrid,
            weights,
            N,
            pickByWeights,
          );
          tileKeyGrid = cleanupIsolatedWater(
            seedU32,
            tileKeyGrid,
            weights,
            N,
            pickByWeights,
          );

          const depthGrid = buildDepthGrid(
            seedU32,
            tileKeyGrid,
            river,
            N,
            riverType || "water",
          );
          tileKeyGrid = applyBeachPatches(seedU32, tileKeyGrid, depthGrid, N);
          let heightGrid = buildHeightGrid(tileKeyGrid, N);
          heightGrid = boostMountainHeights(
            heightGrid,
            tileKeyGrid,
            N,
            ridgeRarity,
          );
          const forestTypeGrid = buildForestTypeGrid(
            seedU32,
            tileKeyGrid,
            N,
            biome,
            climate,
            oasisVeg,
            biomeAllowsFeature,
          );
          const html = renderMapHtml(
            seedU32,
            tileKeyGrid,
            depthGrid,
            heightGrid,
            forestTypeGrid,
            N,
            worldMeta,
            tileset,
            this.pickVariant.bind(this),
          );

          return {
            html,
            tileKeyGrid,
            depthGrid,
            heightGrid,
            forestTypeGrid,
            N,
            river,
          };
        }
      }

      const mapGenerator = new MapGenerator();
      const worldBuilder = new WorldBuilder(mapGenerator, tileset);

      function riverCells(seedU32, N) {
        const cells = new Set();
        const rand = rngUtil.xs32(seedU32 ^ 0x6d2b79f5);
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];

        const addCells = (x, y, width) => {
          const nx = x;
          const ny = y;
          if (nx < 0 || nx >= N || ny < 0 || ny >= N) return;
          cells.add(`${nx},${ny}`);
          if (width <= 1) return;
          const spill = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ];
          for (const [ox, oy] of spill) {
            const sx = x + ox;
            const sy = y + oy;
            if (sx < 0 || sx >= N || sy < 0 || sy >= N) continue;
            cells.add(`${sx},${sy}`);
          }
        };

        const pickDir = () => dirs[(rand() * dirs.length) | 0];
        const downhillAngle = rand() * Math.PI * 2;
        const downhill = {
          x: Math.cos(downhillAngle),
          y: Math.sin(downhillAngle),
        };
        const margin = Math.max(3, Math.floor(N * 0.08));
        const startFromEdge = () => {
          if (Math.abs(downhill.x) > Math.abs(downhill.y)) {
            const x = downhill.x > 0 ? -margin : N - 1 + margin;
            const y = (rand() * N) | 0;
            return { x, y };
          }
          const x = (rand() * N) | 0;
          const y = downhill.y > 0 ? -margin : N - 1 + margin;
          return { x, y };
        };
        const flowDirForCell = (x, y) => {
          const n1 = rngUtil.n2(seedU32, 81000 + x, 82000 + y);
          const n2 = rngUtil.n2(seedU32, 83000 + x, 84000 + y);
          const ang = n1 * Math.PI * 2;
          const mag = 0.45 + n2 * 0.35;
          const vx = downhill.x + Math.cos(ang) * mag;
          const vy = downhill.y + Math.sin(ang) * mag;
          const len = Math.hypot(vx, vy) || 1;
          return { x: vx / len, y: vy / len };
        };
        const pickBiasedDir = (x, y) => {
          const v = flowDirForCell(x, y);
          let best = null;
          let sum = 0;
          const weights = [];
          for (const d of dirs) {
            const dot = d[0] * v.x + d[1] * v.y;
            const w = Math.max(0.02, 0.18 + Math.max(0, dot) * 0.95);
            weights.push(w);
            sum += w;
          }
          let t = rand() * sum;
          for (let i = 0; i < dirs.length; i++) {
            t -= weights[i];
            if (t <= 0) {
              best = dirs[i];
              break;
            }
          }
          return best || dirs[0];
        };
        const lenMain = Math.floor(N * (1.8 + rand() * 0.9));
        const startPos = startFromEdge();
        const start = {
          x: startPos.x,
          y: startPos.y,
          len: lenMain,
          width: 2,
          branchChance: 0.03,
          turnChance: 0.32,
          dir: pickBiasedDir(startPos.x, startPos.y),
        };

        const queue = [start];
        while (queue.length) {
          const p = queue.pop();
          let x = p.x;
          let y = p.y;
          let dx = p.dir[0];
          let dy = p.dir[1];

          for (let i = 0; i < p.len; i++) {
            const width = p.width;
            addCells(x, y, width);

            if (rand() < p.branchChance && p.len - i > 8) {
              queue.push({
                x,
                y,
                len: Math.floor(p.len * (0.45 + rand() * 0.2)),
                width: 2,
                branchChance: p.branchChance * 0.6,
                turnChance: p.turnChance * 0.85,
                dir: pickBiasedDir(x, y),
              });
            }

            if (rand() < p.turnChance) {
              const nd = pickBiasedDir(x, y);
              dx = nd[0];
              dy = nd[1];
            }

            x += dx;
            y += dy;

            if (
              x < -margin ||
              x > N - 1 + margin ||
              y < -margin ||
              y > N - 1 + margin
            )
              break;
          }
        }
        return cells;
      }

      /* ====================== Shared grid helpers ====================== */
      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }

      function neighbors4(N, x, y) {
        const out = [];
        if (y > 0) out.push([x, y - 1]);
        if (x < N - 1) out.push([x + 1, y]);
        if (y < N - 1) out.push([x, y + 1]);
        if (x > 0) out.push([x - 1, y]);
        return out;
      }

      function neighbors8(N, x, y) {
        const out = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx,
              ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < N && ny < N) out.push([nx, ny]);
          }
        }
        return out;
      }

      function countNeighbors8Of(tileKeyGrid, N, x, y, key) {
        let c = 0;
        for (const [nx, ny] of neighbors8(N, x, y))
          if (tileKeyGrid[ny][nx] === key) c++;
        return c;
      }

      function countWaterNeighbors4(tileKeyGrid, N, x, y) {
        const neigh = neighbors4(N, x, y);
        let c = 0;
        for (const [nx, ny] of neigh) if (tileKeyGrid[ny][nx] === "water") c++;
        return c;
      }

      function cleanupIsolatedWater(
        seedU32,
        tileKeyGrid,
        weights,
        N,
        pickByWeights,
      ) {
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "water") continue;
            const waterN4 = countWaterNeighbors4(tileKeyGrid, N, x, y);
            if (waterN4 >= 2) continue;

            const cand = new Map();
            for (const [nx, ny] of neighbors4(N, x, y)) {
              const k = tileKeyGrid[ny][nx];
              if (!k || k === "water" || k === "settlement") continue;
              cand.set(k, (cand.get(k) || 0) + 1);
            }

            let replacement = null;

            if (cand.size) {
              const entries = Array.from(cand.entries());
              entries.sort((a, b) => b[1] - a[1]);
              const topCount = entries[0][1];
              const tied = entries
                .filter((e) => e[1] === topCount)
                .map((e) => e[0]);
              if (tied.length === 1) replacement = tied[0];
              else {
                const roll = rngUtil.n2(seedU32, 19000 + x, 19100 + y);
                replacement = tied[Math.floor(roll * tied.length)];
              }
            } else {
              const roll = rngUtil.n2(seedU32, 19200 + x, 19300 + y);
              const w2 = { ...weights };
              delete w2.water;
              delete w2.settlement;
              const total = Object.values(w2).reduce((a, b) => a + b, 0) || 1;
              for (const k in w2) w2[k] /= total;
              replacement = pickByWeights(roll, w2);
            }

            next[y][x] = replacement || "plains";
          }
        }
        return next;
      }

      // Deterministic "make ranges" pass.
      function smoothMountains(
        seedU32,
        tileKeyGrid,
        weights,
        N,
        rounds = 2,
        pickByWeights,
      ) {
        let cur = tileKeyGrid.map((row) => row.slice());

        for (let round = 0; round < rounds; round++) {
          const next = cur.map((row) => row.slice());

          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              const k = cur[y][x];
              if (k === "water" || k === "settlement") continue;

              const m8 = countNeighbors8Of(cur, N, x, y, "mountain");
              const roll = rngUtil.n2(
                seedU32,
                54000 + round * 1000 + x,
                54100 + round * 1000 + y,
              );

              if (k === "mountain") {
                if (m8 <= 2 && roll < 0.8) {
                  const w2 = { ...weights };
                  delete w2.water;
                  delete w2.settlement;
                  delete w2.mountain;
                  const total =
                    Object.values(w2).reduce((a, b) => a + b, 0) || 1;
                  for (const kk in w2) w2[kk] /= total;
                  next[y][x] = pickByWeights(roll, w2);
                } else if (m8 === 3 && roll < 0.35) {
                  const w2 = { ...weights };
                  delete w2.water;
                  delete w2.settlement;
                  delete w2.mountain;
                  const total =
                    Object.values(w2).reduce((a, b) => a + b, 0) || 1;
                  for (const kk in w2) w2[kk] /= total;
                  next[y][x] = pickByWeights(roll, w2);
                }
              } else {
                if (m8 >= 5 && roll < 0.45) next[y][x] = "mountain";
                else if (m8 === 4 && roll < 0.2) next[y][x] = "mountain";
              }
            }
          }

          cur = next;
        }

        return cur;
      }

      function thinRidges(
        seedU32,
        tileKeyGrid,
        weights,
        N,
        ridgeRarity,
        pickByWeights,
      ) {
        if (!Number.isFinite(ridgeRarity) || ridgeRarity <= 0)
          return tileKeyGrid;
        let cur = tileKeyGrid.map((row) => row.slice());
        const erosionChance = clamp(0.35 + ridgeRarity * 0.35, 0.35, 0.75);
        const growthChance = clamp(0.1 + ridgeRarity * 0.2, 0.1, 0.35);

        const isMountain = (x, y, grid) =>
          x >= 0 && y >= 0 && x < N && y < N && grid[y][x] === "mountain";
        const isStraight = (x, y, grid) => {
          const north = isMountain(x, y - 1, grid);
          const south = isMountain(x, y + 1, grid);
          const east = isMountain(x + 1, y, grid);
          const west = isMountain(x - 1, y, grid);
          return (north && south) || (east && west);
        };

        for (let round = 0; round < 1; round++) {
          const next = cur.map((row) => row.slice());
          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              const k = cur[y][x];
              if (k === "water" || k === "settlement") continue;

              const m8 = countNeighbors8Of(cur, N, x, y, "mountain");
              const straight = isStraight(x, y, cur);
              const roll = rngUtil.n2(
                seedU32,
                56000 + round * 1000 + x,
                56100 + round * 1000 + y,
              );

              if (k === "mountain") {
                if (!straight && m8 <= 3 && roll < erosionChance) {
                  const w2 = { ...weights };
                  delete w2.water;
                  delete w2.settlement;
                  delete w2.mountain;
                  const total =
                    Object.values(w2).reduce((a, b) => a + b, 0) || 1;
                  for (const kk in w2) w2[kk] /= total;
                  next[y][x] = pickByWeights(roll, w2);
                }
              } else {
                const straightNeighbor = isStraight(x, y, cur);
                if (straightNeighbor && roll < growthChance * 1.8)
                  next[y][x] = "mountain";
                else if (m8 >= 6 && roll < growthChance)
                  next[y][x] = "mountain";
              }
            }
          }
          cur = next;
        }
        return cur;
      }

      /* ====================== Water depth via distance-to-land + smoothing ====================== */
      function liquidGlyph(tileKey, depth, tileset, seedU32, x, y) {
        const t = tileset[tileKey] || tileset.water;
        const glyph =
          t.depthGlyphs[depth] ||
          t.depthGlyphs[1] ||
          firstBaseGlyph(tileset.plains, "?");
        if (Array.isArray(glyph)) {
          const roll = Number.isFinite(seedU32)
            ? rngUtil.n2(seedU32, 88000 + x, 88100 + y)
            : Math.random();
          return (
            glyph[Math.floor(roll * glyph.length)] ||
            glyph[0] ||
            firstBaseGlyph(tileset.plains, "?")
          );
        }
        return glyph;
      }

      function distToNonLiquid(tileKeyGrid, N, liquidKey) {
        const INF = 1e9;
        const dist = Array.from({ length: N }, () => Array(N).fill(INF));

        const qx = new Int16Array(N * N);
        const qy = new Int16Array(N * N);
        let head = 0,
          tail = 0;

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) {
              dist[y][x] = 0;
              qx[tail] = x;
              qy[tail] = y;
              tail++;
            }
          }
        }

        while (head < tail) {
          const x = qx[head],
            y = qy[head];
          head++;
          const d = dist[y][x];

          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (dist[ny][nx] > d + 1) {
              dist[ny][nx] = d + 1;
              qx[tail] = nx;
              qy[tail] = ny;
              tail++;
            }
          }
        }

        return dist;
      }

      function smoothDepthsTodo2(
        seedU32,
        tileKeyGrid,
        depthGrid,
        N,
        liquidKey,
      ) {
        const next = depthGrid.map((row) => row.slice());

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            if (next[y][x] <= 1) continue;

            let hasPlainsOrGrass = false;
            for (const [nx, ny] of neighbors8(N, x, y)) {
              if (
                tileKeyGrid[ny][nx] === "plains" ||
                tileKeyGrid[ny][nx] === "grass"
              ) {
                hasPlainsOrGrass = true;
                break;
              }
            }
            if (!hasPlainsOrGrass) continue;
            next[y][x] = 1;
          }
        }

        const next2 = next.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            if (next[y][x] !== 3) continue;

            let touches1 = false;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (tileKeyGrid[ny][nx] === liquidKey && next[ny][nx] === 1) {
                touches1 = true;
                break;
              }
            }
            if (!touches1) continue;

            const roll = rngUtil.n2(seedU32, 62000 + x, 62100 + y);
            if (roll < 0.5) next2[y][x] = 2;
          }
        }

        return next2;
      }

      function bumpDepthCenters(tileKeyGrid, depthGrid, N, liquidKey) {
        const next = depthGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            const d = depthGrid[y][x];
            if (d >= 3) continue;
            let sameOrHigher = true;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (tileKeyGrid[ny][nx] !== liquidKey || depthGrid[ny][nx] < d) {
                sameOrHigher = false;
                break;
              }
            }
            if (sameOrHigher) next[y][x] = d + 1;
          }
        }
        return next;
      }

      function buildDepthGrid(
        seedU32,
        tileKeyGrid,
        river,
        N,
        liquidKey = "water",
      ) {
        const dist = distToNonLiquid(tileKeyGrid, N, liquidKey);

        const depthGrid = Array.from({ length: N }, () => Array(N).fill(0));
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== liquidKey) continue;
            let d = clamp(dist[y][x], 1, 3);
            if (river?.has(`${x},${y}`)) d = Math.max(d, 2);
            depthGrid[y][x] = d;
          }
        }

        const smoothed = smoothDepthsTodo2(
          seedU32,
          tileKeyGrid,
          depthGrid,
          N,
          liquidKey,
        );
        return bumpDepthCenters(tileKeyGrid, smoothed, N, liquidKey);
      }

      function applyLavaEdge(tileKeyGrid, N) {
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "lava") continue;
            for (const [nx, ny] of neighbors8(N, x, y)) {
              const k = tileKeyGrid[ny][nx];
              if (k === "mountain" || k === "water") continue;
              next[ny][nx] = "lava";
            }
          }
        }
        return next;
      }

      /* ====================== Mountain height via distance-to-non-mountain ====================== */
      function distToNonMountain(tileKeyGrid, N) {
        const INF = 1e9;
        const dist = Array.from({ length: N }, () => Array(N).fill(INF));

        const qx = new Int16Array(N * N);
        const qy = new Int16Array(N * N);
        let head = 0,
          tail = 0;

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") {
              dist[y][x] = 0;
              qx[tail] = x;
              qy[tail] = y;
              tail++;
            }
          }
        }

        while (head < tail) {
          const x = qx[head],
            y = qy[head];
          head++;
          const d = dist[y][x];

          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (dist[ny][nx] > d + 1) {
              dist[ny][nx] = d + 1;
              qx[tail] = nx;
              qy[tail] = ny;
              tail++;
            }
          }
        }
        return dist;
      }

      function buildHeightGrid(tileKeyGrid, N) {
        const dist = distToNonMountain(tileKeyGrid, N);
        const heightGrid = Array.from({ length: N }, () => Array(N).fill(0));
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") continue;
            const d = dist[y][x];
            const h = 1 + Math.floor((d - 1) * 2.2);
            heightGrid[y][x] = clamp(h, 1, 5);
          }
        }
        return heightGrid;
      }

      function mountainGlyph(h, tileset) {
        return (
          tileset.mountain.height[h] ||
          tileset.mountain.height[1] ||
          firstBaseGlyph(tileset.mountain) ||
          firstBaseGlyph(tileset.plains, "?")
        );
      }

      function applyDunePatches(seedU32, tileKeyGrid, N, rarity) {
        if (rarity <= 0) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x3e9b1d2f);
        const patches = Math.max(1, Math.floor(1 + rarity * 4));
        const totalCells = Math.floor(N * N * (0.05 + rarity * 0.12));
        const stepsPerPatch = Math.max(10, Math.floor(totalCells / patches));
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];

        const pickStart = () => {
          for (let tries = 0; tries < 100; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (k !== "water" && k !== "mountain" && k !== "settlement")
              return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          let { x, y } = pickStart();
          for (let i = 0; i < stepsPerPatch; i++) {
            if (x < 0 || x >= N || y < 0 || y >= N) break;
            const k = next[y][x];
            if (k !== "water" && k !== "mountain" && k !== "settlement")
              next[y][x] = "desert";
            const d = dirs[(rand() * dirs.length) | 0];
            if (rand() < 0.2) {
              x = clamp(x + d[0] + (rand() < 0.5 ? d[0] : 0), 0, N - 1);
              y = clamp(y + d[1] + (rand() < 0.5 ? d[1] : 0), 0, N - 1);
            } else {
              x = clamp(x + d[0], 0, N - 1);
              y = clamp(y + d[1], 0, N - 1);
            }
          }
        }

        return next;
      }

      // TODO: chance for bigger oasis to spawn
      function applyOasisPatches(seedU32, tileKeyGrid, N, rarity) {
        const oasisVeg = new Set();
        if (rarity <= 0) return { grid: tileKeyGrid, oasisVeg };
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x7f4a7c1b);
        const patches = Math.max(1, Math.floor(1 + rarity * 3));
        const maxRadius = 1 + Math.floor(rarity * 2);

        const pickStart = () => {
          for (let tries = 0; tries < 120; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (k !== "water" && k !== "mountain" && k !== "settlement")
              return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          const { x: cx, y: cy } = pickStart();
          const bigBonus = rand() < 0.35 ? 1 : 0;
          const r = 1 + ((rand() * maxRadius) | 0) + bigBonus;

          for (let y = cy - r - 2; y <= cy + r + 2; y++) {
            for (let x = cx - r - 2; x <= cx + r + 2; x++) {
              if (x < 0 || x >= N || y < 0 || y >= N) continue;
              const dx = x - cx;
              const dy = y - cy;
              const dist = Math.abs(dx) + Math.abs(dy);
              if (dist > r + 2) continue;
              const k = next[y][x];
              if (k === "mountain" || k === "settlement") continue;
              if (dist <= r) {
                next[y][x] = "water";
              } else if (k !== "water") {
                if (dist === r + 2 && rand() < 0.4) continue;
                next[y][x] =
                  rand() < (dist === r + 2 ? 0.7 : 0.6) ? "grass" : "forest";
                oasisVeg.add(`${x},${y}`);
              }
            }
          }
        }

        return { grid: next, oasisVeg };
      }

      function applyMyceliumPatches(seedU32, tileKeyGrid, N, rarity) {
        if (rarity <= 0) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x91a2f5c3);
        const patches = Math.max(1, Math.floor(1 + rarity * 4));
        const totalCells = Math.floor(
          N * N * Math.min(0.95, 0.04 + rarity * 0.35),
        );
        const sizeBoost = 1 + rarity * 1.2;
        const stepsPerPatch = Math.max(
          12,
          Math.floor((totalCells / patches) * sizeBoost),
        );
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
          [1, 1],
          [-1, 1],
          [1, -1],
          [-1, -1],
        ];

        const isBlocked = (k) =>
          k === "water" ||
          k === "lava" ||
          k === "mountain" ||
          k === "desert";
        const fungalVariant = (k) => {
          if (k === "settlement")
            return rand() < 1 / 3 ? "fungal-settlement" : null;
          if (k === "ruins") return rand() < 0.6 ? "fungal-ruins" : null;
          if (k === "fungal-settlement" || k === "fungal-ruins") return k;
          return null;
        };

        const pickStart = () => {
          for (let tries = 0; tries < 140; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (k === "forest") return { x, y };
            if (!isBlocked(k) && rand() < 0.65) return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          let { x, y } = pickStart();
          const stepsThisPatch = Math.max(
            10,
            Math.floor(stepsPerPatch * (0.75 + rand() * 0.6)),
          );
          for (let i = 0; i < stepsThisPatch; i++) {
            if (x < 0 || x >= N || y < 0 || y >= N) break;
            const k = next[y][x];
            const fungal = fungalVariant(k);
            if (fungal) {
              next[y][x] = fungal;
            } else if (k === "settlement") {
              // Leave settlement as-is (2/3 chance) and keep walking.
            } else if (k === "ruins") {
              // Leave ruins as-is (1/2 chance) and keep walking.
            } else if (!isBlocked(k)) {
              next[y][x] = "mycelium";
            }
            const d = dirs[(rand() * dirs.length) | 0];
            if (rand() < 0.25) {
              x = clamp(x + d[0] + (rand() < 0.5 ? d[0] : 0), 0, N - 1);
              y = clamp(y + d[1] + (rand() < 0.5 ? d[1] : 0), 0, N - 1);
            } else {
              x = clamp(x + d[0], 0, N - 1);
              y = clamp(y + d[1], 0, N - 1);
            }
          }
        }

        return next;
      }

      function applyCrystalPatches(seedU32, tileKeyGrid, N, rarity) {
        if (rarity <= 0) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x1b873593);
        const patches = Math.max(1, Math.floor(1 + rarity * 4));
        const totalCells = Math.floor(
          N * N * Math.min(0.85, 0.03 + rarity * 0.22),
        );
        const stepsPerPatch = Math.max(10, Math.floor(totalCells / patches));
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
          [1, 1],
          [-1, 1],
          [1, -1],
          [-1, -1],
        ];

        const isBlocked = (k) =>
          k === "water" ||
          k === "lava" ||
          k === "mountain" ||
          k === "settlement" ||
          k === "fungal-settlement" ||
          k === "ruins" ||
          k === "fungal-ruins";

        const pickStart = () => {
          for (let tries = 0; tries < 140; tries++) {
            const x = (rand() * N) | 0;
            const y = (rand() * N) | 0;
            const k = next[y][x];
            if (isBlocked(k)) continue;
            if (k === "forest" && rand() < 0.45) continue;
            return { x, y };
          }
          return { x: (rand() * N) | 0, y: (rand() * N) | 0 };
        };

        for (let p = 0; p < patches; p++) {
          let { x, y } = pickStart();
          const stepsThisPatch = Math.max(
            10,
            Math.floor(stepsPerPatch * (0.75 + rand() * 0.7)),
          );
          for (let i = 0; i < stepsThisPatch; i++) {
            if (x < 0 || x >= N || y < 0 || y >= N) break;
            const k = next[y][x];
            if (!isBlocked(k)) {
              if (k !== "forest" || rand() < 0.55) next[y][x] = "crystal";
            }
            const d = dirs[(rand() * dirs.length) | 0];
            if (rand() < 0.25) {
              x = clamp(x + d[0] + (rand() < 0.5 ? d[0] : 0), 0, N - 1);
              y = clamp(y + d[1] + (rand() < 0.5 ? d[1] : 0), 0, N - 1);
            } else {
              x = clamp(x + d[0], 0, N - 1);
              y = clamp(y + d[1], 0, N - 1);
            }
          }
        }

        return next;
      }

      function applyBeachPatches(seedU32, tileKeyGrid, depthGrid, N) {
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x2b9f5ac1);
        const centers = [];

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            const k = tileKeyGrid[y][x];
            if (k !== "plains") continue;
            let shallowNeighbor = false;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (
                tileKeyGrid[ny][nx] === "water" &&
                (depthGrid?.[ny]?.[nx] || 1) === 1
              ) {
                shallowNeighbor = true;
                break;
              }
            }
            if (!shallowNeighbor) continue;
            if (rand() < 0.38) centers.push({ x, y });
          }
        }

        const touchesShallowWater = (x, y) => {
          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (
              tileKeyGrid[ny][nx] === "water" &&
              (depthGrid?.[ny]?.[nx] || 1) === 1
            )
              return true;
          }
          return false;
        };

        for (const c of centers) {
          const r = 2 + ((rand() * 4) | 0);
          for (let y = c.y - r - 1; y <= c.y + r + 1; y++) {
            for (let x = c.x - r - 1; x <= c.x + r + 1; x++) {
              if (x < 0 || x >= N || y < 0 || y >= N) continue;
              const k = next[y][x];
              if (k !== "plains") continue;
              const dist = Math.abs(x - c.x) + Math.abs(y - c.y);
              if (dist > r) continue;
              if (dist === r && rand() < 0.35) continue;
              if (!touchesShallowWater(x, y)) continue;
              next[y][x] = "beach";
            }
          }
        }

        return next;
      }

      function applyRuinsClusters(
        seedU32,
        tileKeyGrid,
        N,
        ruinCenters,
        rarity,
      ) {
        if (!Array.isArray(ruinCenters) || !ruinCenters.length || rarity <= 0)
          return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());

        const rand = rngUtil.xs32(seedU32 ^ 0x33b5c5a9);
        const hasMyceliumNeighbor = (x, y) => {
          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (next[ny][nx] === "mycelium") return true;
          }
          return false;
        };

        for (const center of ruinCenters) {
          const parts = String(center?.cell || "").split(",");
          const cx = Number(parts[0]);
          const cy = Number(parts[1]);
          if (!Number.isFinite(cx) || !Number.isFinite(cy)) continue;
          const k = next[cy]?.[cx];
          if (
            !k ||
            k === "water" ||
            k === "lava" ||
            k === "settlement" ||
            k === "fungal-settlement" ||
            k === "fungal-ruins"
          )
            continue;
          const nearMycelium =
            k === "mycelium" || hasMyceliumNeighbor(cx, cy);
          next[cy][cx] = nearMycelium && rand() < 0.6 ? "fungal-ruins" : "ruins";
        }

        return next;
      }

      function applyOvergrownRuins(seedU32, tileKeyGrid, N, climate) {
        const rainIdx = clamp((climate?.rainIdx ?? 3) + 1, 1, 8);
        if (rainIdx < 6) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        const rand = rngUtil.xs32(seedU32 ^ 0x6fbd1d97);
        const chance = 0.75;

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (next[y][x] === "ruins" && rand() < chance) {
              next[y][x] = "overgrown-ruins";
            }
          }
        }

        return next;
      }

      /* ====================== Forest typing (biome + climate) ====================== */
      function forestTypeForCell(
        seedU32,
        x,
        y,
        biome,
        climate,
        oasisVeg,
        biomeAllowsFeature,
      ) {
        const s = String(biome || "").toLowerCase();
        const tempTier = clamp(climate?.tempTier ?? 4, 1, 8);
        const rainIdx = clamp((climate?.rainIdx ?? 3) + 1, 1, 8);

        const isDeadBiome = biomeAllowsFeature(biome, "dead trees", 0.2);

        const isColdBiome =
          s.includes("tundra") ||
          s.includes("taiga") ||
          s.includes("ice") ||
          s.includes("highland");
        const isWetBiome =
          s.includes("wetland") ||
          s.includes("bog") ||
          s.includes("marsh") ||
          s.includes("floodplain") ||
          s.includes("jungle") ||
          s.includes("oceanic") ||
          s.includes("tidal") ||
          s.includes("canal") ||
          s.includes("lagoon") ||
          s.includes("reef");

        if (isDeadBiome) {
          if (oasisVeg?.has(`${x},${y}`)) return "deciduous";
          const roll = rngUtil.n2(seedU32, 70000 + x, 70100 + y);
          if (rainIdx >= 6 && roll < 0.18) return "deciduous";
          return "dead";
        }

        if (isColdBiome || tempTier <= 3) return "coniferous";

        if (isWetBiome) {
          if (oasisVeg?.has(`${x},${y}`)) return "deciduous";
          const roll = rngUtil.n2(seedU32, 70150 + x, 70175 + y);
          return roll < 0.9 ? "deciduous" : "coniferous";
        }

        if (tempTier >= 7 && rainIdx <= 2) {
          if (oasisVeg?.has(`${x},${y}`)) return "deciduous";
          if (isDeadBiome) {
            const roll = rngUtil.n2(seedU32, 70200 + x, 70300 + y);
            return roll < 0.6 ? "dead" : "deciduous";
          }
          return "dead";
        }

        if (rainIdx >= 6 && tempTier >= 5) return "deciduous";

        const roll = rngUtil.n2(seedU32, 70400 + x, 70500 + y);
        return roll < 0.18 ? "coniferous" : "deciduous";
      }

      function forestGlyphForType(ft, seed01, tileset) {
        const t = tileset.forest;
        const list =
          ft === "coniferous"
            ? t.coniferous
            : ft === "dead"
              ? t.dead
              : ft === "deciduous"
                ? t.deciduous
                : baseGlyphs(t);
        const idx = Math.floor(seed01 * list.length);
        return list[idx] || firstBaseGlyph(t, "?");
      }

      function initGrid(N, fill = "plains") {
        return Array.from({ length: N }, () => Array(N).fill(fill));
      }

      function maybeApplyMountainBias(seedU32, weights, normalizeWeights) {
        const mountainBias = rngUtil.n2(seedU32, 90500, 90600) < 0.3;
        if (!mountainBias) return weights;
        weights.mountain = Math.max(0.01, weights.mountain * 1.7);
        weights.plains *= 0.85;
        weights.grass *= 0.85;
        weights.forest *= 0.85;
        weights.water *= 0.9;
        normalizeWeights(weights);
        return weights;
      }

      function buildRiver(seedU32, biome, N, biomeAllowsFeature) {
        const riverType = biomeAllowsFeature(biome, "river-lava")
          ? "lava"
          : biomeAllowsFeature(biome, "river-water")
            ? "water"
            : null;
        const river =
          riverType && rngUtil.n2(seedU32, 42000, 43000) > 0.35
            ? riverCells(seedU32 ^ 0x9e3779b9, N)
            : new Set();
        return { riverType, river };
      }

      function applyInitialTiles(
        seedU32,
        tileKeyGrid,
        weights,
        N,
        riverType,
        river,
        pickByWeights,
      ) {
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            let tileKey;
            if (riverType && river.has(`${x},${y}`)) {
              tileKey = riverType;
            } else {
              const r0 = rngUtil.n2(seedU32, x, y);
              tileKey = pickByWeights(r0, weights);
              if (
                tileKey !== "water" &&
                rngUtil.n2(seedU32, 7000 + x, 8000 + y) > 0.985
              )
                tileKey = "settlement";
            }
            next[y][x] = tileKey;
          }
        }
        return next;
      }

      function desertAllEnabled(seedU32, biome) {
        if (
          !String(biome || "")
            .toLowerCase()
            .includes("desert")
        )
          return false;
        return rngUtil.n2(seedU32, 4242, 31337) < 0.5;
      }

      function applyDesertAll(tileKeyGrid, N, desertAll) {
        if (!desertAll) return tileKeyGrid;
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (next[y][x] === "plains") next[y][x] = "desert";
          }
        }
        return next;
      }

      function thinDesertForests(
        seedU32,
        tileKeyGrid,
        N,
        biome,
        climate,
        oasisVeg = null,
      ) {
        if (
          !String(biome || "")
            .toLowerCase()
            .includes("desert")
        )
          return tileKeyGrid;
        const rainIdx = clamp(climate?.rainIdx ?? 3, 0, 7);
        const isArid = rainIdx <= 1;
        const thinChance = isArid ? 0.75 : 0.55;
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "forest") continue;
            if (oasisVeg?.has(`${x},${y}`)) continue;
            const roll = rngUtil.n2(seedU32, 75000 + x, 76000 + y);
            if (roll < thinChance) next[y][x] = "desert";
          }
        }
        return next;
      }

      function boostMountainHeights(heightGrid, tileKeyGrid, N, ridgeRarity) {
        if (!Number.isFinite(ridgeRarity) || ridgeRarity <= 0)
          return heightGrid;
        const next = heightGrid.map((row) => row.slice());
        const heightBoost = 1 + ridgeRarity * 0.6;
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") continue;
            next[y][x] = clamp(Math.round(next[y][x] * heightBoost), 1, 5);
          }
        }
        return next;
      }

      function buildForestTypeGrid(
        seedU32,
        tileKeyGrid,
        N,
        biome,
        climate,
        oasisVeg,
        biomeAllowsFeature,
      ) {
        const forestTypeGrid = Array.from({ length: N }, () =>
          Array(N).fill(null),
        );
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] === "forest") {
              forestTypeGrid[y][x] = forestTypeForCell(
                seedU32,
                x,
                y,
                biome,
                climate,
                oasisVeg,
                biomeAllowsFeature,
              );
            }
          }
        }
        return forestTypeGrid;
      }

      function renderMapHtml(
        seedU32,
        tileKeyGrid,
        depthGrid,
        heightGrid,
        forestTypeGrid,
        N,
        worldMeta,
        tileset,
        pickVariant,
      ) {
        const ann = worldMeta?.annotations || new Map();
        const rpick = rngUtil.xs32((seedU32 ^ 0x5a5a5a5a) >>> 0);

        let s = "";
        for (let y = 0; y < N; y++) {
          let row = "";
          for (let x = 0; x < N; x++) {
            const tileKey = tileKeyGrid[y][x];
            const key = `${x},${y}`;
            const a = ann.get(key);

            const contentParts = [];
            if (tileKey === "water" || tileKey === "lava")
              contentParts.push(
                `depth: ${clamp(depthGrid[y][x] || 1, 1, 3)}`,
              );
            if (tileKey === "mountain")
              contentParts.push(
                `height: ${clamp(heightGrid[y][x] || 1, 1, 5)}`,
              );
            if (tileKey === "forest")
              contentParts.push(`forest: ${forestTypeGrid[y][x] || "mixed"}`);
            if (a?.settlementName) {
              contentParts.push(`${a.settlementType}: ${a.settlementName}`);
            }
            if (a?.fieldCamp) contentParts.push("Field Camp");
            if (a?.poi?.length) {
              for (const p of a.poi) {
                if (a?.religious && p.type === "religious") continue;
                contentParts.push(`POI: ${p.name}`);
              }
            }
            if (a?.religious) contentParts.push(a.religious.label);

            const factionParts = [];
            if (a?.factions?.length)
              for (const f of a.factions)
                factionParts.push(`Faction: ${f.name}`);
            if (a?.factionOps?.length)
              for (const f of a.factionOps)
                factionParts.push(`Faction Activity: ${f.name} â€” ${f.verb}`);

            const npcParts = [];
            if (a?.npcs?.length)
              for (const n of a.npcs)
                npcParts.push(`NPC: ${n.name} â€” ${n.task}`);

            const title = escAttr(
              [
                `${tileKey}    ${x},${y}`,
                ...contentParts,
                ...factionParts,
                ...npcParts,
              ]
                .filter(Boolean)
                .join("\n"),
            );

            const showStructure =
              a?.poiStructure &&
              !a?.fieldCamp &&
              !a?.religious &&
              tileKey !== "water";

            if (showStructure) {
              const variantSeed = rngUtil.n2(seedU32, x + 999, y + 999);
              const ch = pickVariant("settlement", tileset, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="settlement" data-poi="structure" title="${title}">${ch}</span>`;
            } else if (a?.fieldCamp) {
              const ch =
                rngUtil.oneOf(rpick, baseGlyphs(tileset.camp)) ||
                firstBaseGlyph(tileset.settlement) ||
                firstBaseGlyph(tileset.plains, "?");
              row += `<span data-cell="${x},${y}" data-tile="camp" title="${title}">${ch}</span>`;
            } else if (a?.religious) {
              const rel = a.religious;
              const fallbackRel =
                tileset.religious?.death ||
                tileset.religious?.monastery ||
                firstBaseGlyph(tileset.settlement) ||
                firstBaseGlyph(tileset.plains, "?");
              const ch =
                rngUtil.oneOf(rpick, rel.glyph) || rngUtil.oneOf(rpick, tileset.religious?.[rel.kind]) || fallbackRel;
              row += `<span data-cell="${x},${y}" data-tile="religious" data-religious="${escAttr(rel.kind)}" title="${title}">${ch}</span>`;
            } else if (tileKey === "water" || tileKey === "lava") {
              const d = clamp(depthGrid[y][x] || 1, 1, 3);
              const ch = liquidGlyph(tileKey, d, tileset, seedU32, x, y);
              row += `<span data-cell="${x},${y}" data-tile="${tileKey}" data-depth="${d}" title="${title}">${ch}</span>`;
            } else if (tileKey === "mountain") {
              const h = clamp(heightGrid[y][x] || 1, 1, 5);
              const ch = mountainGlyph(h, tileset);
              row += `<span data-cell="${x},${y}" data-tile="mountain" data-height="${h}" title="${title}">${ch}</span>`;
            } else if (tileKey === "forest") {
              const ft = forestTypeGrid[y][x] || "mixed";
              const variantSeed = rngUtil.n2(seedU32, x + 999, y + 999);
              const ch = forestGlyphForType(ft, variantSeed, tileset);
              row += `<span data-cell="${x},${y}" data-tile="forest" data-forest="${escAttr(ft)}" title="${title}">${ch}</span>`;
            } else if (tileKey === "crystal") {
              const variantSeed = rngUtil.n2(seedU32, x + 777, y + 777);
              const variants = ["blue", "pink", "green"];
              const v =
                variants[Math.floor(variantSeed * variants.length)] || "blue";
              const ch = pickVariant(tileKey, tileset, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="crystal" data-crystal="${v}" title="${title}">${ch}</span>`;
            } else {
              const variantSeed = rngUtil.n2(seedU32, x + 999, y + 999);
              const ch = pickVariant(tileKey, tileset, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="${tileKey}" title="${title}">${ch}</span>`;
            }
          }
          s += row + (y < N - 1 ? "\n" : "");
        }

        return s;
      }

      // #endregion Map Generation
      // #region UI + State
      /* ====================== State, Storage, UI ====================== */
      class UIController {
        constructor(doc, storage, worldBuilder, mapGenerator) {
          this.doc = doc;
          this.storage = storage;
          this.worldBuilder = worldBuilder;
          this.mapGenerator = mapGenerator;
        }

        load() {
          return loadLS();
        }

        save() {
          return saveLS();
        }

        renderLists() {
          return renderLists();
        }

        setCurrentSeed(s, push = true) {
          return setCurrentSeed(s, push);
        }

        generate() {
          return generate();
        }

        bindCrossHover() {
          return bindCrossHover();
        }

        wireEvents() {}
      }

      const $ = (sel) => document.querySelector(sel);
      const out = $("#out"),
        mapEl = $("#map"),
        seedIn = $("#seed"),
        seedShow = $("#seedShow"),
        seedPill = document.querySelector(".seedpill"),
        themeSel = $("#theme"),
        btnGen = $("#gen"),
        btnPrev = $("#prev"),
        btnNext = $("#next"),
        btnCopySeed = $("#copySeed"),
        histList = $("#hist"),
        favList = $("#favs"),
        btnClrFav = $("#clrFav"),
        // btnSave = $("#save"),
        // btnCopyOut = $("#copyOut"),
        // btnShare = $("#share"),

        LS_H = "sow_history_v2",
        LS_F = "sow_faves_v2",
        MAXH = 99;

      const ui = new UIController(
        document,
        localStorage,
        worldBuilder,
        mapGenerator,
      );

      let histArr = [],
        faves = [],
        idx = -1,
        current = "";

      function loadLS() {
        try {
          histArr = JSON.parse(localStorage.getItem(LS_H) || "[]");
          faves = JSON.parse(localStorage.getItem(LS_F) || "[]");
        } catch (e) {
          histArr = [];
          faves = [];
        }
      }

      function saveLS() {
        localStorage.setItem(LS_H, JSON.stringify(histArr.slice(-MAXH)));
        localStorage.setItem(LS_F, JSON.stringify([...new Set(faves)]));
      }

      function renderLists() {
        if (!histList || !favList) return;

        histList.innerHTML = "";
        const recent = histArr.slice(-MAXH).slice().reverse();
        recent.forEach((s) => {
          const li = document.createElement("li");
          li.textContent = s;
          li.title = "Load seed";
          li.onclick = () => {
            ui.setCurrentSeed(s, true);
            ui.generate();
          };
          histList.appendChild(li);
        });

        favList.innerHTML = "";
        faves.forEach((s) => {
          const li = document.createElement("li");
          li.textContent = s;
          li.title = "Load favorite";
          li.onclick = () => {
            ui.setCurrentSeed(s, true);
            ui.generate();
          };
          favList.appendChild(li);
        });
      }

      function pushHistory(s) {
        if (!s) return;
        if (histArr.length === 0 || histArr[histArr.length - 1] !== s)
          histArr.push(s);
        if (histArr.length > MAXH) histArr = histArr.slice(-MAXH);
        idx = histArr.length - 1;
        ui.save();
        ui.renderLists();
      }

      function navigate(d) {
        if (!histArr.length) return;
        idx = Math.max(0, Math.min(histArr.length - 1, idx + d));
        ui.setCurrentSeed(histArr[idx], false);
        ui.generate();
      }

      function setCurrentSeed(s, push = true) {
        current = s;
        seedShow.textContent = s;
        if (push) pushHistory(s);
        updateHash();
      }

      function parseHash() {
        const h = location.hash.replace(/^#/, "");
        const params = new URLSearchParams(h.includes("=") ? h : "");
        const s = params.get("s"),
          t = params.get("t");
        return {
          s: s ? decodeURIComponent(s) : null,
          t: t ? decodeURIComponent(t) : null,
        };
      }

      function updateHash() {
        if (!current) return;
        const t = themeSel.value;
        const h = `s=${encodeURIComponent(current)}&t=${encodeURIComponent(t)}`;
        if (location.hash !== `#${h}`)
          window.history.replaceState(null, "", `#${h}`);
      }

      function resolveTheme(seed, sel, themeTables) {
        if (sel !== "rnd") return sel;
        const keys = Object.keys(themeTables);
        return keys[rngUtil.h32(seed) % keys.length];
      }

      function doGenerate() {
        const typed = seedIn.value.trim();
        const s = typed || rngUtil.randSeed();
        ui.setCurrentSeed(s, true);
        ui.generate();
      }

      /* ====================== Cross-hover binding ====================== */
      let _crossHoverBound = false;

      function bindCrossHover() {
        if (_crossHoverBound) return;
        _crossHoverBound = true;

        const clearHot = () => {
          document
            .querySelectorAll(".is-hot")
            .forEach((el) => el.classList.remove("is-hot"));
        };

        const markCell = (cell) => {
          clearHot();
          if (!cell) return;

          const esc =
            window.CSS && CSS.escape
              ? CSS.escape(cell)
              : cell.replace(/"/g, '\\"');

          mapEl
            .querySelectorAll(`span[data-cell="${esc}"]`)
            .forEach((el) => el.classList.add("is-hot"));
          out
            .querySelectorAll(`.xref[data-cell="${esc}"]`)
            .forEach((el) => el.classList.add("is-hot"));
        };

        out.addEventListener("pointerover", (e) => {
          const t = e.target.closest?.(".xref[data-cell]");
          if (!t) return;
          markCell(t.dataset.cell);
        });

        out.addEventListener("pointerout", (e) => {
          const t = e.target.closest?.(".xref[data-cell]");
          if (!t) return;
          const rt = e.relatedTarget;
          if (rt && rt.closest?.(".xref[data-cell]")) return;
          clearHot();
        });

        mapEl.addEventListener("pointerover", (e) => {
          const t = e.target.closest?.("span[data-cell]");
          if (!t) return;
          markCell(t.dataset.cell);
        });

        mapEl.addEventListener("pointerout", (e) => {
          const t = e.target.closest?.("span[data-cell]");
          if (!t) return;
          const rt = e.relatedTarget;
          if (rt && rt.closest?.("span[data-cell]")) return;
          clearHot();
        });
      }

      function generate() {
        if (!current) return;
        const themeUsed = resolveTheme(
          current,
          themeSel.value,
          worldBuilder.themes,
        );
        const { html, mapGrid, mapFlags } = worldBuilder.buildSlice(
          current,
          themeUsed,
        );
        out.innerHTML = html;
        mapEl.innerHTML = mapGrid;
        mapEl.dataset.deadTrees = mapFlags?.deadTrees ? "1" : "";
        mapEl.dataset.desert = mapFlags?.desert ? "1" : "";
        ui.bindCrossHover();
      }

      function buildTilesetShowcaseGroups() {
        const groups = [];
        const seen = new Set();

        const addGroup = (label) => {
          const group = { label, entries: [] };
          groups.push(group);
          return group;
        };

        const addGlyph = (group, tileKey, glyph, attrs = {}) => {
          if (!glyph || seen.has(glyph)) return;
          seen.add(glyph);
          group.entries.push({ tileKey, glyph, attrs });
        };

        const addList = (group, tileKey, list, attrs = {}) => {
          if (!list) return;
          const arr = Array.isArray(list) ? list : [list];
          for (const glyph of arr) addGlyph(group, tileKey, glyph, attrs);
        };

        const gWater = addGroup("water");
        const water = tileset.water?.depthGlyphs || {};
        addList(gWater, "water", water[1], { depth: 1 });
        addList(gWater, "water", water[2], { depth: 2 });
        addList(gWater, "water", water[3], { depth: 3 });

        const gMountain = addGroup("mountain");
        const mountain = tileset.mountain?.height || {};
        for (const h of [1, 2, 3, 4, 5]) {
          addList(gMountain, "mountain", mountain[h], { height: h });
        }

        const gForest = addGroup("forest");
        const forest = tileset.forest || {};
        addList(gForest, "forest", forest.base, { forest: "mixed" });
        addList(gForest, "forest", forest.coniferous, {
          forest: "coniferous",
        });
        addList(gForest, "forest", forest.dead, { forest: "dead" });
        addList(gForest, "forest", forest.deciduous, {
          forest: "deciduous",
        });

        const gGrass = addGroup("grass");
        addList(gGrass, "grass", tileset.grass);

        const gPlains = addGroup("plains");
        addList(gPlains, "plains", tileset.plains);

        const gBeach = addGroup("beach");
        addList(gBeach, "beach", tileset.beach);

        const gDesert = addGroup("desert");
        addList(gDesert, "desert", tileset.desert);

        const gMyc = addGroup("mycelium");
        addList(gMyc, "mycelium", tileset.mycelium);

        const gSettlement = addGroup("settlement");
        addList(gSettlement, "settlement", tileset.settlement);

        const gRuins = addGroup("ruins");
        addList(gRuins, "ruins", tileset.ruins);

        const gOvergrownRuins = addGroup("overgrown-ruins");
        addList(
          gOvergrownRuins,
          "overgrown-ruins",
          tileset["overgrown-ruins"],
        );

        const gFungalSettlement = addGroup("fungal-settlement");
        addList(gFungalSettlement, "fungal-settlement", tileset["fungal-settlement"]);

        const gFungalRuins = addGroup("fungal-ruins");
        addList(gFungalRuins, "fungal-ruins", tileset["fungal-ruins"]);

        const gCamp = addGroup("camp");
        addList(gCamp, "camp", tileset.camp);

        const gRel = addGroup("religious");
        const rel = tileset.religious || {};
        addList(gRel, "religious", rel.death, { religious: "death" });
        addList(gRel, "religious", rel.monastery, {
          religious: "monastery",
        });

        const gCrystal = addGroup("crystal");
        addList(gCrystal, "crystal", tileset.crystal);

        return groups.filter((g) => g.entries.length);
      }

      function renderTilesetShowcase() {
        let s = "";
        const groups = buildTilesetShowcaseGroups();
        let row = 0;

        for (const group of groups) {
          const label = `<span class="map-label">${escHtml(group.label)}:</span>`;
          s += label + " ";
          for (let i = 0; i < group.entries.length; i++) {
            const col = i + 1;
            const { tileKey, glyph, attrs } = group.entries[i];
            const cell = `${col},${row}`;

            const dataParts = [
              `data-cell="${cell}"`,
              `data-tile="${tileKey}"`,
            ];
            if (attrs.depth) dataParts.push(`data-depth="${attrs.depth}"`);
            if (attrs.height) dataParts.push(`data-height="${attrs.height}"`);
            if (attrs.forest)
              dataParts.push(`data-forest="${escAttr(attrs.forest)}"`);
            if (attrs.religious)
              dataParts.push(`data-religious="${escAttr(attrs.religious)}"`);

            const titleParts = [tileKey, cell];
            if (attrs.depth) titleParts.push(`depth: ${attrs.depth}`);
            if (attrs.height) titleParts.push(`height: ${attrs.height}`);
            if (attrs.forest) titleParts.push(`forest: ${attrs.forest}`);
            if (attrs.religious)
              titleParts.push(`religious: ${attrs.religious}`);
            const title = titleParts.join("    ");

            s += `<span ${dataParts.join(" ")} title="${escAttr(title)}">${glyph}</span>`;
          }
          row++;
          s += "\n";
        }

        mapEl.innerHTML = s;
        mapEl.dataset.deadTrees = "";
        mapEl.dataset.desert = "";
        out.textContent = "Tileset showcase";
        ui.bindCrossHover();
      }

      function shareURL() {
        if (!current) return;
        updateHash();
      }

      // #endregion UI + State
      // #region Events + Init
      /* ====================== Events + Init ====================== */
      btnGen.onclick = doGenerate;
      seedIn.addEventListener("keydown", (e) => {
        if (e.key === "Enter") doGenerate();
      });
      btnPrev.onclick = () => navigate(-1);
      btnNext.onclick = () => navigate(1);

      // btnSave.onclick = () => {
      //   if (!current) return;
      //   if (!faves.includes(current)) faves.push(current);
      //   saveLS();
      //   renderLists();
      // };

      btnCopySeed.onclick = () => {
        if (current) navigator.clipboard?.writeText(current);
      };

      if (seedPill) {
        seedPill.addEventListener("click", (e) => {
          if (!e.shiftKey) return;
          e.preventDefault();
          e.stopPropagation();
          renderTilesetShowcase();
        });
      }

      // btnCopyOut.onclick = () => navigator.clipboard?.writeText((out.textContent || "") + "\n" + (mapEl.textContent || ""));

      // btnShare.onclick = () => shareURL();

      // if (btnClrFav) {
      //   btnClrFav.onclick = () => {
      //     if (!faves.length) return;
      //     if (!confirm("Clear all favorites?")) return;
      //     faves = [];
      //     ui.save();
      //     ui.renderLists();
      //   };
      // }

      themeSel.onchange = () => {
        ui.generate();
        updateHash();
      };

      window.addEventListener("hashchange", () => {
        const { s, t } = parseHash();
        if (t) themeSel.value = t;
        if (s) {
          ui.setCurrentSeed(s, true);
          ui.generate();
        }
      });

      (function init() {
        ui.load();
        ui.renderLists();
        const { s, t } = parseHash();
        if (t) themeSel.value = t;

        if (s) {
          ui.setCurrentSeed(s, true);
        } else if (histArr.length) {
          ui.setCurrentSeed(histArr[histArr.length - 1], false);
          idx = histArr.length - 1;
        } else {
          ui.setCurrentSeed(rngUtil.randSeed(), true);
        }
        ui.generate();
      })();

      // #endregion Events + Init
    </script>
  </body>
</html>
